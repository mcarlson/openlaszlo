<chapter id="input-devices">

<title>Input Devices and Gestures</title>




<para/><section><title>Overview</title>
<para>
This chapter explains how to incorporate mouse and keyboard input into an OpenLaszlo application. It covers the basic concepts
as well as more advanced topics such as tracking the mouse across multiple views while the mouse is down, and how to implement the "right click" context menu in OpenLaszlo applications. 
</para>

<para/></section><section><title>The Mouse</title>

<para>
Interaction with a view via the mouse is fundamental to all applications. These sections will explore the basic concepts as well
some more advanced topics.
</para>
<para/><section><title>Basic Mouse Events</title>
<para> Interacting with the example below displays the five basic mouse events that can be recognized by a view.
</para> 
<para> <emphasis role="b">Mouse events</emphasis>: onmouseover, onmouseout, onmousedown, onmouseup, onclick </para>
<para>
	Though onmouseup and onclick are similar, onmouseup is sent whenever the user lets up on the mouse, while 
	onclick is only sent when the user lets up on the mouse while the cursor is still contained within the boundary of the view.
</para>
<example role="live-example">
   <title>The basic mouse events</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$1.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>The basic mouse events</title><programlisting role="lzx-embednew"><filename>input-devices-$1.lzx</filename><parameter/><code>
&lt;canvas height="40"&gt;
  &lt;view bgcolor="red"
        onmouseover="txt.setText('onmouseover')"
        onmouseout="txt.setText('onmouseout')"
        onmousedown="txt.setText('onmousedown')"
        onmouseup="txt.setText('onmouseup')"
        onclick="txt.setText('onmouseup, onclick')"
        x="10" y="10" width="20" height="20"/&gt;

  &lt;text id="txt"
        x="40" y="11" width="150"/&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas height="40"&gt;
  &lt;view bgcolor="red"
        onmouseover="txt.setText('onmouseover')"
        onmouseout="txt.setText('onmouseout')"
        onmousedown="txt.setText('onmousedown')"
        onmouseup="txt.setText('onmouseup')"
        onclick="txt.setText('onmouseup, onclick')"
        x="10" y="10" width="20" height="20"/&gt;

  &lt;text id="txt"
        x="40" y="11" width="150"/&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$1.lzx></example?>

<para/></section><section><title>Making Views Clickable</title>
<para>
	A view will only respond to mouse events when its attribute clickable="true". Views, by default, are not clickable. 
	If, however,  any of the mouse events are included in a view's tag ( like above ) then clickable will be set to true automatically.
    In the example below, there are no mouse events declared within the tag itself, only in its methods. In this case it becomes
    necessary to explicitly define clickable="true" for the view.
</para>
<example role="live-example">
   <title>Making views clickable</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$2.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>Making views clickable</title><programlisting role="lzx-embednew"><filename>input-devices-$2.lzx</filename><parameter/><code>
&lt;canvas height="40"&gt;
  &lt;view bgcolor="red" clickable="true"
         x="10" y="10"
         width="20" height="20"&gt;
    &lt;handler name="onmousedown"&gt;
      this.setWidth(30);
      this.setheight(30);
      this.setX(5);
      this.setY(5);
    &lt;/handler&gt;
    &lt;handler name="onmouseup"&gt;
      this.setWidth(20);
      this.setheight(20);
      this.setX(10);
      this.setY(10);
    &lt;/handler&gt;
  &lt;/view&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas height="40"&gt;
  &lt;view bgcolor="red" clickable="true"
         x="10" y="10"
         width="20" height="20"&gt;
    &lt;handler name="onmousedown"&gt;
      this.setWidth(30);
      this.setheight(30);
      this.setX(5);
      this.setY(5);
    &lt;/handler&gt;
    &lt;handler name="onmouseup"&gt;
      this.setWidth(20);
      this.setheight(20);
      this.setX(10);
      this.setY(10);
    &lt;/handler&gt;
  &lt;/view&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$2.lzx></example?>

<para/></section><section><title>ClickRegion</title>
<para>
Setting clickregion to a vector-based SWF turns the SWF shape into a clickable hotspot.
</para>

<example role="live-example">
   <title>Setting a clickregion</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/clickregion.lzx"/></textobject> 
    </programlisting>
</example>

<?example role="live-example"><title>Setting a clickregion</title><programlisting role="lzx-embednew"><filename>clickregion.lzx</filename><parameter/><code>
&lt;canvas width="500" height="500" debug="true"&gt;
  &lt;view height="150" width="100" bgcolor="red" clickable="true" resource="../resources/test_triangle.swf" stretches="both" clickregion="../resources/test_triangle.swf" onclick="Debug.write('click')" /&gt;
&lt;/canvas&gt; 
</code></programlisting><?lzx-edit programs/clickregion.lzx></example?>

<para/></section><section><title>Cursor Management</title>
<para>
The cursor automatically changes to a hand when it is over a clickable view, but if a custom cursor is desired, then
this can be accomplished by defining a custom resource for the cursor and using it with LzCursor service as shown below.
</para>

<example role="live-example">
   <title>Changing the cursor</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$3.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>Changing the cursor</title><programlisting role="lzx-embednew"><filename>input-devices-$3.lzx</filename><parameter/><code>
&lt;canvas height="30"&gt;
  &lt;resource name="waitcursor" src="resources/lzwaitcursor_rsc.swf"/&gt;
  &lt;button onclick="setCursor()" text="Click me to change the cursor for 1/2 second"&gt;
    &lt;method name="setCursor"&gt;
      LzCursor.setCursorGlobal('waitcursor');
      // call LzCursor.restoreCursor() after 1/2 second
      var del= new LzDelegate(LzCursor, 'restoreCursor');
      LzTimer.addTimer(del, 500);
    &lt;/method&gt;
  &lt;/button&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas height="30"&gt;
  &lt;resource name="waitcursor" src="resources/lzwaitcursor_rsc.swf"/&gt;
  &lt;button onclick="setCursor()" text="Click me to change the cursor for 1/2 second"&gt;
    &lt;method name="setCursor"&gt;
      LzCursor.setCursorGlobal('waitcursor');
      // call LzCursor.restoreCursor() after 1/2 second
      var del= new LzDelegate(LzCursor, 'restoreCursor');
      LzTimer.addTimer(del, 500);
    &lt;/method&gt;
  &lt;/button&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$3.lzx></example?>

<para/><section><title>Disabling the "hand" cursor</title>
<para>By setting <indexterm><primary><literal>LzCursor.showHandCursor()</literal></primary></indexterm><methodname>LzCursor.showHandCursor()</methodname> to true or false, you show or hide the hand cursor for all clickable views.
This means that you can, for example, prevent clicks from traveling
through windows, without the hand cursor appearing.</para>
<para>Here is an example showing the hand cursor turned on and off.</para>

<example role="live-example">
   <title>Enabling and disabling the hand cursor</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$4.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>enabling and disabling the hand cursor</title><programlisting role="lzx-embednew"><filename>input-devices-$4.lzx</filename><parameter/><code>
&lt;canvas&gt;
    &lt;view width="100" height="100" bgcolor="green"&gt;
        &lt;handler name="onclick"&gt;
            LzCursor.showHandCursor(true);
        &lt;/handler&gt;
    &lt;/view&gt;
    &lt;view x="110" width="100" height="100" bgcolor="yellow"&gt;
        &lt;handler name="onmouseover"&gt;
            LzCursor.showHandCursor(true);
        &lt;/handler&gt;
        &lt;handler name="onmouseout"&gt;
            LzCursor.showHandCursor(false);
        &lt;/handler&gt;
    &lt;/view&gt;
    &lt;view x="220" width="100" height="100" bgcolor="red"&gt;
        &lt;handler name="onclick"&gt;
            LzCursor.showHandCursor(false);
        &lt;/handler&gt;
    &lt;/view&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas&gt;
    &lt;view width="100" height="100" bgcolor="green"&gt;
        &lt;handler name="onclick"&gt;
            LzCursor.showHandCursor(true);
        &lt;/handler&gt;
    &lt;/view&gt;
    &lt;view x="110" width="100" height="100" bgcolor="yellow"&gt;
        &lt;handler name="onmouseover"&gt;
            LzCursor.showHandCursor(true);
        &lt;/handler&gt;
        &lt;handler name="onmouseout"&gt;
            LzCursor.showHandCursor(false);
        &lt;/handler&gt;
    &lt;/view&gt;
    &lt;view x="220" width="100" height="100" bgcolor="red"&gt;
        &lt;handler name="onclick"&gt;
            LzCursor.showHandCursor(false);
        &lt;/handler&gt;
    &lt;/view&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$4.lzx></example?>
<para/></section></section><section><title>Custom Cursors for multiple runtimes</title>
<para>
With OpenLaszlo 4, you can set custom cursors in DHTML and SWF. If you plan to use custom cursors across DHTML and SWF, be sure you're using appropriate cursor IDs for DHTML (see http://www.quirksmode.org/css/cursor.html for more info), and make sure you've included resources named after those IDs for SWF. See test/cursors.lzx for an example. Also note that global cursors currently only work for clickable items in DHTML.
</para>
<para/></section><section><title>Custom buttons</title>
<para>Creating a custom button that changes its images with onmouseup, onmouseover, and onmousedown is a common practice.  Here is an example using the <indexterm><primary>basebutton</primary></indexterm><sgmltag class="element">&lt;basebutton&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: basebutton-->
 tag: 

</para>
<example role="live-example">
   <title>Creating a custom button using basebutton</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$5.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>Creating a custom button using basebutton</title><programlisting role="lzx-embednew"><filename>input-devices-$5.lzx</filename><parameter/><code>
&lt;canvas height="150"&gt;
  &lt;!-- first create the multi-frame resource and give it a name --&gt;
  &lt;resource name="mybutton_rsrc"&gt;
    &lt;!-- first frame MUST be the mouseup state of the button --&gt;     
    &lt;frame src="resources/button-up.png"/&gt;
    &lt;!-- second frame MUST be the mouseover state of the button --&gt;
    &lt;frame src="resources/button-over.png"/&gt;
    &lt;!-- third frame MUST be the mousedown state of the button --&gt;
    &lt;frame src="resources/button-down.png"/&gt;
  &lt;/resource&gt;
  
  &lt;!-- Second, assign the resource to a basebutton tag --&gt;
  &lt;basebutton resource="mybutton_rsrc"/&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas height="150"&gt;
  &lt;!-- first create the multi-frame resource and give it a name --&gt;
  &lt;resource name="mybutton_rsrc"&gt;
    &lt;!-- first frame MUST be the mouseup state of the button --&gt;     
    &lt;frame src="resources/button-up.png"/&gt;
    &lt;!-- second frame MUST be the mouseover state of the button --&gt;
    &lt;frame src="resources/button-over.png"/&gt;
    &lt;!-- third frame MUST be the mousedown state of the button --&gt;
    &lt;frame src="resources/button-down.png"/&gt;
  &lt;/resource&gt;
  
  &lt;!-- Second, assign the resource to a basebutton tag --&gt;
  &lt;basebutton resource="mybutton_rsrc"/&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$5.lzx></example?>

<para/></section><section><title>Dragging Views</title>
<para>Dragging a view can be accomplished with the use of a dragstate. When a dragstate is applied, views
can be dragged freely or constrained to a boundary as well as an axis.
The example below shows the use of a dragstate with its max, min, and axis attributes.</para>

<example role="live-example">
   <title>Dragging a view</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$6.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>dragging a view</title><programlisting role="lzx-embednew"><filename>input-devices-$6.lzx</filename><parameter/><code>
&lt;canvas height="120"&gt;
  &lt;simplelayout spacing="3"/&gt;
  
  &lt;text&gt;dragging within a bounded area&lt;/text&gt;
  &lt;view bgcolor="yellow" height="40" width="160"&gt;
    &lt;view bgcolor="red" width="20" height="20" 
          onmousedown="this.dragger.apply()"
          onmouseup="this.dragger.remove()"&gt;
      &lt;dragstate name="dragger"
          drag_min_x="0"
          drag_max_x="$once{parent.width - this.width}"
          drag_min_y="0"
          drag_max_y="$once{parent.height - this.height}"
          drag_axis="both"/&gt;
    &lt;/view&gt;
  &lt;/view&gt;
  
  &lt;text&gt;dragging along the x-axis&lt;/text&gt;
  &lt;view bgcolor="yellow" height="40" width="160"&gt;
    &lt;view bgcolor="red" width="20" height="20" 
          onmousedown="this.dragger.apply()"
          onmouseup="this.dragger.remove()"&gt;
      &lt;dragstate name="dragger"
          drag_min_x="0"
          drag_max_x="$once{parent.width - this.width}"
          drag_min_y="0"
          drag_max_y="$once{parent.height - this.height}"
          drag_axis="x"/&gt;
    &lt;/view&gt;
  &lt;/view&gt;
 &lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas height="120"&gt;
  &lt;simplelayout spacing="3"/&gt;
  
  &lt;text&gt;dragging within a bounded area&lt;/text&gt;
  &lt;view bgcolor="yellow" height="40" width="160"&gt;
    &lt;view bgcolor="red" width="20" height="20" 
          onmousedown="this.dragger.apply()"
          onmouseup="this.dragger.remove()"&gt;
      &lt;dragstate name="dragger"
          drag_min_x="0"
          drag_max_x="$once{parent.width - this.width}"
          drag_min_y="0"
          drag_max_y="$once{parent.height - this.height}"
          drag_axis="both"/&gt;
    &lt;/view&gt;
  &lt;/view&gt;
  
  &lt;text&gt;dragging along the x-axis&lt;/text&gt;
  &lt;view bgcolor="yellow" height="40" width="160"&gt;
    &lt;view bgcolor="red" width="20" height="20" 
          onmousedown="this.dragger.apply()"
          onmouseup="this.dragger.remove()"&gt;
      &lt;dragstate name="dragger"
          drag_min_x="0"
          drag_max_x="$once{parent.width - this.width}"
          drag_min_y="0"
          drag_max_y="$once{parent.height - this.height}"
          drag_axis="x"/&gt;
    &lt;/view&gt;
  &lt;/view&gt;
 &lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$6.lzx></example?>
<?ignore <p>Having other views respond while a view is being dragged ... </p>

?>
<para/></section></section><section><title>Tracking the Mouse</title>
<para/><section><title>Tracking the mouse within a single view</title>
<para>
This simple program shows how to do basic mouse tracking in a view:
</para>

<example role="live-example">
   <title>Simple mouse tracking</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$7.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>Simple mouse tracking</title><programlisting role="lzx-embednew"><filename>input-devices-$7.lzx</filename><parameter/><code>
&lt;canvas height="500" width="500" debug="true"&gt;
   &lt;debug y="300"/&gt;
   &lt;view width="300" height="300" bgcolor="red" clickable="true" &gt;
       &lt;attribute name="moustracker_del" value="$once{ new LzDelegate( this, 'trackmouse' )}" /&gt;
         &lt;handler name="onmousedown" &gt;
           moustracker_del.register(LzIdle,'onidle');
       &lt;/handler&gt;

       &lt;handler name="onmouseup" &gt;
           moustracker_del.unregisterAll();
       &lt;/handler&gt;

       &lt;method name="trackmouse" &gt;
           Debug.write("mousex,mousey =", this.getMouse('x'),this.getMouse('y'));
       &lt;/method&gt;
         &lt;/view&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas height="500" width="500" debug="true"&gt;
   &lt;debug y="300"/&gt;
   &lt;view width="300" height="300" bgcolor="red" clickable="true" &gt;
       &lt;attribute name="moustracker_del" value="$once{ new LzDelegate( this, 'trackmouse' )}" /&gt;
         &lt;handler name="onmousedown" &gt;
           moustracker_del.register(LzIdle,'onidle');
       &lt;/handler&gt;

       &lt;handler name="onmouseup" &gt;
           moustracker_del.unregisterAll();
       &lt;/handler&gt;

       &lt;method name="trackmouse" &gt;
           Debug.write("mousex,mousey =", this.getMouse('x'),this.getMouse('y'));
       &lt;/method&gt;
         &lt;/view&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$7.lzx></example?>
<para>
This generates a lot of points, but you can decide how much data to filter or not in the trackmouse method.
</para>

<para/></section><section><title>Tracking the Mouse in overlapping views</title>
<para>
	Once the mouse is down in relation to a specific view, onmouseover and onmouseout events
	are only sent to that view. This makes it difficult to track the mouse over other views.
	This section explains how to accomplish this, first by using a base component called <indexterm><primary>basetrackgroup</primary></indexterm><sgmltag class="element">&lt;basetrackgroup&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: basetrackgroup-->
, and then with the low level APIs
	that basetrackgroup is built upon.
</para>

<para>
	In the example below, notice that the onmouseover and onmouseout events change the size of the view
	while the onmousetrackover and onmousetrackout events change the color of the view. As you drag the mouse, the first view
	will continue to change its size and color while the other views will only change their color. Again, 
	this is because the basic onmouseover and onmouseout events are only being sent to the first view that was clicked. 
	However, onmousetrackover and onmousetrackout are sent to all views while the mouse is down.
</para>

<example role="live-example">
   <title>Using basetrackgroup</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$8.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>Using basetrackgroup</title><programlisting role="lzx-embednew"><filename>input-devices-$8.lzx</filename><parameter/><code>
&lt;canvas height="160"&gt;
  &lt;class name="myTrackableView" bgcolor="red"
         onmouseover="setWidth(70)" 
         onmouseout="setWidth(60)"
         onmouseup="setAttribute('bgcolor', 0xFF0000)"
         width="60" height="30"&gt;

    &lt;!-- Use methods for mouse-tracking events --&gt;
    &lt;handler name="onmousetrackover"&gt;
      setAttribute('bgcolor', 0x0000FF); //blue
    &lt;/handler&gt;

    &lt;handler name="onmousetrackout"&gt;
      setAttribute('bgcolor', 0xFF0000); //red
    &lt;/handler&gt;

    &lt;handler name="onmousetrackup"&gt;
      setAttribute('bgcolor', 0xFF0000); //red
    &lt;/handler&gt;
  &lt;/class&gt;

  &lt;text&gt;Click on any red view and drag the mouse. &lt;/text&gt;
  &lt;basetrackgroup bgcolor="yellow"
                  x="20" y="40"&gt;
    &lt;myTrackableView/&gt;
    &lt;myTrackableView/&gt;
    &lt;myTrackableView/&gt;
    &lt;simplelayout axis="y" spacing="5"/&gt;
  &lt;/basetrackgroup&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas height="160"&gt;
  &lt;class name="myTrackableView" bgcolor="red"
         onmouseover="setWidth(70)" 
         onmouseout="setWidth(60)"
         onmouseup="setAttribute('bgcolor', 0xFF0000)"
         width="60" height="30"&gt;

    &lt;!-- Use methods for mouse-tracking events --&gt;
    &lt;handler name="onmousetrackover"&gt;
      setAttribute('bgcolor', 0x0000FF); //blue
    &lt;/handler&gt;

    &lt;handler name="onmousetrackout"&gt;
      setAttribute('bgcolor', 0xFF0000); //red
    &lt;/handler&gt;

    &lt;handler name="onmousetrackup"&gt;
      setAttribute('bgcolor', 0xFF0000); //red
    &lt;/handler&gt;
  &lt;/class&gt;

  &lt;text&gt;Click on any red view and drag the mouse. &lt;/text&gt;
  &lt;basetrackgroup bgcolor="yellow"
                  x="20" y="40"&gt;
    &lt;myTrackableView/&gt;
    &lt;myTrackableView/&gt;
    &lt;myTrackableView/&gt;
    &lt;simplelayout axis="y" spacing="5"/&gt;
  &lt;/basetrackgroup&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$8.lzx></example?>
<anchor id="input-devices.view_source"/>
<para/></section></section><section><title>"View Source" right click menu item </title>
<para>
 The default canvas context (right click) menu has a "view source" 
 item, available in Flash player Version 7 and later. By default this menu includes an "About OpenLaszlo" entry, which links to the <ulink url="http://www.openlaszlo.org">OpenLaszlo</ulink> website, and an option to view source.
</para>
<para>
For an application <literal>framitz.lzx</literal> that is deployed proxied (using the OpenLaszlo Server), clicking on View Source will fetch 
<literal>framitz.lzx?lzt=source</literal> in a new browser window. If you don't wish to make source visible, set <literal>allowRequestSOURCE=false </literal>in <literal>WEB-INF/lps/config/lps.properties</literal>. 
</para>
<para>
Starting with Flash 8, you can control the content of the menu using the class <indexterm><primary>LzContextMenu</primary></indexterm><classname>LzContextMenu</classname>, which you
instantiate using <literal>new LzContextMenu()</literal>. The method <indexterm><primary><literal>LzContextMenu.makeMenuItem ()</literal></primary></indexterm><methodname>LzContextMenu.makeMenuItem ()</methodname>instantiates an <literal>LzContextMenuItem</literal>.
</para>
<para>
To make a new menu, first you create the menu, then you create a menu item, and then you add the menu item to the menu.  The data type of the menu item is
<literal>LzContextMenuItem</literal>; you supply the text that you want to appear in the menu -- the word 'Delete' may not be used as context menu text -- and a delegate that specifies how you want that menu item to be handled. <indexterm><primary><literal>LzContextMenu.addItem()</literal></primary></indexterm><methodname>LzContextMenu.addItem()</methodname> adds an item to that menu. So, to create a new menu you would do:
</para>

<example role="live-example">
   <title>Creating a context menu</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$9.lzx"/></textobject> 
    </programlisting>
</example>

<?example role="live-example"><title>Creating a context menu</title><programlisting role="lzx-embednew"><filename>input-devices-$9.lzx</filename><parameter/><code>
&lt;canvas debug="true"&gt;

&lt;view width="350" height="100" bgcolor="#cccccc"&gt;

&lt;text text="For my context menu to work, I need to run in SWF8"/&gt;

&lt;method event="oninit"&gt;
	var cmenu = new LzContextMenu(); // create the menu
    var item1 = cmenu.makeMenuItem('hello', new LzDelegate(this, "handlerightclick")); // create the menu item, and set up an LzDelegate as a callback
    cmenu.addItem(item1); //add the item to the menu
    this.setContextMenu(cmenu);
&lt;/method&gt;

 &lt;method name="handlerightclick" args="val"&gt;
    Debug.write("hello world");
  &lt;/method&gt;
&lt;/view&gt;

&lt;/canvas&gt;

</code></programlisting><?lzx-edit programs/input-devices-$9.lzx></example?>

<para>
There is no method to clear the menu (Settings and About Flash Player are always there), but you can erase one  with something
like
</para>
<programlisting>
var cmenu = new LzContextMenu();
canvas.setDefaultContextMenu(cmenu)
</programlisting>
<para>
That would give you an empty context menu.
</para>
<para condition="solo">
SOLO deployed applications, say, <literal>framitz.lzx.swf</literal>, will attempt to fetch <literal>"framitz.lzx.swf.zip"</literal>.This assumes that a copy 
of the source will be placed there if you desire to make your source visible. If you don't wish to share code of your SOLO application, use the method above.

</para>
<para/></section><section><title>Keyboard Input</title>
<para>
In OpenLaszlo applications, the keyboard input can be accepted by the view which has the keyboard "focus".  The <indexterm><primary>LzFocus</primary></indexterm><classname>LzFocus</classname> service allows you to set and control the focus.  The opposite of focus is "blur", as discussed below.
</para>
<para/><section><title>Focus and the LzFocus service</title>
<para>A focusable view is a view whose <indexterm><primary>focusable</primary></indexterm><sgmltag class="attribute">focusable</sgmltag> attribute is true (the
default value).  When the user clicks on a focusable view, the focus
is set to that view.  If the view is different from the previously
focused view, an <indexterm><primary>onblur event</primary></indexterm><literal>onblur</literal> is sent to the previously
focused view, and an <indexterm><primary>onfocus event</primary></indexterm><literal>onfocus</literal> is sent to the newly focused
view.</para>
<para>
To prevent a view from taking keyboard input, you can set its <literal>focusable</literal> attribute to "false".</para>
<para/></section><section><title>Focus trap and the focus group</title>
<para><indexterm significance="preferred"><primary>Focus trap</primary></indexterm><glossterm>Focus trap</glossterm>: A view's focus trap is its most direct ancestor
whose <indexterm><primary>focustrap</primary></indexterm><sgmltag class="attribute">focustrap</sgmltag> attribute is true, or the canvas.  A view's <indexterm significance="preferred"><primary>focus
group</primary></indexterm><glossterm>focus
group</glossterm> is the set of focusable views that are descendants of the focus
trap, and are not descendants of any more immediate ancestor whose
<indexterm><primary>focustrap</primary></indexterm><sgmltag class="attribute">focustrap</sgmltag> attribute is also true.</para>

<para>The effect of this definition is that tabbing within the children
of a view that has a true <indexterm><primary>focustrap</primary></indexterm><sgmltag class="attribute">focustrap</sgmltag>, such as
a window, will tab to another child of the same view, but won't tab to
a view within another window.</para>

<para>The <ulink url="../../demos/contacts/contacts.lzx" type="">Contacts demo</ulink> demonstrates the
use of keyboard focus.  Double-click on a name to open the details
window.  Click in a text, and then press tab and shift-tab to move to
other text fields within the same focus group.</para>
<para/><section><title>Using Tab key to move within a focus group</title>
<para>When the tab key is pressed, the focus moves to the next
focusable view within the current <emphasis role="i">focus group</emphasis>.    If there is no next view, the first view
within the current focus group is selected.  Similarly, shift-tab
selects the previous focusable view.  If there is no previous view,
the last view within the current focus group is selected.</para>

<para>A view can override the <indexterm><primary><literal>getNextSelection()</literal></primary></indexterm><methodname>getNextSelection()</methodname> and
<indexterm><primary><literal>getPrevSelection()</literal></primary></indexterm><methodname>getPrevSelection()</methodname> methods to change this default behavior.
The tab and shift tab keys select the view returned by calling
<indexterm><primary><literal>getNextSelection()</literal></primary></indexterm><methodname>getNextSelection()</methodname> and <indexterm><primary><literal>getPrevSelection()</literal></primary></indexterm><methodname>getPrevSelection()</methodname>,
respectively, on the view that currently has the keyboard focus.</para>
<para/></section><section><title>Programmatic control of focus group</title>
<para>In addition to the tab key, focus within a focus group can also be set under programmatic control, by calling the 
<indexterm><primary><literal>LzFocus.setFocus()</literal></primary></indexterm><methodname>LzFocus.setFocus()</methodname>, <indexterm><primary><literal>LzFocus.next()</literal></primary></indexterm><methodname>LzFocus.next()</methodname>, and
<indexterm><primary><literal>LzFocus.prev()</literal></primary></indexterm><methodname>LzFocus.prev()</methodname> methods.</para>
<para/></section></section><section><title>Reading Key Values </title>
<para>
One way of integrating keyboard input into your application is to have a focusable view capture pressed key codes. Only one view can be focusable at any one time. In this example, we're making that view focused oninit (although in a larger application, you could bring focus to that view using the tab key, or you could write an onclick method to tell it to focus).</para>
<para>
The example below illustrates use of <indexterm><primary>LzFocus</primary></indexterm><sgmltag class="element">&lt;LzFocus&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: LzFocus-->
 to make a view able to accept keyboard input.</para>

<example role="live-example">
   <title>Reading key values</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/input-devices-$10.lzx"/></textobject> 
   </programlisting>
</example>
<?example role="live-example"><title>Reading Key Values</title><programlisting role="lzx-embednew"><filename>input-devices-$10.lzx</filename><parameter/><code>
&lt;canvas  height="200" debug="true"&gt;
    &lt;debug x="110" y="15" /&gt;

    &lt;!-- NOTE: Even though the view below takes focus oninit,
               in some browsers you might still need to click on the
               application itself, to take the focus away from the 
               browser itself and to the Flash Player. --&gt;

    &lt;view width="100" height="100" bgcolor="0x333399"
          focusable="true"
          oninit="LzFocus.setFocus(this)"&gt;

        &lt;handler name="oninit"&gt;
            this.keyCodes = new Array()
            this.keyCodes[65] = "A for Apple";
            this.keyCodes[76] = "L for Laszlo";
            this.keyCodes[79] = "O for Optometrist";
            this.keyCodes[83] = "S for Sammy";
            this.keyCodes[90] = "Z for Zebra";
        &lt;/handler&gt;

        &lt;handler name="onkeydown" args="akeycode"&gt;
            // respond here    
            Debug.write( "Key pressed: " + akeycode );
            if ( this.keyCodes[akeycode] != undefined ) {
                Debug.write( this.keyCodes[akeycode] );
            } else {
                Debug.write( "you pressed: " + String.fromCharCode(akeycode) );
            }
        &lt;/handler&gt;
    &lt;/view&gt;
&lt;/canvas&gt;
</code></programlisting><programlisting>
&lt;canvas  height="200" debug="true"&gt;
    &lt;debug x="110" y="15" /&gt;

    &lt;!-- NOTE: Even though the view below takes focus oninit,
               in some browsers you might still need to click on the
               application itself, to take the focus away from the 
               browser itself and to the Flash Player. --&gt;

    &lt;view width="100" height="100" bgcolor="0x333399"
          focusable="true"
          oninit="LzFocus.setFocus(this)"&gt;

        &lt;handler name="oninit"&gt;
            this.keyCodes = new Array()
            this.keyCodes[65] = "A for Apple";
            this.keyCodes[76] = "L for Laszlo";
            this.keyCodes[79] = "O for Optometrist";
            this.keyCodes[83] = "S for Sammy";
            this.keyCodes[90] = "Z for Zebra";
        &lt;/handler&gt;

        &lt;handler name="onkeydown" args="akeycode"&gt;
            // respond here    
            Debug.write( "Key pressed: " + akeycode );
            if ( this.keyCodes[akeycode] != undefined ) {
                Debug.write( this.keyCodes[akeycode] );
            } else {
                Debug.write( "you pressed: " + String.fromCharCode(akeycode) );
            }
        &lt;/handler&gt;
    &lt;/view&gt;
&lt;/canvas&gt;
</programlisting><?lzx-edit programs/input-devices-$10.lzx></example?>
<?ignore <example title="Creating and using LzTrackgroups">

</example>
<!--
<h4>Tracking APIs</h4>
-->

<todo>
<h2>The Keyboard ( section under construction )</h2>

<h3>Focusing on a View</h3>
<h3>Basic Keyboard Events</h3>
<h3>While the Key is down...</h3>
<h3>Using Modifier keys: Option, Shift, and Control</h3>
</todo>
?>
<para/></section></section></chapter>
