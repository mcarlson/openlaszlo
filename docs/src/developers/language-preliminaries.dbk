<chapter id="language-preliminaries">

<title>Language Preliminaries</title>

<para>LZX is an object-oriented, tag-based language that uses XML and JavaScript syntax to create the presentation layer 
of rich Internet applications. Typically these applications are compiled by the 
OpenLaszlo compiler. They may be deployed as standalone files, or they may be 
served by the OpenLaszlo Server. 
The specification of the language includes both a set of XML tags and a set of JavaScript APIs.</para>

<para>The LZX language was designed to use familiar syntaxes and naming conventions so that experienced web developers would find it easy to learn and incorporate into their programming environments. At the same time LZX introduces new concepts and capabilities that make possible more fluid and responsive user interfaces to web applications than are possible with any other technology.</para>

<para>A running LZX program takes place on a visual object called a canvas, which is basically a bit of screen real estate. On the canvas, autonomous boxes called views interact. These views may be nested logically and visually, and have dozens of programmable attributes, including size, position, background color, opacity, clickability, stretchability, and so forth. Views may be used to contain resources, such as, for example, an image or a video, and may also be dynamically bound to any set of XML-formatted data. The attributes of any view can be set to be a function of the attributes of any other view or views, and virtually any attribute of a view can be animated — that is, set to vary over time.</para>

<para>The LZX view system is similar to other view systems in many ways, but its implementations of data binding, attribute-constraints, and animation distinguish it from other 
UI technologies.</para>

<para>LZX programs typically contain both declarative and procedural structures, and the language follows many naming conventions
 from CSS (Cascading Style Sheets). Programs written in LZX thus appear similar, on casual inspection, to DHTML applications 
with embedded JavaScript. LZX programs are conceptually different, however, from typical DHTML/JavaScript applications that are 
interpreted and rendered, or "executed," by the web browser. LZX programs, in contrast, are compiled on the server and 
downloaded as byte code for a target rendering engine.</para>

<para>In the current implementation of the OpenLaszlo platform, LZX programs are compiled in the OpenLaszlo Server and downloaded either as 
Flash movies (.swf files) to be executed in the Flash Player plugged into an Internet browser, or compiled to DHTML which is downloaded to be executed by the browser's JavaScript engine. It's important to understand that the Flash Player is used only as an execution/rendering engine for the generated byte code: there's 
nothing inherent in LZX that marries it to Flash. In particular, LZX does not employ or rely upon the Flash object model.</para>

<para>Similarly, because LZX programs are compiled by the OpenLaszlo Server the use of JavaScript in LZX programs is subtly 
different from its use in traditional web applications in which JavaScript is used to do things like communicate with the browser 
or generate HTML pages. Those functions are basically irrelevant in LZX applications. Thus, although the language design is 
rather traditional, the programming paradigm is fundamentally new.</para>

<para>This chapter summarizes the traditional and innovative aspects of LZX. It's an overview, not a tutorial; after reading it you will be better able to decide how to go about learning the language. Depending on your background and experience, you may determine that you need to go learn some more about XML or object-oriented programming before addressing LZX. On the other hand, if you find these concepts accessible, you may want to jump right in and begin coding, in which case we suggest starting with the <ulink url="../guide/laszlo_basics.html" type="laszlo-dguide">OpenLaszlo Basics</ulink> tutorial.</para>

<para/><section><title>Overview of Syntax and Semantics</title>

<para>In LZX, XML tags are used to create JavaScript objects, and JavaScript is used inside of LZX programs to
 manipulate objects created by tags. In most cases, anything that can be done with a tag can be accomplished in 
JavaScript, and vice versa. However, this equivalence is not universally true, and moreover one technique is 
virtually always vastly superior to another in any situation. <emphasis role="em">Learning</emphasis> LZX basically comes down to 
learning the tags and APIs; <emphasis role="em">mastering</emphasis> the language requires developing a subtle understanding of how 
the procedural and declarative approaches differ, and learning how and when to use each.</para>
<para role="fixme"><remark role="fixme"><emphasis role="para-label">FIXME: </emphasis>
At some point we will  have to mention CSS here.
</remark></para>
<para>LZX strictly adheres to XML and JavaScript syntax</para>
<note><para>
In earlier releases, LZX did not enforce case sensitivity in JavaScript. Since OpenLaszlo release 3.0 LZX has been a completely 
case-sensitive language. See below for a more in-depth discussion.
</para></note>

<para>The following sections offer a brief refresher on the two kinds of
LZX syntax. See below for a discussion of how JavaScript and XML
syntaxes play together in typical LZX programs.</para>

<para/><section><title>XML</title>

<para>XML, the eXtensible Markup Language, is a W3C standard for encoding
data. You will need a general familiarity with XML concepts in order
to write programs in the LZX language for two reasons: in the first
place, most of the functionality of LZX is implemented in an XML tag
set. LZX programs themselves are valid XML documents; LZX programs
that are not valid XML simply will not compile. Secondly, LZX programs
only operate on data encapsulated in XML.</para>

<para>If you understand how tags and attributes are represented in XML, are comfortable with the concepts of roots and nodes, and know how nesting works you probably know enough to get started with LZX. For more information and links to any number of online books and tutorials about XML, visit the <ulink url="http://www.w3.org/XML/">W3C web site</ulink>.</para>
<para>Another distinction between XML and JavaScript is that in XML the type names are lowercase ("string", "number"), while in JavaScript they're capitalized, e.g. "String", "Number".  The XML type names are used in &lt;attribute name="foo" type="string"/&gt;; they're lowercase for compatibility with the XML Schema Description datatypes.
</para>
<para/><section><title>XML and HTML</title>
<para>
If you have experience with HTML but not XML, you'll find many similarities. Here's some notes on how XML differs from the HTML, for people who are only familiar with HTML.  These apply to all XML; they may particularly catch people up with respect to text markup, which uses tags (&lt;p&gt;, &lt;i&gt;, &lt;br&gt;) with the same names and meanings as HTML tags:</para>
<itemizedlist spacing="compact"><listitem><para>- Case matters.  &lt;b&gt; is different from &lt;B&gt;.  (&lt;b&gt; exists in LZX as a tag for marking up bold text in a &lt;text&gt; element.  &lt;B&gt; does not exist.)</para></listitem><listitem><para>- Attribute values must be quotes, by " or '.  &lt;view width=100&gt; is invalid XML; use &lt;view width='100'&gt; or &lt;view width="100"&gt; instead.</para></listitem><listitem><para>- Empty elements must be closed.  &lt;br&gt; is valid HTML; in XML use &lt;br&gt;&lt;/br&gt; or &lt;br/&gt; instead.</para></listitem></itemizedlist>


<para/></section><section><title>Namespaces</title>
<para>
OpenLaszlo applications can be written with a namespace:</para>
<programlisting>
  &lt;canvas xmlns="http://www.laszlosystems.com/2003/05/lzx"&gt;...&lt;/canvas&gt;
</programlisting>
<para>
or without:</para>
<programlisting>
  &lt;canvas&gt;...&lt;/canvas&gt;
</programlisting>
<para>
If there is no namespace, the compiler defaults it to the LZX namespace (<ulink url="http://www.laszlosystems.com/2003/05/lzx">http://www.laszlosystems.com/2003/05/lzx"</ulink>).
</para>
<note><para>
A namespace has the same syntax as an URL, but it is not an URL; namespaces are really just hierarchical unique id's.
  In the above examples, that is, the namespace doesn't point to anything in particular on the Laszlo Systems website (if you click on it you'll get a 404 error). For more on namespaces, see the <ulink url="http://www.w3.org/TR/REC-xml-names/">W3C specification.</ulink>

</para></note>
<para/></section></section><section id="language-preliminaries.javascript"><title>JavaScript</title>

<para>JavaScript is a language originally written at Netscape by Brendan Eich for incorporation in the Netscape 2.0 browser. It was instantly successful and widely adopted in other browsers, and to preserve its emerging value as a standard, the European Computer Manufacturer's Association (ECMA) codified the language as ECMAScript and now maintains control of its evolution. Although there may be subtle differences between any implementation of JavaScript and the language formally specified by the standards body, in colloquial usage the terms JavaScript and ECMAScript are often used interchangeably. While perhaps a little more accurate to say that "ECMAScript" refers to the pure language while "JavaScript" means both the language and the associated libraries that are available on most browsers, in this book we follow general usage and use the terms loosely, trusting that it will be clear from the context what we're talking about. The term "script" refers to any (procedural) code written in JavaScript.</para>

<para>LZX incorporates a partial implementation of the <ulink url="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262 Edition 3 specification</ulink>.</para>

<para>In order to write reasonable LZX code you will need to be comfortable with these aspects of JavaScript:</para>
<itemizedlist spacing="compact"><listitem><para> basic control structures (<literal>for</literal>, <literal>while</literal>,
etc.);</para></listitem><listitem><para> the object model;</para></listitem><listitem><para> "loose" data typing;</para></listitem><listitem><para> scoping, that is, the range of namespaces within a program.</para></listitem></itemizedlist>

<para>Depending on your background, you may find certain aspects of LZX familiar or foreign. For example, if you have experience with Java but not JavaScript, you will need to be aware of key differences in the languages, in particular with regard to data typing, the object model, and the scope or namespace of variables.</para>

<para>Like other so-called scripting languages such as Perl and Python, JavaScript is a loosely-typed language — you can declare a variable without specifying its type. This makes for rapid prototyping and arguably more readable code, but it also makes it possible for data-type errors to go undetected.</para>

<para>JavaScript's approach to object-oriented programming lacks the rigor of Java's. There are no packages or interfaces, for example, nor is it possible to finalize classes. Finally, the behavior of local and global variables in JavaScript is sometimes surprising to Java programmers.</para>

<para>Conversely, if you are an experienced JavaScript programmer you may have to "unlearn" certain assumptions, in particular with regard to the availability of certain libraries and functions. For example, while the Math library is present in LZX, the the REGXEP library for regular expressions is not. Moreover, LZX has a more complete object-oriented programming model than does simple JavaScript. That is, LZX has classes and inheritance.</para>

<para>If you have experience with neither Java nor JavaScript you may want to first work through a JavaScript tutorial like the ones available at <ulink url="http://www.w3schools.com/js/default.asp">w3schools.com</ulink> before delving too deeply into LZX.</para> 

<para/></section><section><title>The "dot" syntax</title> 

<para>LZX employs the "dot" (period) syntax to indicate relationships between objects and their members. Consider the expression</para> 

<para><literal>something.other</literal></para>

<para>When read as JavaScript, <literal>something</literal> refers to an object, and <literal>other</literal> refers to a property of that object, where a property might be, say, a method. Now consider the following LZX code fragment:</para> 

<programlisting>
&lt;view name="beatles"&gt; 
  &lt;view name="george"/&gt; 
&lt;/view&gt;
</programlisting>  

<para>in this case it may sometimes be convenient to refer to the interior view, "george" as</para> 

<para><literal>beatles.george</literal></para> 

<para>in which case <varname>george</varname> is a "child" of <varname>beatles</varname> .</para> 

<para>As will be discussed further below, LZX affords various ways to define attributes of, and methods on, objects or classes. For example, the following code samples (which create a view named <varname>myview</varname> and set its background color to red) are equivalent:</para> 

<para>JavaScript:</para> 

<programlisting>myview = new LzView;</programlisting> 

<programlisting>myview.setAttribute (bgcolor, red);</programlisting>

<para>XML tag:</para> 

<programlisting>&lt;view name="myview" bgcolor="red"/&gt;</programlisting>

<para>and in both cases the background color of <literal>myview</literal> could be accessed by subsequent code as <literal>myview.bgcolor</literal> . The "dot" convention thus provides a convenient way of referring to objects regardless of how they came into existence — that is, whether by declarative tag or procedural code.</para> 
<para/></section><section><title>Case Sensitivity</title>
<para>
OpenLaszlo entirely case-sensitive.  This means that whenever you use a variable it must be in the case in which it was defined.
</para>

<para/></section><section><title>Implicit "this" and "with"</title>
<para>
LZX has a behavior that is more Java-like than JavaScript-like.
'implicit this' is a term we use to describe the behavior of free  
references in LZX methods and handlers.  In LZX classes, the object  
bound to `this` is implicitly 'in scope' in all methods and handlers,  
as it is in Java (this is _not_ the case in JavaScript).  We added  
this feature to LZX because we felt it led to more intuitive and  
compact code.
</para>
<para>
What this means is that in any method or handler in a class you can  
refer to the class attributes by name directly, without the prefix  
`this.`.  (Hence the nickname 'implicit this'.)  A concrete example:
</para>
<programlisting>
&lt;class name="foo"&gt;
   &lt;attribute name="attr" value="42" /&gt;

   &lt;method name="implicitAttrValue"&gt;
     return attr;
   &lt;/method&gt;

   &lt;method name="explicitAttrValue"&gt;
     return this.attr;
   &lt;/method&gt;
&lt;/method&gt;
</programlisting>
<para>
The two methods will return the same value. 
</para>
<para>
You should <emphasis role="em">not</emphasis>  
rely on "implicit this" on the left-hand side (LHS) of an assignment  
expression. Doing so is dangerous because unless the property already exists in `this`, you will write a global.
 Consider:
</para>
<programlisting>
&lt;class name="bar"&gt;
   &lt;attribute name="attr" /&gt;

   &lt;method name="implicitSetAttrValue"&gt;
     attr = 7;
   &lt;/method&gt;

   &lt;method name="explicitSetAttrValue"&gt;
     this.attr = 7;
   &lt;/method&gt;
&lt;/class&gt;
</programlisting>
<para>
Because `attr` is not initialized, the implicit method may not find  
`attr` in the instance and will set the global variable `attr`  
instead.  You should _always_ explicitly use `this.` on the left-hand  
side of any assignment.  The compiler can help you find errors like  
this:  If you compile your application with <literal>`lzc -
DwarnGlobalAssignments`,</literal> the compiler will print a warning for every  
global assignment that your program makes.  If you intend to make a  
global assignment, you can silence the warning by explicitly using  
`global.attr =`.
</para>
<para>
`with` is a JavaScript primitive that can be used to establish scope. Free variables in the body of a `with` will be looked up first in the object that is the argument (and then in whatever the enclosing scope is). Functions close over their scope when they are defined, so by wrapping `with (_root)` around each global function definition, free references in functions will be looked up in the global context (as opposed to the SWF implementation, where global functions are given a null scope, so when they are called from the idle context, their free references appear unbound).
</para>
<para/><section><title>"this" in states and animators</title>
<para>
Inside Animators, the "this" keyword refers to the animator, and "parent" refers to the view or node it is nested in.
</para>
<para>
In states, the "this" keyword refers to the view or node that state is nested inside of. Methods nested inside of a state apply to the view. There is an exception to the above rule: when listening to the onapply or onremove events, the methods apply to the state, and
  the "this" keyword points to the state. 
</para>
<para/></section></section><section><title>The LZX DTD and Schema</title> 

<para>An XML schema defines the LZX tag set and can be used to configure an editor. The DTD is also available for the curious, although there is no need for you to be aware of it for programming purposes.</para>

<para>The LZX schema is used by the OpenLaszlo Compiler to ensure
that LZX programs are formally correct. For example, the schema
specifies what attributes can be included in an opening
<indexterm><primary>view</primary></indexterm><sgmltag class="element">&lt;view&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: view-->
 tag. If your program contains a
<indexterm><primary>view</primary></indexterm><sgmltag class="element">&lt;view&gt;</sgmltag> tag that includes an attribute not defined by
the schema, it will compile with a warning.</para>

<para>LZX allows you to define your own tags. User defined tags do not
get incorporated into the schema that is available to your editor,
although they are used in the internal schema that the compiler uses
to test that program's validity.</para>




<para/></section></section><section id="language-preliminaries.objects-and-attributes"><title>Objects and Attributes</title> 


<para>LZX incorporates the standard object-oriented programming concepts of inheritance, encapsulation, and polymorphism. In general, a tag in an OpenLaszlo program corresponds to an object that is an instance of the class of that name. For example, the <indexterm><primary>view</primary></indexterm><sgmltag class="element">&lt;view&gt;</sgmltag> tag corresponds to an <indexterm><primary>LzView</primary></indexterm><classname>LzView</classname> object.</para> 

<para>To a first approximation, then, LZX can be described as a rule-based declarative language for manipulating visual (JavaScript) objects called views, where rules are expressed as constraints on the values of the attributes of those objects.</para> 

<para>The following paragraphs summarize some of the key object-oriented aspects of the LZX language. These ideas are examined at greater length elsewhere in this Guide, particularly in <xref linkend="class-inheritance"/>.</para>

<para/><section><title>Objects</title> 

<para>An object is a data type that contains named pieces of data. Depending on context, a named datum might be called a <emphasis role="em">property</emphasis> or an <emphasis role="em">attribute</emphasis> of that object. For example, each <literal>view</literal> object has 49 attributes, such as height, width, horizontal position, vertical position, and so forth. Values are generally assigned to the attributes of objects when the objects are created; attributes that you do not specifically set are assigned default values.</para> 

<para>You can create new kinds of LZX objects by using the <indexterm><primary>class</primary></indexterm><sgmltag class="element">&lt;class&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: class-->
 tag. Each new class you create must be given a name and the name of a class that it's "extending." The newly created objects inherit all the properties of the class you extended, plus any additional properties you may define. For example consider the trivial case</para> 

<programlisting>&lt;class name="myview" extends="view"/&gt;</programlisting>

<para>In this case you have defined a new kind of object called a <varname>myview</varname> that has all the properties of a <literal>view</literal>. <xref linkend="initialization-and-instantiation"/> discusses in depth when and how objects are defined in your code and built by the compiler at runtime.</para> 

<para/></section><section><title>Attributes</title> 

<para>In LZX, the word "attribute" has two related but subtly different meanings, one syntactical and one semantic. In the XML, syntactical, sense, an attribute is a named value associated with an XML element and specified in that element's opening tag. Thus in the XML tag</para> 

<programlisting>&lt;boss demeanor="friendly"/&gt;</programlisting>

<para><indexterm><primary>demeanor</primary></indexterm><sgmltag class="attribute">demeanor</sgmltag> is an attribute of the tag <literal>boss</literal> . This meaning of "attribute" applies whenever the context is XML structure. Note that the value assigned to an attribute is enclosed in double quotation marks.</para> 

<para>Because LZX tags correspond to JavaScript classes, "attribute" takes on the additional semantic weight of property of a JavaScript object. Thus the LZX tag</para> 

<programlisting>&lt;view height="20" width="30"/&gt;</programlisting>

<para>causes the creation of a view object with the specified values for the attributes <indexterm><primary>height</primary></indexterm><sgmltag class="attribute">height</sgmltag> and <indexterm><primary>width</primary></indexterm><sgmltag class="attribute">width</sgmltag>.</para> 

<para>The <indexterm><primary>attribute</primary></indexterm><sgmltag class="element">&lt;attribute&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: attribute-->
 tag can be used to set JavaScript attributes of objects. For example,</para> 

<programlisting> 
&lt;view name="myview"&gt; 
  &lt;attribute name="height" value="20"/&gt; 
  &lt;attribute name="width" value="30"/&gt; 
&lt;/view&gt;  
</programlisting>

<para>is equivalent, in LZX, to the earlier one-line version. Thus <indexterm><primary>height</primary></indexterm><sgmltag class="attribute">height</sgmltag> is an attribute of the view, in the semantic sense, even though it is not in the XML sense of being contained in the opening tag. <indexterm><primary>height</primary></indexterm><sgmltag class="attribute">height</sgmltag> is also an attribute, in the XML sense, of the first <indexterm><primary>attribute</primary></indexterm><sgmltag class="element">&lt;attribute&gt;</sgmltag> tag. Its value can be referenced by script as <literal>myview.height</literal>.</para> 

<para>You also use the <indexterm><primary>attribute</primary></indexterm><sgmltag class="element">&lt;attribute&gt;</sgmltag> tag to define new attributes for classes you create. For example</para> 

<informalexample role="live-example"><programlisting>
&lt;class name="froboz" extends="view"&gt; 
  &lt;attribute name="whatnot" value="17"/&gt; 
&lt;/class&gt;
</programlisting></informalexample>

<para>Defines a new kind of view object, <literal>froboz</literal>, that has fifty attributes: the 49 that it has inherited from view, plus the new attribute named <indexterm><primary>whatnot</primary></indexterm><sgmltag class="attribute">whatnot</sgmltag>.</para> 

<para>We have seen that attributes can be set, that is, assigned values, in LZX tags. It is also possible to set attribute values in script using the <indexterm><primary><literal>setAttribute()</literal></primary></indexterm><methodname>setAttribute()</methodname> method. Additionally, values of attributes can be read, or "gotten" in script (but not in tags) using the <indexterm><primary><literal>getAttribute()</literal></primary></indexterm><methodname>getAttribute()</methodname> method. (Methods will be explained below).</para> 

<para>Assume the existence of a view named <varname>johnny</varname>. This view may have been created by a tag or in script; how the view came into existence does not matter.</para> 

<para>The JavaScript code to set the height of this view to 100 pixels would be:</para> 
<para><literal>johnny.setAttribute("height", 100);</literal></para> 

<para>and to read the value the height would be</para> 

<para><literal>johnny.getAttribute("height");</literal></para> 

<para>Every time that an attribute is set, that is, every time the value of an attribute changes, an object called an <literal>event</literal> is generated. The next section discusses what events are, and how they work in LZX programs.</para> 

<para/></section></section><section><title>Events and Methods</title> 

<para/><section><title>Events</title> 

<para>Events are the mechanism by which objects communicate with each other when something changes. For example, an event might be generated when a mouse button is clicked, or when data arrives from a server, or when a view has been constructed.</para> 

<para>In LZX programs, events are not broadcast, but rather they are communicated in a point-to-point fashion using <literal>delegates</literal>, which are basically function pointers that are referenced when events happen. This implementation increases flexibility and reduces the overhead of using events. However, for the purposes of the discussion in this chapter we're going to ignore delegates and speak of events in a slightly less rigorous manner, saying, for example when such-and-such an event <emphasis role="em">occurs</emphasis>, thus and such <emphasis role="em">happens,</emphasis> leaving aside for now an explanation of <emphasis role="em">how</emphasis> it happens.</para> 

<para>Views have approximately two dozen defined events, as listed 
on the entry for <indexterm><primary>view</primary></indexterm><sgmltag class="element">&lt;view&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: view-->
 in the <ulink url="../reference/../reference/" type="laszlo-reference">LZX Reference Manual</ulink>. Many of these
events that deal with user input, such as <indexterm><primary>onblur event</primary></indexterm><literal>onblur</literal>,
<indexterm><primary>onclick event</primary></indexterm><literal>onclick</literal>, <indexterm><primary>onkeydown event</primary></indexterm><literal>onkeydown</literal>, will be familiar to
JavaScript programmers. Other events, such as <indexterm><primary>onheight event</primary></indexterm><literal>onheight</literal>
and <indexterm><primary>onopacity event</primary></indexterm><literal>onopacity</literal>, pertain to views' visible
attributes. Finally, the <indexterm><primary>oninit event</primary></indexterm><literal>oninit</literal> and
<indexterm><primary>onconstruct event</primary></indexterm><literal>onconstruct</literal> events are related to the creation of the
instances of view objects. Similarly, other system-defined LZX objects
such as Datasets (see below) have events associated with them.</para>

<para>Events and attributes often work as pairs, and in fact, the default
behavior of the <indexterm><primary><literal>setAttribute()</literal></primary></indexterm><methodname>setAttribute()</methodname> method is to set the named property and
send the event called "<literal>on</literal>" + property. For instance, when a
view changes its <indexterm><primary>x</primary></indexterm><sgmltag class="attribute">x</sgmltag> (horizontal) position, it
sends the event <indexterm><primary>onx event</primary></indexterm><literal>onx</literal> with the new value for its
<indexterm><primary>x</primary></indexterm><sgmltag class="attribute">x</sgmltag> property. This means that in addition to
system-defined events, there exists an event for each attribute you
define.</para>

<para>When an event happens, control is transferred to its associated event-handler (if one is defined). Events can be sent with a single argument, which usually conveys information about the property that changed.</para> 

<para>Elsewhere in this Guide we discuss how events are implemented in
LZX, and how the event architecture bears upon program design. In
particular, <xref linkend="delegates"/> discusses the
relationship between events and delegates.</para>

<para/></section><section><title>Methods</title> 

<para>In LZX, a method is a JavaScript function associated with a particular object.</para>

<para>Functions are invoked using the <literal>()</literal>
operator. Thus,</para>

<programlisting>
&lt;view name="dog"&gt;   
  &lt;method name="bark"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/method&gt; 
&lt;/view&gt;
</programlisting>

<para>Defines a function that is executed when invoked by name, as in</para>

<para><literal>dog.bark();</literal></para> 

<para>In JavaScript, the <literal>this</literal> keyword is used to refer to the object through which the function was invoked. </para>
<para/></section><section><title>Handlers</title>
<para>
A handler is like a method. But whereas a method is invoked by its name, a handler must be associated with a particular event. The handler
script will be executed when the referenced view receives an event
with this name. For example,</para>

<programlisting>
&lt;view&gt; 
  &lt;handler name="onclick"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/handler&gt; 
&lt;/view&gt;
</programlisting>

<para>defines a function that is executed when the view is clicked on. 
Consider</para> 

<programlisting> 
&lt;view&gt; 
  &lt;method name="bark"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/method&gt; 
  &lt;handler name="onclick"&gt; 
    this.bark()  
  &lt;/handler &gt; 
&lt;/view&gt;
</programlisting>  

<para>When the view is clicked on, the <indexterm><primary>onclick event</primary></indexterm><literal>onclick</literal> event causes the execution of the <indexterm><primary><literal>handler()</literal></primary></indexterm><methodname>handler()</methodname> which in turn invokes the method named <indexterm><primary><literal>bark()</literal></primary></indexterm><methodname>bark()</methodname>.  Event handlers are often identified in an opening tag, as in</para> 

<programlisting>
&lt;view onclick="clickHandler()"&gt; 
  &lt;method name="clickHandler"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/method&gt; 
&lt;/view&gt; 
</programlisting>

<para>There are three general categories of methods and handler:</para> 
<itemizedlist spacing="compact"><listitem><para>   "On init" methods that are invoked when their parent object is created;</para></listitem><listitem><para>   handlers that are invoked when their parent object receives a specified event;</para></listitem><listitem><para>   named methods that are explicitly invoked by other methods.</para></listitem></itemizedlist>

<para>Note that you can define a method using conventional JavaScript syntax, but in LZX the preferred way to declare a method is with the <indexterm><primary>method</primary></indexterm><sgmltag class="element">&lt;method&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: method-->
 tag.</para> 

<para>Also note that in LZX, unlike many other object-oriented systems,
you can override a method in an instance of an object. This topic is
covered in <xref linkend="class-inheritance"/>.</para>

<para/></section></section><section><title>Constraints</title> 



<para>In LZX, a constraint is an attribute whose value is a function of other attribute values.  The syntax for coding a constraint is</para> 

<programlisting>$<replaceable>when</replaceable>{<replaceable>expression</replaceable>}</programlisting>

<para>where:</para>
<itemizedlist spacing="compact"><listitem><para><literal>$</literal> is the token indicating a constraint</para></listitem><listitem><para><literal><replaceable>when</replaceable></literal> is an optional compiler directive: <literal>immediately</literal>, <literal>once</literal>, or <literal>always</literal>.  <literal>$always{<replaceable>expression</replaceable>}</literal> can be abbreviated to <literal>${<replaceable>expression</replaceable>}</literal> </para></listitem><listitem><para><literal>{</literal> and <literal>}</literal> are tokens delimiting the
  expression to be evaluated</para></listitem><listitem><para><literal><replaceable>expression</replaceable></literal> is a JavaScript expression</para></listitem></itemizedlist>

<para>As we have seen above, whenever the value of an attribute
changes, its <indexterm><primary>on event</primary></indexterm><literal>on</literal> event is generated. Because a
constraint is an attribute whose value is dependent upon the values of
one or more other attribute(s), the value of the constraint is
recalculated whenever it receives the <indexterm><primary>on event</primary></indexterm><literal>on</literal> event for the
attributes on which it depends.</para>

<para>Consider</para> 

<programlisting>
&lt;view name="someView" 
      width="${someAttribute + someOtherAttribute}" 
 /&gt;
</programlisting>

<para>The value of <literal>someView.width</literal> is recomputed whenever an <literal>onsomeAttribute</literal> or <literal>onsomeOtherAttribute</literal> event occurred.</para> 

<para>So for example</para> 

<programlisting>
&lt;view name="beatles" width="${this.paul.width + 28}"&gt; 
  &lt;view name="paul" onclick="clickhandler()" &gt; 
    &lt;!-- clickhandler method here to increase paul's width based on user clicking mouse --&gt; 
  &lt;/view&gt; 
&lt;/view&gt;
</programlisting>

<para>The width of <literal>beatles</literal> will increase or decrease as a function of <literal>paul</literal>'s width; the expression <literal>this.paul.width + 28</literal> is a constraint.</para> 

<para>When the user clicks on the <literal>paul</literal> view, the clickhandler will adjust the size of the <literal>paul</literal> view.  This change will be reported to the <literal>${this.paul.width + 28}</literal> constraint, which will then adjust the <literal>beatles</literal> view to the width of the <literal>paul</literal> view plus an additional 28 pixels.  All of these steps are invisible to the user because they occur instantly.</para>

<para>This, of course is a trivial example, but it serves to make the
point that in declaring the structure of your objects in LZX you also
declare the rules by which they will relate to each other. Constraints
are a fundamental concept in LZX programming, and learning to
"think in LZX" is a mostly a matter of learning to properly
model your system's behavior in terms of the constraints on its
constituent parts. <xref linkend="constraints"/> covers constraints in depth.</para>

<para/><section><title>Lexical and View Hierarchies</title> 

<para>An LZX application is expressed as a hierarchy of objects, usually visual objects, all of which are contained in a single object called the Canvas. Recall that LZX programs are XML documents, the Canvas is the root element. The simplest LZX program is thus:</para> 

<programlisting>&lt;canvas/&gt;</programlisting>

<para>This program compiles and executes, but has no output. As the simplest visual object is the View, a minimal LZX program would look something like:</para> 

<programlisting>
&lt;canvas&gt;
  &lt;view&gt;
    &lt;text&gt; Hello World!&lt;/text&gt; 
  &lt;/view&gt; 
&lt;/canvas&gt;
</programlisting>

<para>This code clearly defines a hierarchy of three objects. We can make their visual relationship more visible by giving the canvas and view sizes and background colors:</para> 

<para>In this simple case, the lexical hierarchy in the code corresponds to the visual hierarchy in the canvas. In fact, a <literal>&lt;text&gt;</literal> object is an instance of a class derived from <literal>&lt;view&gt;</literal> . The typical LZX program repeats this pattern on a larger scale: the canvas contains views which contain other views, and so forth. Classes are used to replicate view groupings; components such as buttons, windows, input fields and sliders are examples of classes built from views.</para> 

<para>LZX affords a variety of ways to simplify the relationships among views. For example, there are several categories of layouts that handle the "housekeeping" of placing views in relationship to each other. These are described in <xref linkend="layout-and-design"/>.</para> 

<para>However, the relationship between the textual hierarchy in the code and the visual hierarchy on the canvas is not always as neat as in the example above. In particular, LZX's powerful data binding semantics make it possible for a single <literal>&lt;view&gt;</literal> tag in the text to cause the creation of an arbitrary number of instances of <literal>view</literal> objects. In such cases it becomes very important to have a precise way of talking about complex relationships among objects. <xref linkend="views"/> covers this topic in depth.</para> 

<para/></section><section><title>Lexical Scope</title> 

<para>In LZX the concepts of local and global namespaces, or scopes, are basically the same as in JavaScript. Having said that, it should be pointed out that JavaScript follows rules that are sometimes surprising to Java Programmers.</para> 

<para>In JavaScript, all variables are global unless they are preceded by the keyword <literal>var</literal>.</para>

<para>Thus</para> 

<programlisting>a = 7; // defines a global variable a</programlisting>

<para>and</para> 

<programlisting>var a = 7 // defines a local variable a</programlisting>

<para>This syntax means, for example, that an assignment in a method definition can set an instance of a global variable:</para> 

<programlisting>for (a = 0; a &lt;n; a++);</programlisting>
 
<para>Creates a global variable named <varname>a</varname>, or changes the value of this variable if it already exists. What the programmer meant to write was</para> 

<programlisting>for (var a = 0; a &lt;n; a++);</programlisting>

<para>In LZX, the <indexterm><primary>name</primary></indexterm><sgmltag class="attribute">name</sgmltag> attribute is local and the <indexterm><primary>id</primary></indexterm><sgmltag class="attribute">id</sgmltag> attribute is global. Thus</para> 

<informalexample role="live-example"><programlisting>
&lt;canvas&gt; 
  &lt;view name="john" id="grandfather"&gt; 
    &lt;view name="john" id="father"&gt; 
      &lt;view name="john" id="son"/&gt; 
    &lt;/view&gt; 
  &lt;/view&gt; 
&lt;/canvas&gt;
</programlisting></informalexample>

<para>is a valid name scheme. The innermost view can be referenced by
<literal>Canvas.john.john.john</literal> or simply <literal>son</literal>.</para>

<para>As will be discussed below, functions created using the
<indexterm><primary>script</primary></indexterm><sgmltag class="element">&lt;script&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: script-->
 tag can be accessed from anywhere in the
program.</para>

<para/></section></section><section><title>Data Access, Manipulation, and Binding</title> 

<para>LZX is designed to make it easy to write data-driven applications in which the values of data sources define the appearance and actions of the program. It does this through tags and APIs that allow you to get access to data over http, manipulate XML data in memory, and, significantly, bind the data hierarchy to the view hierarchy.</para> 

<para>The following paragraphs summarize these key features of the LZX data-handling architecture. <xref linkend="data"/> discusses this subject in depth.</para> 

<para/><section><title>Data Access</title> 

<para>LZX programs manipulate XML-formatted data, which may be</para> 
<itemizedlist spacing="compact"><listitem><para>   embedded in the program text, </para></listitem><listitem><para>   read in from a source when the program is compiled, or</para></listitem><listitem><para>   read in from a source when the program is running.</para></listitem></itemizedlist> 

<para>XML sources are stored as objects called datasets. The <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: dataset-->
 tag has attributes that allow you to, for example, control caching on the client and server, include or exclude http headers, queue requests, and so forth. Objects created by <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag> are called LzDatasets. Methods on LzDatasets allow you to, for example, get and set query strings, parameters and so forth.</para> 

<para/></section><section><title>   Data Manipulation</title> 

<para>LZX employs datapointers, which are objects that represent pointers to nodes in datasets, to locate and manipulate content. Datapointers support a subset of XPath, which is a W3C standard specification for identifying paths of an XML document, or in the case of LZX, datasets. XPath uses a notation similar to the UNIX file-system to refer to nodes within a dataset. Datapointers can be repositioned using both procedural calls such as <indexterm><primary><literal>selectNext()</literal></primary></indexterm><methodname>selectNext()</methodname> and by running an XPath request using <indexterm><primary><literal>setXPath()</literal></primary></indexterm><methodname>setXPath()</methodname>.</para> 

<para>Because it incorporates sophisticated pattern matching, XPath notation is extremely concise and powerful. A single XPath expression can represent an arbitrarily large number of XML elements. Using methods such as <indexterm><primary><literal>addNode()</literal></primary></indexterm><methodname>addNode()</methodname>, <indexterm><primary><literal>setNodeName()</literal></primary></indexterm><methodname>setNodeName()</methodname>, <indexterm><primary><literal>setXpath()</literal></primary></indexterm><methodname>setXpath()</methodname>, and <indexterm><primary><literal>selectParent()</literal></primary></indexterm><methodname>selectParent()</methodname>, you can build and manipulate XML structures.</para> 

<para/></section><section><title>Data Binding</title> 

<para>LZX provides a unique way of merging any arbitrarily shaped data hierarchy with any display hierarchy; this capability is called data binding. It is implemented in such a way that the data context of a child in the display hierarchy is implicitly the data context of its parent. Moreover, it is possible to instruct the system to create an arbitrary bit of view hierarchy to represent each element in a set of selected data.</para> 

<para>The way this is done is by binding views to datapointers. A <literal>datapath</literal> is a special case of datapointer that explicitly marries the data hierarchy to the view hierarchy, as in, for example:</para> 

<programlisting>&lt;view name="bob" datapath="testdata:/*"&gt;</programlisting>

<para>where <varname>testdata</varname> refers to a dataset defined earlier in the program.</para> 

<para>If this sounds a little abstract, well, it is. Therefore we'll keep the discussion short here and defer longer explanations to <xref linkend="data"/>; you may also want to examine some of the examples on <ulink url="http://www.laszlosystems.com/demos">http://www.laszlosystems.com/demos</ulink> to get a feel for what can be done when applications are truly data-driven.</para> 

<para>The key thing to understand is that while other languages and technologies have implemented merge algorithms that may appear similar on the surface, LZX's data binding is novel in the creation of program objects that retain a live connection with the entities of the data source.</para> 

<para/></section></section><section><title>Combining Tags and Script in LZX Programs</title> 

<para>As mentioned earlier, virtually all nontrivial LZX programs contain both (XML) tags and script. Tags are used declaratively, that is, to define objects and their attributes. Script is used procedurally, that is, to explicitly define a series of steps. Although the two kinds of code are liberally intermixed within LZX — for example, script can appear within tags — each syntax locally maintains its integrity.</para> 

<para>So for example, within declarative LZX code, comments are denoted</para> 
<programlisting>&lt;!-- XML comment --&gt;</programlisting>
<para>while within JavaScript, comments are denoted</para> 
<programlisting>// JavaScript comment</programlisting>
<para>Thus LZX is similar to an alloy of two metals that do not chemically combine.</para> 

<para>Because the declarative and procedural portions of a program can be so intertwined, it can be a little tricky, at first, to recognize them within a program. However, once you gain a little experience and begin to grasp the underlying logic of LZX you will find that you hardly notice the alternating syntaxes. The following paragraphs explain how and why to employ the two "flavors" of LZX. Consult the documentation for your IDE or text editor to learn how to use the LZX DTD or schema to give visual cues that indicate what portions of the program are in each syntax.</para> 
<para/><section><title>Name Mapping between Tags and Classes</title>
<para>
The preferred normalized form of class names is <literal>lz.[tagname]</literal> where [tagname] is the name of a tag.  So for example a if you created a class called "bob":</para>
<programlisting>
&lt;class name="bob"/&gt;
</programlisting>
<para>
then from the point of view of JavaScript, this would be an lz.bob object.
</para>
<para>
In earlier versions of LZX (before OpenLaszlo 4), there was an asymmetric mapping between tag and class names, often of the form LzFoo &lt;—&gt; &lt;foo&gt;, as in the correspondence between, say the class name <indexterm><primary>LzView</primary></indexterm><classname>LzView</classname> and the tag name <indexterm><primary>view</primary></indexterm><sgmltag class="element">&lt;view&gt;</sgmltag>. (Notice in LzView the mixed case, and the absence of the period between lz and the tag name.) Also there was a distinction between LFC classes and user-created classes.  The new lz.foo form is consistent across LFC classes and user-created classes. The old forms will still work, and they appear throughout this documentation and in example code. At some point, however, the old forms will probably be deprecated, and it would be a good practice to adopt the new form in your code.</para>


<para/></section><section><title>How to Combine Tags and Script</title> 

<para>Let's start by making a distinction between what is syntactically allowable and what is meaningful.</para> 

<para/><section><title>What's Allowable</title> 

<para>Remember that all LZX programs are well-formed XML files. That means that all portions of the program, including embedded JavaScript, must conform to XML rules. Therefore where JavaScript uses characters that are meaningful to XML, such as the left angle bracket &lt;, you must make sure that those characters don't confuse the XML parser. You can do that in either of two ways:</para> 

<itemizedlist spacing="compact"><listitem><para>by explicitly <indexterm significance="preferred"><primary>escaping</primary></indexterm><glossterm>escaping</glossterm> delimiter characters with an
  <indexterm significance="preferred"><primary>entity reference</primary></indexterm><glossterm>entity reference</glossterm>. (For example, the entity reference for the left
  angle bracket is <literal>&amp;lt;</literal>).</para></listitem><listitem><para>by using the XML <literal>CDATA</literal> construct to define a block
  of <indexterm significance="preferred"><primary>character data</primary></indexterm><glossterm>character data</glossterm>.</para></listitem></itemizedlist> 

<para>This is the sum total of rules for making sure that XML does not trip on JavaScript.</para> 

<para/></section><section><title>What's Meaningful</title> 

<para>Although the admixture of two different sets of language rules in one language does create opportunities for confusion, it's fairly easy to recognize how LZX programs are structured, and what kind of code goes where. There are only a few contexts in which script code can appear in LZX programs. After you learn to recognize these contexts you are unlikely to be confused about what syntax applies. JavaScript is used:</para> 
<itemizedlist spacing="compact"><listitem><para>between an opening and closing <literal>&lt;script&gt;</literal> and <literal>&lt;/script&gt;</literal> tag;</para></listitem><listitem><para>between an opening and closing <literal>&lt;method&gt;</literal> and <literal>&lt;/method&gt;</literal> tag;</para></listitem><listitem><para>between an opening and closing <literal>&lt;handler&gt;</literal> and <literal>&lt;/handler&gt;</literal> tag;</para></listitem><listitem><para>with the double-quoted right hand value of an assignment statement within certain tags, such as <literal>oninit="<replaceable>script expression</replaceable>"</literal> .</para></listitem></itemizedlist>



<para/></section></section><section><title>When to Use Tags and When to Use Script</title> 

<para>As we said earlier, most things that you can do in LZX can be done either with XML tags or JavaScript APIs, and mastering LZX requires developing a subtle understanding of how and when to use each. You will find, in general, that tags are best for computations that can be done at compile-time — such as laying out the canvas — and script is best for run-time things, such as responding to user input. But in order for you to make any use of that information you need to understand what is done at compile time and what is done at run time, and much of that is under your control, and dependent on the problem you're trying to solve.</para> 

<para>In other words, there is no simple set of unambiguous rules that tell you when to use tags versus when to use script. But there are, however, design patterns common to all well-made LZX programs.</para> 

<para>Remember, LZX is primarily a language for manipulating visual objects called views. So the question of when to use tags versus script is usually asked in the context of the <emphasis role="em">creation of views and manipulation of their attributes</emphasis>. Script can be used for other things, such as global functions, but in those instances the need to write procedural code (i.e., script) is usually clear-cut. The finesse part has to do with manipulating views and their attributes.</para> 

<para>For example, a simple two-word constraint might express a relationship between views that would require thirty lines of code to express. Most of the time the constraint is the better programming solution. But not always.</para> 

<para>Although there are no absolutes, there are some general principles that define best practice in LZX development:</para> 
<itemizedlist spacing="compact"><listitem><para>   Use tags when that is the only option.</para></listitem><listitem><para>   Use JavaScript when that is the only option.</para></listitem><listitem><para>   If something can be done with either tags or script, use tags (unless there is a good reason not to).</para></listitem></itemizedlist>

<para>Each of these principles is described briefly below.</para>



<para/><section><title>Use tags when that is the only option</title> 

<para>There are certain tags that perform functions that cannot be done using script. For example, the root node (and enclosing tag) of every LZX program is <indexterm><primary>canvas</primary></indexterm><sgmltag class="element">&lt;canvas&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: canvas-->
. Every LZX program begins with <literal>&lt;canvas&gt;</literal> and ends with <literal>&lt;/canvas&gt;</literal>; there is no alternative structure using script. Similarly there are no script equivalents for <indexterm><primary>splash</primary></indexterm><sgmltag class="element">&lt;splash&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: splash-->
, <indexterm><primary>method</primary></indexterm><sgmltag class="element">&lt;method&gt;</sgmltag>, <indexterm><primary>attribute</primary></indexterm><sgmltag class="element">&lt;attribute&gt;</sgmltag>, <indexterm><primary>resource</primary></indexterm><sgmltag class="element">&lt;resource&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: resource-->
, <indexterm><primary>font</primary></indexterm><sgmltag class="element">&lt;font&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: font-->
, and several other tags. Moreover, within certain tag definitions there are certain attributes that can only be set in the tag.</para> 

<para/></section><section><title>Use JavaScript when that is the only option.</title> 

<para>There are several JavaScript APIs that perform functions that cannot be done using tags. For example, <literal>LzDelegate, LzEvent, LzParam</literal> and similar APIs perform operations that cannot be done using tags. Similarly, there are certain attributes of objects that can only be referenced by script, even for objects that were created with tags. For example, consider</para> 

<para><literal>&lt;view name="franklin"&gt;</literal></para> 

<para>There is an attribute, <literal>franklin.subviews,</literal> that can be accessed by script; it is not possible to set or access that attribute in a tag.</para> 

<para/></section><section><title>If something can be done with either tags or script, use tags.</title> 

<para>In the large number of cases where it is possible to do something using either tags or views, it is generally better to use tags. For example you can create a new view called "sam" using tags</para> 

<para><literal>&lt;view name="sam"&gt;</literal></para> 
<para>or script</para> 
<para><literal>sam = new LzView();</literal></para> 

<para>When you use the tag syntax you can quite naturally create hierarchies of nested subviews, define attributes as constraints, and lay out your code in a way that helps you conceptualize the placement of views on the canvas. Achieving any of these results in pure JavaScript would be a colossal pain and negate much of the benefit of the language. Learning to think in LZX means learning to think in terms of views that act nearly autonomously according to the constraints you establish at their creation.</para> 

<para/></section><section><title>Unless there is a good reason not to.</title> 

<para>Sometimes it's better to write procedural code instead of declarative code. This may become necessary, for example, to achieve optimal performance: multiply-constrained systems can sometimes become CPU bound. Other times procedural code may make your program's behavior easier to understand: complex rule-based view systems sometimes become inscrutable.</para> 

<para role="fixme"><remark role="fixme"><emphasis role="para-label">FIXME: </emphasis>Appendix _____ contains a schematic overview of what functions can be done by tag alone, script alone, or by both.</remark></para>

<para/></section></section></section><section><title>Compilation and Execution</title> 
<para>LZX programs are compiled by the OpenLaszlo Compiler, downloaded as byte code, and executed on the client.  In writing your program you can make trade-offs between compilation performance, download and startup up time, and runtime performance.</para> 

<para>As in other scripting languages such as Perl and Python, LZX programs execute in approximately linear order. That is to say, if you were to write</para> 

<programlisting>
&lt;view name="outside"&gt; 
  &lt;view name="inside"/&gt; 
&lt;/view&gt;
</programlisting>

<para>Then <varname>inside</varname> would be built before
<varname>outside</varname>. However in many cases you may wish to
control the order in which objects are built, or initialized. LZX
gives you fine grained control over initialization and instantiation
of views.</para>

<para>The <indexterm><primary>splash</primary></indexterm><sgmltag class="element">&lt;splash&gt;</sgmltag> tag allows you use the canvas to
display information while the program is being initialized.</para>



<para/></section><section><title>On Runtimes and Deployment Modes and the "Core" API</title>
<note><para>The following section also appears in the Preface; we repeat it here on the assumption that the Preface is an often-skipped part of any manual.</para></note>
<para>
OpenLaszlo applications can be compiled to run in any of several runtimes, and in either of two deployment modes. Some capabilities are available in only a subset of these use cases. OpenLaszlo's "core" APIs run on all target runtimes, and they get the most attention in this <emphasis role="i">Guide</emphasis>. The "Core API" is kind of loose concept, since there's no formal definition, but what it means is that unless you see indication to the contrary, you can assume that the topic under discussion applies to all runtimes. Similarly the default deployment mode is assumed to be SOLO.
</para>
<para>
Nevertheless, as a developer you have to decide whether to:
</para>
<orderedlist spacing="compact"><listitem><para>optimize for swf (employ swf-only APIs, (and maybe even touch Flash APIs))</para></listitem><listitem><para>optimize for dhtml (employ dhtml-only APIs)</para></listitem><listitem><para>code to lowest common denominator ("core" APIs only)</para></listitem><listitem><para>conditionalize (include both. An example would be including comma separated list of embedded and system fonts; when compiled to SWF you get embedded font, to DHTML you get system font).</para></listitem></orderedlist>
<para>
The focus of the <emphasis role="i">Developer's Guide</emphasis> is (c), the lowest common denominator; runtime-specific APIs and engineering approaches are presented as adjuncts.  Graphic devices ("glyphs") in the margin call attention to non core/non SOLO information.
</para>
<para role="fixme"><remark role="fixme"><emphasis role="para-label">FIXME: </emphasis>illustrate the glyphs here when they're ready</remark></para>
<para>
Depending on which approach you're taking, you'll make different engineering decisions and different approaches to reading the this <emphasis role="i">Guide</emphasis>.  For example, if you're determined to deploy SOLO, you can just skip all the chapters marked with the "Server Required" device, etc.
</para>
<para>
Finally, this <emphasis role="i">Guide</emphasis> does not address any browser-specific considerations.  If a thing does not run on all supported browsers for a given runtime, it's by definition not supported and thus should not be cluttering up our lovely <emphasis role="i">Guide</emphasis>. Nonstandard, browser-specific things are described in the release notes or the <ulink url="http://wiki.openlaszlo.org/Main_Page">OpenLaszlo Wiki</ulink>.
</para>

<para/></section></chapter>