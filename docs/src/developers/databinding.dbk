<chapter id="databinding">
 
<title>Data Access and Binding</title>
<!-- the section on data replication has been moved to its own chapter. IORIO 20 jan 2008 -->
<!-- remove commented out sample code that was ignored by the build. IORIO 20 nov 2007 -->
<!-- change link for data-tutorial per LPP-4923, IORIO 17 oct 2007 -->
<para>This chapter describes various methods of tying XML data structures into your LZX application.  See 
<xref linkend="data-structures"/> for discussion of some of the concepts used in this chapter.
For a gentle introduction to databinding and manipulation in OpenLaszlo applications, you may start
 with the tutorial: <xref linkend="data-tutorial" />
</para>
<section><title>Preview of databinding</title>
<para>By "databinding" we mean the automatic association of a value in an XML data structure with an element in the LZX view hierarchy of the application. This chapter explores various aspects of databinding and manipulation in OpenLaszlo applications. Before going into specific details, we'll start with a conceptual overview of how data is represented in LZX applications, and the APIs for manipulating it.</para>
<section><title>Types of data objects</title>
<para>
A dataset (<indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname>) is two things:</para>
<itemizedlist spacing="compact"><listitem><para>Firstly, it is the client side store for XML data. It's where a single XML document lives in an OpenLaszlo application. </para></listitem><listitem><para>Secondly, it's the mechanism by which OpenLaszlo applications make HTTP GET or POST requests.</para></listitem></itemizedlist>
<para>An <indexterm><primary>lz.DataElement</primary></indexterm><classname>lz.DataElement</classname> is the LZX class that represents a single XML data tag in OpenLaszlo applications. lz.DataElements are usually kept in a dataset, although data-bound views can get pointers to them even if they are not in a dataset. Inside of a dataset, lz.DataElements are linked in a tree-like structure, but that doesn't mean to say that an lz.DataElement <emphasis role="i">must</emphasis> go inside of a dataset. </para>
<para>
lz.DataElement is a subclass of <indexterm><primary>lz.DataNode</primary></indexterm><classname>lz.DataNode</classname>, as is <indexterm><primary>lz.DataText.</primary></indexterm><classname>lz.DataText.</classname>.
</para>
<para>Finally, note that a dataset is a subclass of lz.DataElement, which means that all of the methods which work on lz.DataElements also work on lz.datasets, although the usual method of manipulating datasets is with datapaths and datapointers, as explained below.</para>
</section><section><title>Two ways to interact with data</title>
<para>
As we have said, all data in OpenLaszlo applications is in XML format. 
There are two related but distinct ways of using and manipulating that data in OpenLaszlo applications; that is, there two API models:</para>
<itemizedlist spacing="compact"><listitem><para>The DOM model—in which the APIs allow you to directly manipulate elements of a Document Object Model using DOM conventions.</para></listitem><listitem><para>The DataPointer model—in which the APIs allow you to position a logical cursor within the dataset using XPATH syntax</para></listitem></itemizedlist>
<para>
These two categories of APIs have similar functionality with large areas of overlap. However, there are some things that can only be done (or can best be done) using one specific approach (and not the other).  This means that in many situations there are two logically distinct ways to achieve the same result. Learning to master data manipulation in LZX is a matter of becoming fluent in both approaches and knowing when to use each.</para>
<section><title>lz.DataNodes and the DOM APIs</title>
<para>
The <ulink url="http://www.w3.org/DOM/">Document Object Model</ulink> is, according to the W3C specification, "a platform-  and language-neutral interface that will allow programs and  scripts to dynamically access and update the content, structure  and style of documents." In the LZX context, the "document" is that lz.DataNode.
</para>
<para><indexterm><primary>lz.DataNode</primary></indexterm><classname>lz.DataNode</classname> is the base class for the classes that represent LZX's hierarchical data format. An lz.DataNode
comprises <indexterm><primary>lz.DataElement</primary></indexterm><classname>lz.DataElement</classname>s.
An lz.DataElement represents a node in a hierarchical dataset. An lz.DataElement can contain other lz.DataElements, or 
<indexterm><primary>lz.DataText</primary></indexterm><classname>lz.DataText</classname>, which represents a text node.
 More 
advanced data manipulation in OpenLaszlo applications employ the various methods on the lz.DataElement class, such as 
<indexterm><primary><literal>appendChild()</literal></primary></indexterm><methodname>appendChild()</methodname>, <indexterm><primary><literal>getNextSibling()</literal></primary></indexterm><methodname>getNextSibling()</methodname>, and so forth. These classes can only be created in script, not by tags. For tag-based data manipulation, use <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: dataset-->
 and the related concepts of datapointers and datapaths.
</para>

</section><section><title>Datapointers and Datapaths</title>
<para>
In addition to lz.DataNodes, which can only be manipulated in script, LZX includes the notions of
 <indexterm><primary>datapath</primary></indexterm><sgmltag class="element">&lt;datapath&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: datapath-->
 and <indexterm><primary>datapointer</primary></indexterm><sgmltag class="element">&lt;datapointer&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: datapointer-->
, which provide a convenient, tag-based
mechanism for typical data manipulation. By using datapointers to move through the data, you control the behavior of views that are bound to that data.
</para>
</section></section></section><section id="databinding.datasets"><title>OpenLaszlo datasets and data nodes</title>
<para>
Data in OpenLaszlo applications can be declared with a tag, or built up using procedural (script) APIs. The script APIs operate on <indexterm><primary>lz.DataNode</primary></indexterm><classname>lz.DataNode</classname>s.
</para>
<para>All declaratively-declared data in OpenLaszlo applications is contained within one or more datasets. The content of a dataset is an XML fragment with a single root node, but without the XML declaration. A given dataset usually represents a single conceptual set that may or may not be modified or reloaded during the execution of the application.</para> 
 

<para>You declare a dataset in your application using the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: dataset-->
 tag. The name of the dataset is used in the <indexterm><primary>datapath</primary></indexterm><sgmltag class="attribute">datapath</sgmltag>
 attribute of a view, as will be explained below. </para>
<para>Datasets can be embedded directly in applications, constructed at
runtime, or procured from remote servers.  A dataset may be declared on the canvas, in which case it is visible to the entire application, or it may be declared within a class, in which case it is visible to the members of that class.</para>
<para>

To embed a dataset directly
in an OpenLaszlo application, you use the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag> tag as
below. In this example, you can get access to the given dataset by referring to
<literal>canvas.shelf</literal>.</para>

<example role="live-example"><title>Embedding data in an OpenLaszlo application</title><programlisting>
&lt;canvas&gt;
  &lt;dataset name="shelf"&gt;
    &lt;bookshelf&gt;
      &lt;book binding="paperback"&gt;
        &lt;title&gt;Acts of the Apostles&lt;/title&gt;
        &lt;author&gt;John F.X. Sundman &lt;/author&gt;
        &lt;publisher&gt;Rosalita Associates &lt;/publisher&gt;
        &lt;price&gt;15.00&lt;/price&gt;
        &lt;year&gt;1999&lt;/year&gt;
        &lt;category&gt;thriller&lt;/category&gt;
        &lt;rating&gt;4.5 &lt;/rating&gt;
      &lt;/book&gt;
      &lt;book binding="casebound"&gt;
        &lt;title&gt;Shock&lt;/title&gt;
        &lt;author&gt;Robin Cook &lt;/author&gt;
        &lt;publisher&gt;Putnam &lt;/publisher&gt;
        &lt;price&gt;24.95&lt;/price&gt;
        &lt;year&gt;2001&lt;/year&gt;
        &lt;category&gt;thriller&lt;/category&gt;
        &lt;rating&gt;3.5 &lt;/rating&gt;
      &lt;/book&gt;
      &lt;book binding="paperback"&gt;
        &lt;title&gt;Cheap Complex Devices&lt;/title&gt;
        &lt;editor&gt;John Compton Sundman &lt;/editor&gt;
        &lt;publisher&gt;Rosalita Associates &lt;/publisher&gt;
        &lt;price&gt;11.00&lt;/price&gt;
        &lt;year&gt;2002&lt;/year&gt;
        &lt;category&gt;metafiction&lt;/category&gt;
        &lt;rating&gt;5.0 &lt;/rating&gt;
      &lt;/book&gt;
    &lt;/bookshelf&gt;  
  &lt;/dataset&gt;
&lt;/canvas&gt;
</programlisting></example>

<para>This style of dataset inclusion is called <indexterm significance="preferred"><primary>local data</primary></indexterm><glossterm>local data</glossterm> in
that the data is included locally in the application, rather than
being retrieved from a remote data source or web service.  Data can be
included from a remote source by specifying the
<indexterm><primary>src</primary></indexterm><sgmltag class="attribute">src</sgmltag> attribute as follows:</para>

<example role="live-example">
   <title>Dataset from a remote source</title>
   <programlisting language="lzx">
      <textobject><textdata fileref="programs/databinding-$2.lzx"/></textobject>
   </programlisting>
</example>

<para>In this example the OpenLaszlo application, when it starts up, makes a
HTTP request for the url,
<literal>http://www.w3schools.com/xml/simple.xml</literal> and populates the
dataset named <varname>menu</varname> with the XML returned.  You can
click the button to see the serialized contents of the dataset.</para>


<section><title>The <indexterm><primary>src</primary></indexterm><sgmltag class="attribute">src</sgmltag> attribute</title>

<para>The <indexterm><primary>src</primary></indexterm><sgmltag class="attribute">src</sgmltag> attribute should be a well-formed
URL that points to the back-end data source that will produce the
data.  This may be an absolute or relative URL.  (All requests made
for relative URLs are relative to the application's URL.)  The URL may
point to a static XML file or a server-side processor (such as JSP, ASP,
PHP, and so on) that produces XML data.</para>
<para>
The <indexterm><primary>src</primary></indexterm><sgmltag class="attribute">src</sgmltag> attribute of the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag> element specifies whether the data is compiled into the 
application or fetched at runtime:
</para>
<itemizedlist spacing="compact"><listitem><para>If the src attribute is a URL, the value of
 the dataset is the XML data that a request to the URL named by the
 src attribute returns when the application is run.</para></listitem><listitem><para>If the src
 attribute is a pathname, the value of the dataset is the content of
 the XML file that the pathname refers to, and is compiled into the
 application.</para></listitem><listitem><para>  If the src attribute is not present, the value of the
 dataset is the content of the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag> element.</para></listitem></itemizedlist>
<para>

The data within a dataset is accessed using a <indexterm><primary>datapointer</primary></indexterm><sgmltag class="element">&lt;datapointer&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: datapointer-->
 or a instance of one of its subclasses. 
</para>
<para>A dataset is an instantiation of the <indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname> class. An <indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname>
is a JavaScript object that provides a <glossterm>Document Object
Model</glossterm> (DOM) API for accessing, manipulating, and creating
XML elements and attributes in memory.  These APIs are discussed in
<xref linkend="databinding"/>.  The dataset also has APIs that
pertain to data transport.</para>
  <anchor id="databinding.datapaths"/>

<section><title>Interpreting a datapath</title>
<para>The <indexterm><primary>datapath</primary></indexterm><sgmltag class="attribute">datapath</sgmltag> 
of the <indexterm><primary>text</primary></indexterm><sgmltag class="element">&lt;text&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: text-->
 tag binds it to the data.</para>

<para>Datapaths use XPath attributes to navigate through the XML data. So the name of the dataset to use goes before 
the colon <literal>myData:</literal>, followed by the nodes, separated by forward slashes (/). The square brackets provide
 a (one-based) space to enter which sibling node we want. [1] is implied, so the above example could be rewritten
without any "[1]"s.</para>
<?ignore <p>In plain English, the above example says: "get me the text from the first firstName node, of the first person 
node of the first (and of course, only) myXML node." The text() method call returns that node's text.</p>

<p>To get Marge's name, we could rewrite the <tagname>text</tagname> tag as follows:</p>

<pre class="code">
&lt;text datapath="myData:/myXML/person[2]/firstName/text()" /&gt; 
</pre>

<p>Note that the "[1]"s are omitted, as they are implied. To get the "show" attribute of Montgomery, we could write:</p>

<pre class="code">
&lt;text datapath="myData:/myXML/person[3]/@show" /&gt; 
</pre>
?>
<para>The <literal>/text()</literal> path segment is unnecessary with the
<indexterm><primary>datapath</primary></indexterm><sgmltag class="attribute">datapath</sgmltag> attribute.</para>


<para>So far we've used the <indexterm><primary>text</primary></indexterm><sgmltag class="element">&lt;text&gt;</sgmltag> tag in conjunction with a single datapath. 
If we wanted to present tabular information, this would mean each text element would need its own
 datapath, and would be cumbersome and difficult to write. Instead let's make a quick table, by giving 
a <indexterm><primary>view</primary></indexterm><sgmltag class="element">&lt;view&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: view-->
 a datapath:</para>

<example role="live-example">
   <title>Assigning a datapath to a view</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$3.lzx"/></textobject> 
   </programlisting>
</example>

<para>The datapath of the entire <varname>rowOfData</varname> view has now become Homer's <varname>person</varname> node. 
The child elements of <varname>rowOfData</varname> inherit this, so their datapaths can be referenced relatively.</para>

</section><section><title>Multiple rows of data</title>

<para>In the above example we used a single <varname>rowOfData</varname> node. Next, we shall use a range of all of the nodes:</para>

<example role="live-example">
   <title>Range of nodes</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$4.lzx"/></textobject> 
   </programlisting>
</example>


<para>Whichever tag contains the <indexterm><primary>datapath</primary></indexterm><sgmltag class="attribute">datapath</sgmltag> attribute will get repeated as 
often as is necessary.</para>


<para>Remember that datapaths bind themselves to a view, so if the data changes, so will the view. </para>
</section></section></section><section id="databinding.including"><title>Ways to include data</title>

<para>
The source for a dataset may be anything that returns XML, including sources elsewhere on the web.  For instance, the source may be a URL for a .jsp or .php program that generates XML data "on the fly."  This is a typical architecture for OpenLaszlo applications.  
The table below highlights ways of categorizing datasets according to where the data comes from and how it is integrated into the application.
</para>
 
<informaltable><tgroup cols="3"><thead><row><entry>How is it included?</entry><entry>When is it loaded?</entry><entry>Syntax</entry></row></thead><tbody><row><entry><link linkend="databinding.embedded">Embedded</link></entry><entry>Compile-time</entry><entry>
<informalexample role="live-example"><programlisting>
&lt;dataset name="myData"&gt;
  &lt;myXML&gt;
     &lt;!-- ... other XML tags ... --&gt;
  &lt;/myXML&gt;
&lt;/dataset&gt;
</programlisting></informalexample>
    </entry></row><row><entry><link linkend="databinding.included">Included</link></entry><entry>Compile-time</entry><entry>
<programlisting>
&lt;dataset name="myData" src="myXMLDoc.xml"/&gt;
</programlisting>
    </entry></row><row><entry><link linkend="databinding.http">HTTP data</link></entry><entry>Runtime</entry><entry>
<programlisting>
&lt;dataset name="myData" request="true" 
         type="http" src="myXMLDoc.xml" /&gt;
</programlisting>
    </entry></row></tbody></tgroup></informaltable>


<section id="databinding.embedded"><title>Embedded Data</title>

<para>Embedded data is XML between the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag> tags. When the OpenLaszlo Compiler compiles the application, the data is bound into it. The data can still be changed after the application runs. </para>


</section><section id="databinding.included"><title>Included Data</title>
<para>Included data is essentially the same as embedded data, except that the XML itself is kept in a separate file. The size of the initial download will be the same as with embedded data.</para>

<para>It is locally referenced via the filesystem, so it can be placed in other directories. Included data is static.</para>


</section><section id="databinding.http"><title>HTTP Data</title>
<para>Remote data goes over HTTP, which means it can (but doesn't have to) be dynamic. If it is static, then the only difference between it and included or embedded data is that it is downloaded after the application loads. The <literal>type="http"</literal> attribute tells the OpenLaszlo Server that this is an HTTP request. The requests can be either GET or POST. </para>

<para>There are several points at which the client makes requests for the data:</para>

<itemizedlist spacing="compact"><listitem><para>The client will request the data
<!-- fix typo LI 9/3/2007 -->
<!-- as soon as the app loads if the the dataset's  -->
as soon as the app loads if the dataset's <indexterm><primary>request</primary></indexterm><sgmltag class="attribute">request</sgmltag> attribute is true. </para></listitem><listitem><para>The client will also request the data every time the querystring or base URL of the dataset changes (using the <indexterm><primary><literal>setQueryString()</literal></primary></indexterm><methodname>setQueryString()</methodname> or <indexterm><primary><literal>setURL()</literal></primary></indexterm><methodname>setURL()</methodname> respectively) methods of the <literal>lz.dataset</literal> object.</para></listitem><listitem><para>When the dataset's <indexterm><primary><literal>doRequest()</literal></primary></indexterm><methodname>doRequest()</methodname> method gets called.</para></listitem></itemizedlist>

<para>In the table above, we referenced a file locally (myXMLDoc.xml), but we could have done it absolutely, or we could have hit a server-side script (PHP, ASP, JSP or some CGI) that returned an XML document. We could add the query string to the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag> tag:</para>

<informalexample role="live-example"><programlisting>
&lt;dataset name="myData"
         <emphasis role="em">src="http://www.myServer.com/cgi-bin/myXMLDoc.cgi?return=addresses"</emphasis>/&gt;
</programlisting></informalexample>

<para>The <literal>type="http"</literal> attribute gets implied when the <indexterm><primary>src</primary></indexterm><sgmltag class="attribute">src</sgmltag> attribute contains "<literal>http://</literal>".</para>

</section><section><title>Dataset Scope</title>
<para>
If specified on the canvas, datasets are visible to and accessible by the entire application. Datasets can also be local to a class.
</para>
<itemizedlist spacing="compact"><listitem><para>Datasets will automatically name themselves <literal>localdata</literal> if a name is not specified </para></listitem><listitem><para>Local datapath syntax is 
datapath="local:<emphasis role="i">reference.to.dataset.relative.to.parent</emphasis>:/path" </para></listitem><listitem><para> The name of the dataset can be omitted from the datapath if the dataset name is the default 'localdata', e.g. 'local:classroot:/' can be used instead of 'local:classroot.localdata:/' for a dataset named localdata in the classroot</para></listitem></itemizedlist>
<para>
   Here is a simple program that illustrates use of local datasets (the file testdata.xml,  a sample XML file is included in this directory also.)
</para>
<example role="live-example">
   <title>local datasets</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$7.lzx"/></textobject> 
   </programlisting>
</example>

</section><section><title><indexterm><primary>ondata event</primary></indexterm><literal>ondata</literal>, <indexterm><primary>onerror event</primary></indexterm><literal>onerror</literal> and <indexterm><primary>ontimeout event</primary></indexterm><literal>ontimeout</literal> event</title>

<para>When the application's <indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname> receives the data, the
<indexterm><primary>ondata event</primary></indexterm><literal>ondata</literal> event is sent.  In the case that an error occured
in communicating with the back-end (which may be proxied by the OpenLaszlo Server in proxied applications, or direct, in SOLO applications), an <indexterm><primary>onerror event</primary></indexterm><literal>onerror</literal> event is
sent instead.  And, if there is a timeout (currently hard-coded at 30
seconds) in communicating with the back end, an <indexterm><primary>ontimeout event</primary></indexterm><literal>ontimeout</literal>
event is sent.  The OpenLaszlo Runtime guarentees that each request generates
exactly one of <indexterm><primary>ondata event</primary></indexterm><literal>ondata</literal>, <indexterm><primary>onerror event</primary></indexterm><literal>onerror</literal>, or
<indexterm><primary>ontimeout event</primary></indexterm><literal>ontimeout</literal>.
</para>


</section><section><title>POST support</title>
<para>Datasets support both HTTP GET and POST methods for communicating
with the OpenLaszlo Server and back-end servers.  The default is GET but this can be
changed with the <literal>lz.dataset.setQueryType()</literal> API.  In
general, requests with large query parameters should be sent via
POST.</para>



</section><section><title>HTTP Request and Response headers</title>

<para>In general, the OpenLaszlo Server proxies HTTP request and response headers
to and from the back-end.  However, certain headers are specifically
omitted or modified.</para>
<para>
Note that response headers are not available to SOLO applications.
</para>

<para role="fixme"><remark role="fixme"><emphasis role="para-label">FIXME: </emphasis>include the list here</remark></para>

</section><section><title>Cookies</title>

<para>The OpenLaszlo Server proxies all "Cookie" request headers and all
"<literal>Set-Cookie</literal>" response headers.  Because of
the domain name restrictions on cookies, the OpenLaszlo Server can only properly
proxy these cookie headers when the back-end host is in the same
domain (or a subdomain) or the OpenLaszlo host.  For more on this topic, see <xref linkend="cookies"/></para>

</section></section><section><title>AJAX API</title>
<para>
 
<indexterm><primary>XMLHTTPRequest</primary></indexterm><sgmltag class="element">&lt;XMLHTTPRequest&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: XMLHTTPRequest-->
 implements XMLHttpRequest as <ulink url="http://developer.apple.com/internet/webcontent/xmlhttpreq.html"> specified</ulink> by the <ulink url="http://www.whatwg.org/specs/web-apps/current-work/#scripted-http">what-wg
</ulink> consortium. Basically, this class allows you to fetch XML data from a URL, and so it is essentially equivalent to the <indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname> API (or the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: dataset-->
 tag.)  It is provided as a convenience to developers who are familiar with its syntax from its use in AJAX applications.  
</para>
<para>
Here is an example of the XMLHTTPRequest class.
</para>
<example role="live-example">
   <title>XMLHTTPRequest</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$8.lzx"/></textobject> 
   </programlisting>
</example>


<section><title>Using XMLHTTPRequest() in SOLO applications</title>
<para>In SOLO applications, the <indexterm><primary>XMLHTTPRequest</primary></indexterm><classname>XMLHTTPRequest</classname> class does provide one capability that is not currently available from datasets; that is, you can get the raw text of the XML as a string, before it is parsed.  You do this using the <indexterm><primary><literal>responseText()</literal></primary></indexterm><methodname>responseText()</methodname> method. This capability is only available in SOLO applications.
</para>
<para>
Note that by accessing a URL in this way you can fetch data that is not XML, which may come in handy in some situations.  However, since LZX is predicated on the XML data model, in general you shouldn't expect to be using this technique very much.</para>
<para>
Also, in SOLO deployed applications, the <indexterm><primary>XMLHTTPRequest</primary></indexterm><classname>XMLHTTPRequest</classname> class departs from the what-wg specification in these ways:</para>
<itemizedlist spacing="compact"><listitem><para>HTTP headers are not settable</para></listitem><listitem><para>response headers are not accessible</para></listitem><listitem><para>you cannot send raw POST data</para></listitem><listitem><para>you cannot send repeated query args in a POST using LoadVars</para></listitem><listitem><para>Username/password HTTP Auth args to send() are not supported.</para></listitem></itemizedlist>

  
</section></section><section id="databinding.datapointers"><title>Datapointers</title>

<para>We introduced datapaths first, which are extensions of datapointers, but they can become cumbersome. A datapointer points to just one place of the dataset at a time, but can be moved around -- you can have multiple datapointers, each pointing to a different part of a dataset.</para>

<para>Datapointers are not bound to views like datapaths are, but they do have a place in the view hierarchy—that is, they "know about" parents and children.</para>

<para>You will use a datapointer when you need to operate on the data in some way. For example, using the same format of data as in the previous examples, say you wanted to find all the people who were in the South Park show:</para>

<example role="live-example">
   <title>Manipulating datapointers</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$9.lzx"/></textobject> 
   </programlisting>
</example>



<para>For brevity's sake, we are writing to the debugger, and we are including the data from a local file.</para>

<para>The <literal>selectChild(2)</literal> method call selects the <indexterm><primary>myXML</primary></indexterm><sgmltag class="element">&lt;myXML&gt;</sgmltag> node, then the South Park <indexterm><primary>person</primary></indexterm><sgmltag class="element">&lt;person&gt;</sgmltag> node -- it selects the second-depth node because of the depth argument "2" we passed it (otherwise it would default to 1.</para>

<para>The <literal>selectNext</literal> method call returns <literal>true</literal> as long as an XML node was successfully selected (i.e. until there aren't any more). We exploit this by using it in a <literal>do <replaceable>…</replaceable> while</literal> loop, so that the same iteration occurs for every <indexterm><primary>person</primary></indexterm><sgmltag class="element">&lt;person&gt;</sgmltag> node.</para>

<para>We could also have given the <indexterm><primary>datapointer</primary></indexterm><sgmltag class="element">&lt;datapointer&gt;</sgmltag> <indexterm><primary>onerror event</primary></indexterm><literal>onerror</literal> and <indexterm><primary>ontimeout event</primary></indexterm><literal>ontimeout</literal> event handlers to capture any problems. </para>




</section><section><title>Accessing data</title>
<section><title>Datasets</title>

<para>A <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: dataset-->
 provides a way to
encapsulate arbitrary XML data in an OpenLaszlo application. Depending on
the source of the data, datasets can be static or dynamic. When a
dataset is explicitly declared with <literal>type="http"</literal>, the
value of its <indexterm><primary>src</primary></indexterm><sgmltag class="attribute">src</sgmltag> is interpreted as an URL and
the dataset is populated with data at runtime. If the
<indexterm><primary>src</primary></indexterm><sgmltag class="attribute">src</sgmltag> attribute is absent, the data it represents
is expected to be contained within the <indexterm><primary>dataset</primary></indexterm><sgmltag class="element">&lt;dataset&gt;</sgmltag>
tags, and thus also compiled into the application.</para>

<para>When we say that HTTP datasets are dynamic, we mean that you can
repopulate them programmatically by calling the
<indexterm><primary><literal>doRequest()</literal></primary></indexterm><methodname>doRequest()</methodname> method of the dataset object, or if the
<indexterm><primary>request</primary></indexterm><sgmltag class="attribute">request</sgmltag> attribute is set to true, by changing
the URL of the dataset when one of the <indexterm><primary><literal>setSrc()</literal></primary></indexterm><methodname>setSrc()</methodname>,
<indexterm><primary><literal>setQueryString()</literal></primary></indexterm><methodname>setQueryString()</methodname>, or <indexterm><primary><literal>setQueryParam()</literal></primary></indexterm><methodname>setQueryParam()</methodname>
methods is called.</para>
<section><title>Globally Visible Datasets</title>
<para>When a dataset is defined as an immediate child of <indexterm><primary>canvas</primary></indexterm><sgmltag class="element">&lt;canvas&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: canvas-->
 or <indexterm><primary>library</primary></indexterm><sgmltag class="element">&lt;library&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: library-->
, it can be referenced
anywhere in the code through the <indexterm><primary>datasets</primary></indexterm><sgmltag class="attribute">datasets</sgmltag>
property of canvas, i.e.  <literal>canvas.datasets['mydset']</literal>, or
simply by its name (it is globally visible):</para>
<example role="live-example">
   <title>Explicitly defined datasets</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$10.lzx"/></textobject> 
   </programlisting>
</example>


</section><section><title>Datasets created at runtime</title>
<para>Datasets can also be created at runtime in script by calling the constructor for the <indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname>:
<literal>var dset = new lz.dataset(null, {name: 'mydset'})</literal>. The first argument to the constructor is 
the dataset's parent node, which is the <indexterm><primary>datasource</primary></indexterm><sgmltag class="element">&lt;datasource&gt;</sgmltag><remark role="fixme">[unknown tag]</remark>
<!--unknown tag: datasource-->
 that encloses this dataset; this
parameter is allowed to be null — in this case a datasource will be created implicitly.
</para>


</section></section></section><section><title>Simple binding</title>

<para>The LZX event system allows you to insert custom data
handling into the application as needed. This is typically done by
overriding the <indexterm><primary><literal>applyData()</literal></primary></indexterm><methodname>applyData()</methodname> method of the databound
node, by providing a handler for the <indexterm><primary>ondata event</primary></indexterm><literal>ondata</literal> event on
the datapointer or datapath, or by defining a <literal>$path</literal>
constraint on an expression-type attribute and processing changes to
the attribute's value with the
<literal>on<varname>attribute_name</varname></literal> handler.</para>

<section><title>Overriding applyData</title>

<para>The <indexterm><primary><literal>applyData()</literal></primary></indexterm><methodname>applyData()</methodname> method is called on any node that is
declared with a datapath that matches a terminal selector, such as
<literal>text()</literal> or <literal>@<varname>attribute</varname></literal> when the data it
matches is changed. The argument passed to the method is the string
the data represents. Use the <indexterm><primary>ondata event</primary></indexterm><literal>ondata</literal> event if the node
is bound to a datapath that matches a data node (see below).
</para>
<example role="live-example">
   <title>Overriding applyData</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$11.lzx"/></textobject> 
   </programlisting>
</example>



</section><section><title>Attribute bindings using $path</title>
<para>Attributes of a node can be bound to data explicitly by using the <literal>$path{}</literal> constraint syntax. The expression
inside the curly brackets must evaluate to a string, which is interpreted as a relative XPath expression. 
</para>
<section><title>Absolute paths</title>
<para>If you
need to use an absolute path in the expression, you could instead constrain the attribute to the result of an 
<indexterm><primary><literal>xpathQuery()</literal></primary></indexterm><methodname>xpathQuery()</methodname> call: <literal>visible="dp.xpathQuery('mydset:/record/row[1]/@visible')"</literal>. A
 limitation of the <literal>$path{}</literal> constraint is that the expression it contains is evaluated only at the 
initialization time, that is, an expression such as <literal>$path{'mynode[' + i + ']/@attr'}</literal> will behave like a 
<literal>$once{}</literal> constraint.</para> 
<para>$path bindings are two-way, so calling <indexterm><primary><literal>updateData()</literal></primary></indexterm><methodname>updateData()</methodname> 
on a node's datapath will store the current value for that attribute back in the dataset.
</para>
<example role="live-example">
   <title>$path constratint bindings</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$12.lzx"/></textobject> 
   </programlisting>
</example>


</section><section><title>Attribute values by $path constraint</title>

<para>Assigning a node's attribute value by <literal>$path</literal> constraint results in replication of the node as many times as necessary to correspond to each item in the <literal>dataset</literal>.</para>

<para>In this example, there are three items in the <literal>dataset</literal>, so the <literal>box</literal> node replicates three times.</para>

<example role="live-example">
   <title>Assigning an attribute value by $path constraint</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$13.lzx"/></textobject> 
   </programlisting>
</example>

</section><section><title>$path values in calculations</title>
<para>
JavaScript provides easy casting from string to numeric data types. The $path{...} syntax is defined to return a string, which can be used to assign a value to an attribute.  You can combine attributes to preform calculations based on strings returned from a $path{...} inquiry on a dataset.
</para>
<para>
Say, for example that you had a dataset that contained temperatures in Fahrenheit that you wished to convert to Centigrade. You would have to create an intermediate attribute that binds to the (possibly replicated) path constraint and then bind your text field to a calculation on that attribute. Something like:</para>
<example role="live-example"><title>calculations on $path{} values</title><programlisting>
  &lt;attribute name='intermediate' value="$path{'degf'}" \&gt;
  &lt;attribute name='text' value="${Number(intermediate) * 5 / 9}" /&gt;
</programlisting></example>



</section></section><section><title>The .data property</title>
<para>The <structfield>data</structfield> property is a shorthand way of accessing data referenced by a datapointer or a datapath. 
For convenience, a datamapped node gets its data property set to that of the datapath it is bound to. In the example
below, the color view changes its properties as the data field to which they are constrained follows the "order" 
attribute of the nodes in the dataset. Note that the data is a string value of the attribute; this is the case when 
the XPath matches an operator. The datapath of the enclosing view, however, refers to entire node in the dataset,
and its data property contains an instance of <indexterm><primary>lz.DataNode</primary></indexterm><classname>lz.DataNode</classname> that the XPath references. This is
evident from the debugger output.</para>
<example role="live-example">
   <title>Using the data property</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$15.lzx"/></textobject> 
   </programlisting>
</example>



</section><section><title>Using ondata to process updates</title>
<para>For a datapointer, a datapath, or a datamapped node, the <indexterm><primary>ondata event</primary></indexterm><literal>ondata</literal> event is sent whenever the data it 
is bound to changes. This implies that for XPaths that select a data node, ondata event is sent only when the 
datapointer is set to point to a different node. If the pointer selects an operator, i.e. <literal>"text()"</literal> or <literal>"@attr"</literal> it is 
also sent when the text or the attribute it matches has changed. The argument sent with the event is the current 
value of the data property of the node or the datapointer (see previous section).</para>

<para>The example below makes use of the ondata event sent by a temporary
datapointer to calculate the average of a sequence of accumulated
numbers and display it. Then event is sent when the
<indexterm><primary><literal>setXPath()</literal></primary></indexterm><methodname>setXPath()</methodname> method is invoked on the
datapointer. Typically, a problem like this would be easier to program
using JavaScript's built-in arrays, but this version illustrates the
data-driven approach. It also introduces the concept of data
replication, which is explained in more detail later in this
document.</para>
<example role="live-example">
   <title>Ondata event</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$14.lzx"/></textobject> 
   </programlisting>
</example>



</section></section><section><title>Manipulating datapointers</title>
<para>
Recall that datapointer is an object that represents a pointer to a node in a <indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname>. The datapointer can be repositioned using either cursor movements calls such as <indexterm><primary><literal>selectNext()</literal></primary></indexterm><methodname>selectNext()</methodname>, or by running an XPath request via <indexterm><primary><literal>setXPath()</literal></primary></indexterm><methodname>setXPath()</methodname>.
</para>
<para>
Datapointers support a subset of the XPath specification, which uses a notation similar to the UNIX file-system to refer to nodes within a dataset. Once a datapointer is bound to a node in a dataset it will keep pointing to that node until it is moved. If the dataset is edited, the behavior of the datapointer will be controlled by its rerunxpath attribute. If this attribute is true (the default value), it will continue pointing to its current node as long as it is valid.
</para>
<section><title><indexterm><primary>rerunxpath</primary></indexterm><sgmltag class="attribute">rerunxpath</sgmltag></title>
<para>The <indexterm><primary>rerunxpath</primary></indexterm><sgmltag class="attribute">rerunxpath</sgmltag> property of datapointer determines whether the XPath expression is re-evaluated every time the 
contents of the dataset change. The default is false; if set to true, every time the dataset is edited, the XPath 
binding is refreshed. In other words, the datapointer is assumed to be "constant" unless the <indexterm><primary>rerunxpath</primary></indexterm><sgmltag class="attribute">rerunxpath</sgmltag> attribute 
is true.</para>
<example role="live-example">
   <title>Using rerunxpath attribute</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$16.lzx"/></textobject> 
   </programlisting>
</example>



<para>This example illustrates the effect of the <indexterm><primary>rerunxpath</primary></indexterm><sgmltag class="attribute">rerunxpath</sgmltag> property. The text fields at the bottom are updated when 
the ondata event is sent by the datapointers intended to be bound to the first node in the dataset. However, the 
first one is declared with <literal>rerunxpath="true"</literal>, and therefore it points to the actual first data node, while the 
second one remembers the node it was referencing initially, and never gets updated.</para>
</section><section><title>Forcing visibility of datamapped views</title>
<para>By default, a view that is databound will have a <literal>visibility</literal> attribute of <literal>
collapse</literal>, 
which will cause it not to be visible when it has no data, that is, when the xpath does not match 
any entries in the dataset.</para>
<para>However, sometimes it is desirable to override this behavior, specifying that a datamapped 
view should be visible regardless of whether or not it has data. A typical example of this is a panel 
containing placeholder views mapped to dynamically retrieved data records, that need to be visible at 
all times. You do this by setting the view's <literal>visibility</literal> attribute to <literal>visible</literal>.</para>

<para>The following example allows you to explore the effect of different settings of the <literal>
visibility</literal> 
attribute when the databinding of a view does and does not match. There are three 'stoplights', 
the red bulb has <literal>visibility="hidden"</literal>, the yellow bulb has <literal>visibility="collapse"
</literal> and the green bulb 
has <literal>visibility="visible"</literal>. This means the green light will always be on, the yellow light will be 
on when there is data and the red light will never be on. When initially loaded, there is only 
data for the first stoplight, the second and third stoplights have no matching data. Clicking on 
the Add Data button will add another entry to the <literal>dataset</literal> causing the second (and third if you 
click again) stoplight to have data. The text describes the current state of each bulb's <literal>visibility</literal> 
and <literal>visible</literal> attributes. You can see the <literal>visible</literal> attribute of the 
second and third yellow lights change 
when you Add Data. You can also press the Toggle Visibility on each light bulb to cycle through the 
different <literal>visibility</literal> settings to see how they affect the <literal>visible</literal> attribute 
depending on the presence or absence of data.</para>
<example role="live-example">
   <title>Visibility of datamapped views</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/viewvisibility.lzx"/></textobject> 
   </programlisting>
</example>

</section><section><title>Update timing (order of data initialization)</title>
<para>Because data contained by static datasets is compiled into the application, it is available immediately. 
Therefore any datapointers that have a static dataset as part of their paths will send the ondata event before
any children of the canvas are instantiated by the runtime. This is important to remember if all changes in the 
data need to be reflected in the application's interface. In other words, when writing handlers for <literal>ondata</literal>, one 
should be careful not to reference views that may not have been fully initialized.</para>

<para>In the example below, we attempt to expand a datamapped tree in response to the ondata event, but the tree is 
backed by the same data and is not yet fully initialized, since there was not enough time for databinding to occur. 
Thus, the <indexterm><primary><literal>openChildren()</literal></primary></indexterm><methodname>openChildren()</methodname> call on the first tree fails and the tree is not expanded. The solution is to move the 
call to the handler for <indexterm><primary>oninit event</primary></indexterm><literal>oninit</literal>, which will be sent when the tree and all of its children (also trees) 
have finished initializing. This result of this approach is that the call succeeds and the second tree is expanded.</para>
<example role="live-example">
   <title>Proper handling of data updates</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$18.lzx"/></textobject> 
   </programlisting>
</example>


<para>On the other hand, dynamic datasets have to fetch data externally, so they may not deliver it before the visual 
elements that depend on it are in a stable state. This is why the logic in the code should only attempt to
use these datamapped elements in response to the ondata event or by overriding the applyData method (see above).
Note that the <indexterm><primary>lz.dataset</primary></indexterm><classname>lz.dataset</classname> object itself sends an ondata event whenever it receives new data; this is a convenient 
way of synchronizing UI operations with arrival of data it is tied to. As stated above, static datasets cause ondata 
to be sent as soon as they are instantiated.</para>

</section><section><title>Iterator methods</title>
<para>Often, the <indexterm><primary>lz.datapointer</primary></indexterm><classname>lz.datapointer</classname> API provides the most convenient way to traverse the hierarchy of nodes in a dataset. Below
is an example that recursively walks a dataset mapped to a tree by calling iterator methods on a datapointer initially 
set to the top of the dataset, and adds a new node at each level.</para>
<example role="live-example">
   <title>Using datapointer's iterator methods</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$19.lzx"/></textobject> 
   </programlisting>
</example>


</section></section><section><title>Data processing</title>
<section><title>Using <indexterm><primary><literal>setPointer()</literal></primary></indexterm><methodname>setPointer()</methodname> to bind data</title>
<para>As an essential part of their functionality, datapointers (and datapaths) can be set directly to data nodes. 
The example below uses the <indexterm><primary><literal>setPointer()</literal></primary></indexterm><methodname>setPointer()</methodname> method to set the target view's datapath to the node referenced by the 
datapath of the selected view. In effect, this maps the details view to the contact currently selected in the 
dataset.</para>
<example role="live-example">
   <title>Using setPointer</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$20.lzx"/></textobject> 
   </programlisting>
</example>


</section><section><title>Controlling a datapath</title>

<para><indexterm><primary>lz.datapath</primary></indexterm><classname>lz.datapath</classname> is a subclass of <indexterm><primary>lz.datapointer</primary></indexterm><classname>lz.datapointer</classname>, and therefore can be used in much the same way to iterate over data.
The example below treats the datapath of each of the replicated view as a pointer to the dataset that backs it.
The datapath of the enclosing view in this context is simply a pointer to the root of the dataset, and thus it
could be used to manipulate and add children nodes.</para>
<example role="live-example">
   <title>Dereferencing datapaths</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$21.lzx"/></textobject> 
   </programlisting>
</example>


<para>There is an important restriction on usage of iterator methods with a datapath. If you move it by calling any 
of <literal>select<replaceable>...</replaceable>()</literal> or <literal>set<replaceable>XXX</replaceable>Pointer()</literal> methods, its XPath is then removed, which means that any updates to underlying 
data will not notify the datamapped UI element. Consider the following example.</para>
<example role="live-example">
   <title>Datapath iteration</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$22.lzx"/></textobject> 
   </programlisting>
</example>



<para>You can move the datapath of the contact detail view in either direction, and the text fields will update 
correctly. This is because their respective datapaths are unaffected by the scrolling (it only moves the 
datapath of the containing view). However, deleting a contact will only result in an automatic update to the 
text fields if no navigation has yet occurred. The solution is to reset the datapath's XPath to the proper value
by calling the <indexterm><primary><literal>setXPath()</literal></primary></indexterm><methodname>setXPath()</methodname> method:</para>
<example role="live-example">
   <title>Datapath iteration workaround</title>
   <programlisting language="lzx">
   <textobject><textdata fileref="programs/databinding-$23.lzx"/></textobject> 
   </programlisting>
</example>


</section></section></chapter>
