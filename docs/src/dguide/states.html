<html xmlns="http://www.w3.org/1999/xhtml" id="states">
<head>
    <title>States</title>
</head>

<body>

<!-- optional -->
 
<h1> States </h1>

<p>This chapter discusses the general use of states and the built in states dragstate and resizestate.</p>

<!--=========================================================================-->
<!-- Major sub-heads in h2, etc                                              -->
<!--=========================================================================-->
<h2><a name="I">Overview</a></h2>

<p><dfn>States</dfn> are a convenient method of defining multiple complex behaviors in your application using declarative syntax, 
behaviors that might normally be contained in a script block.
 </p>
<p>States are written within the object to which the state is applied and can contain any number of children. 
All code in a <tagname link="true">state</tagname> is written as if it were directly inside the parent of the state when it is applied.  This concept sounds 
a bit abstract, but in practice seems quite natural, as we hope the following discussion will make clear.</p>

<h2>States vs Procedures</h2> 

<p>
Declarative programming is great for declaring the initial state of an application, but 
subsequent transformations may make the originally declared structures barely recognizable. 
Laszlo's <tagname link="true">state</tagname> construct provides a way to make declarative constructs effectively procedural.
</p>
<p>
The alternative to using states is to declare the initial state of your program with tags, and then 
manipulate that state with procedural code, 
that is, with script.  This poses a problem, because some of LZX's most powerful features are difficult to add 
programmatically.
</p>
<p>
This is particularly true of animators and constraints. Constraints are central to the whole Laszlo idea, but manipulating them with script can be very tricky.
For instance, here's a small program where the blue box follows the mouse:
</p>

<example title="following mouse without states">
&lt;canvas&gt;
  &lt;view bgcolor="blue" width="20" height="20"&gt;
    &lt;attribute name="x" value="${parent.getMouse('x') - 10}"/&gt;
    &lt;attribute name="y" value="${parent.getMouse('y') - 10}"/&gt;
  &lt;/view&gt;
&lt;/canvas&gt;
</example>

<p>
While this is a nice way of expressing this kind of thing (made possible by Laszlo's constraint system), it's rarely useful in a program.
 Usually, objects only follow the mouse when they're being dragged. What's needed for that is a way to write declarative LZX nodes that 
could be applied and removed depending on whether the view is to be dragged or not.
</p>
<p>
The <tagname>state</tagname> tag makes this possible. Here's a rewrite of the above program using states to make the blue 
box drag only when the mouse is down:
</p>
<example title="using &lt;state&gt; to follow mouse">
&lt;canvas&gt;
  &lt;view bgcolor="blue" width="20" height="20"
        onmousedown="this.setAttribute('mouseIsDown', true )"
        onmouseup="  this.setAttribute('mouseIsDown', false )"&gt;
    &lt;attribute name="mouseIsDown" value="false"/&gt;
    &lt;state apply="${parent.mouseIsDown}"&gt;
      &lt;attribute name="x" value="${parent.getMouse('x') - 10}"/&gt;
      &lt;attribute name="y" value="${parent.getMouse('y') - 10}"/&gt;
    &lt;/state&gt;
  &lt;/view&gt;
&lt;/canvas&gt;
</example>

<p>
Note that the syntax of the constraints hasn't changed; they're just inside a <tagname>state</tagname> tag. 
This is useful, but it's also a little strange: the <tagname>state</tagname> tag is essentially an invisible node of 
hierarchy. You can see this in the fact that the <code>parent</code> in the apply constraint for the state is
 not the same object as the <code>parent</code> in the drag constraints inside the state.
</p>
<p>
This example highlights the metaphysical nature of states: they modify the meta-object protocol enough so that
 their contents can be stored and applied elsewhere. (This could conceivably be a feature of the system as a whole 
 as in, for example, <code>anLzNode.setParent(otherLzNode)</code>, but it's not). 
</p>
<h3>Attributes of states</h3>
<p>
Here's a question: what should happen when you write this?
</p>
<example extract="false" title="attributes of states">
  &lt;class name="myDragState" extends="state"&gt;
    &lt;attribute name="dragMin" value="2"/&gt;
    &lt;attribute name="dragMax" value="20"/&gt;
    &lt;!-- ... --&gt;
  &lt;/class&gt;
</example>
<p>
Do the attributes <attribute>dragMin</attribute> and <attribute>dragMax</attribute> pertain to the state itself, 
or to the state's container? The former is more powerful: it would allow for developers to extend the special behavior of states, 
say by over-riding the state's apply method. The latter, though, is more consistent with the LZX idiom, where, 
as a first-order approximation, a class behaves like a macro.
</p>
<p>
The answer is, the behavior is the latter: attributes apply to the state's container. Here's a little test program that shows that.</p>

<example title="attributes pertain to container, not parent">
&lt;canvas&gt;
  &lt;class name="constrainedDragState" extends="state"&gt;
    &lt;attribute name="dragMin" value="100"/&gt;
    &lt;attribute name="dragMax" value="300"/&gt;
    &lt;attribute name="mousePos" value="${parent.getMouse( 'x' ) - 10}"/&gt;
    &lt;attribute name="x" 
               value="${Math.max(Math.min(this.dragMax, this.mousePos),
                                 this.dragMin )}"/&gt;
  &lt;/class&gt;
  
  &lt;view bgcolor="blue" width="20" height="20" x="100" y="50"
        onmousedown="myDrag.apply()"
        onmouseup="  myDrag.remove()"&gt;
    &lt;attribute name="mouseIsDown" value="false"/&gt;
    &lt;constrainedDragState name="myDrag"/&gt;
  &lt;/view&gt;
&lt;/canvas&gt;
</example>
<p>
Note that the references to <code>dragMin</code>, <code>dragMax</code> and such are all qualified by the keyword <code>this</code>.
</p>

<p>
Any attribute for which the state has a setter belongs to the state itself, 
whereas any attribute that doesn't belongs to the state's <code>apply</code> target. This makes sense, 
because any setter for an attribute which is intended to be applied by the state 
(and not kept by the state) can be written in the apply target. 
This how it  works in LZX. Here's a little program that proves that:</p>

<example title="using setters in &lt;state&gt; attributes">
&lt;canvas debug="true"&gt;
  &lt;class name="testState" extends="state"&gt;
    &lt;attribute name="countApplies"  value="0"
               setter="this.countApplies = countApplies"/&gt;
    &lt;method name="apply"&gt;
      this.setAttribute('countApplies', ++this.countApplies);
      super.apply();
    &lt;/method&gt;
  &lt;/class&gt;
  &lt;button &gt;Try it
    &lt;handler name="onclick"&gt;
      ts.apply();
      Debug.write("applies:" + ts.countApplies);
      ts.remove();
    &lt;/handler&gt;
    &lt;testState name="ts"/&gt;
  &lt;/button&gt;
&lt;/canvas&gt;
</example>
 
<h3>Performance Considerations</h3>
<p>All states are instantiated. Therefore your application "pays the instantiation cost" of a regular node 
of hierarchy for a state, whether or not it is applied. This is because the state is itself an <classname>LzNode</classname>,
 which must be processed by the <classname>LzNode</classname> constructor.</p> 
<p>
The advantage of limiting the ways in which a developer can modify a 
state itself is that then a given state can have a limited number of attributes, which are controlled by the runtime. 

Allowing developers to change the semantics of "state" by attaching attributes and methods to it would make it harder to make 
this optimization. 
</p>
 
 	
<example title="using states to animate transitions">
&lt;canvas&gt;
  &lt;window title="state demo" width="400" height="300"&gt;
    &lt;state name="max" apply="true"&gt;
      &lt;animatorgroup duration="1000" process="simultaneous"&gt;
        &lt;animator attribute="width" to="400"/&gt;
        &lt;animator attribute="height" to="300"/&gt;
        &lt;animator attribute="x" to="100"/&gt;
        &lt;animator attribute="y" to="100"/&gt;
      &lt;/animatorgroup&gt;
      &lt;text align="center" y="20%"&gt;M a x i m i z e d&lt;/text&gt;
    &lt;/state&gt;
    &lt;state name="min" &gt;
      &lt;animatorgroup duration="1000" process="simultaneous"&gt;
        &lt;animator attribute="width" to="170"/&gt;
        &lt;animator attribute="height" to="100"/&gt;
        &lt;animator attribute="x" to="0"/&gt;
        &lt;animator attribute="y" to="0"/&gt;
      &lt;/animatorgroup&gt;
      &lt;text align="center" valign="middle"&gt;Minimized&lt;/text&gt;
    &lt;/state&gt;
    &lt;button placement="title_area" align="right" height="16"&gt; Toggle
      &lt;attribute name="isMax" value="true"/&gt;
      &lt;handler name="onclick"&gt;
        if (this.isMax) {parent.max.remove(); parent.min.apply();}
        else {parent.max.apply(); parent.min.remove();}
        this.isMax = !this.isMax;
      &lt;/handler&gt;
    &lt;/button&gt;
&lt;/window&gt;
&lt;/canvas&gt;
</example>
<p>
   The state element is declared with the <attribute>apply</attribute>, <attribute>onapply</attribute>, and
   <attribute>onremove</attribute> attributes, and the <tagname>view</tagname>.  <attribute>apply</attribute>, 
<attribute>onapply</attribute>,
   and <attribute>onremove</attribute> control the behavior of the state itself.  Any other
   attributes and children are applied to the state's parent, when
   the state is applied.
   </p>
<h3>States that are not children of views</h3>
<p>
If the state is a child of an element that is not a view,
   such as a <tagname>layout</tagname> or <tagname>animator</tagname>, then the view attributes may not
   make sense.  It is possible to attach an attribute that applies
   to one of these other elements to a state, by using
   the <tagname link="true">attribute</tagname> element.
</p>
 


<h3><a name="II">States may contain views or classes </a></h3>


<p>States can also contain views or classes that are only created when the state is applied.</p>

<pre>
&lt;state name="showchildren"&gt;
  &lt;view y="13" x="13" name="children"&gt;
    &lt;simplelayout/&gt;
    &lt;treeitem grown="${classroot.opened}"&gt;
      &lt;datapath xpath="*" pooling="true"/&gt;
    &lt;/treeitem&gt;
   &lt;/view&gt;
&lt;/state&gt;
</pre>

<h3>Dragstate</h3>
<p>You can subclass <tagname>state</tagname> to suit whatever purpose at hand. LZX contains two such subclasses of <tagname>state</tagname> 
to solve common problems.</p>
<p>This example shows how to subclass the <tagname>dragstate</tagname> class to create a state functionality that you can apply to
 different views. </p>

<example title="Dropshadow done using states">
&lt;canvas height="200"&gt;
  &lt;class extends="dragstate" name="fadeDragger" pooling="true"&gt;
    &lt;method event="onapply"&gt;
      parent.bringToFront();
      parent.setAttribute('opacity', .5)
    &lt;/method&gt;
    &lt;method event="onremove"&gt;
      parent.setAttribute('opacity', 1)
    &lt;/method&gt;
    &lt;view name="hShadow" x="10" y="${parent.body.height}"
          width="${parent.body.width}" height="10"
          opacity=".2" bgcolor="black"/&gt;
    &lt;view name="vShadow"  x="${parent.body.width}" y="10"
          width="10" height="${parent.body.height - 10}"
          opacity=".2" bgcolor="black"/&gt;
  &lt;/class&gt;
  
  &lt;view
        onmousedown="myFadeDragger.apply()"
        onmouseup="myFadeDragger.remove()"&gt;
    &lt;fadeDragger name="myFadeDragger"/&gt;
    &lt;view name="body" width="40" height="40" bgcolor="blue"/&gt;
  &lt;/view&gt;
  &lt;view x="100" y="100"
        onmousedown="myFadeDragger.apply()"
        onmouseup="myFadeDragger.remove()"&gt;
    &lt;fadeDragger name="myFadeDragger"/&gt;
    &lt;view name="body" width="60" height="60" bgcolor="red"/&gt;
  &lt;/view&gt;
&lt;/canvas&gt;
</example>

<!-- See other chapters in the D3 guide and also the wiki for more informtion on formatting chapters --> 
<!-- Here is a list of some topics you may want to discuss in this chapter-->


 
<?ignore 

<h3>Resizestate</h3>




 
 States and Performance  
 
 

It would be good to point out the use of a multi-frame resource for different states (like what's done in window and button)
 

    Avoid changing a state's view at runtime
     Costly
 
  Use "frames" instead
 States
    Analogous to layouts: temporal placement of multiple views
       two uses/benefits
           Express changes that can be applied at runtime
           To optimize application performance 
 Views aren't created until needed
       A description of an instance hierarchy 
       can be applied or removed at runtime
       Applying state with a constraint
           Adds constraint, doesn't replace
Tags discussed in this chapter: state, dragstate, resizestate,
 ?>

</body>
</html>
<!-- * X_LZ_COPYRIGHT_BEGIN ***************************************************
* Copyright 2001-2006 Laszlo Systems, Inc.  All Rights Reserved.              *
* Use is subject to license terms.                                            *
* X_LZ_COPYRIGHT_END ****************************************************** -->
