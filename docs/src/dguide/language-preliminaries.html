<html xmlns="http://www.w3.org/1999/xhtml" id="language-preliminaries">
<head>
<title>Language Preliminaries</title>
</head>
<body>

<h1>Language Preliminaries</h1>

<p>LZX is an object oriented, tag-based language that uses XML and JavaScript syntax to create the presentation layer 
of rich internet applications. Typically these applications are compiled by the 
OpenLaszlo compiler. They may be deployed as standalone files, or they may be 
served by the OpenLaszlo Server. 
The specification of the language includes both a set of XML tags and a set of JavaScript APIs.</p>

<p>The LZX language was designed to use familiar syntaxes and naming conventions so that experienced web developers would find it easy to learn and to incorporate into their programming environments. At the same time LZX introduces new concepts and capabilities that make possible more fluid and responsive user interfaces to web applications than are possible with any other technology.</p>

<p>A running LZX program takes place on a visual object called a canvas, which is basically a bit of screen real estate. On the canvas, autonomous boxes called views interact. These views may be nested logically and visually, and have dozens of programmable attributes, including size, position, background color, opacity, clickability, stretchability, and so forth. Views may be used to contain resources, such as, for example, an image or a video, and may also be dynamically bound to any set of XML-formatted data. The attributes of any view can be set to be a function of the attributes of any other view or views, and virtually any attribute of a view can be animated &#x2014; that is, set to vary over time.</p>

<p>The LZX view system is similar to other view systems in many ways, but its implementations of data binding, attribute-constraints, and animation distinguish it from other 
UI technologies.</p>

<p>LZX programs typically contain both declarative and procedural structures, and the language follows many naming conventions
 from CSS (Cascading Style Sheets). Programs written in LZX thus appear similar, on casual inspection, to DHTML applications 
with embedded JavaScript. LZX programs are conceptually different, however, from typical DHTML/JavaScript applications that are 
interpreted and rendered, or "executed," by the web browser. LZX programs, in contrast, are compiled on the server and 
downloaded as byte code for a target rendering engine.</p>

<p>In the current implementation or the Laszlo platform, LZX programs are compiled in the OpenLaszlo Server and downloaded as 
Flash movies (.swf files) and executed in the Flash Player plugged into an Internet browser. It's important to understand, 
however, that the Flash Player is used only as an execution/rendering engine for the generated byte code, and there's 
nothing inherent in LZX that marries it to Flash. In particular, LZX does not employ or rely upon the Flash object model.</p>

<p>Similarly, because LZX programs are compiled by the OpenLaszlo Server the use of JavaScript in LZX programs is subtly 
different from its use in traditional web applications in which JavaScript is used to do things like communicate with the browser 
or generate HTML pages. Those functions are basically irrelevant in LZX applications. Thus although the language design is 
rather traditional, the programming paradigm is fundamentally new.</p>

<p>This chapter summarizes the traditional and innovative aspects of LZX. It's an overview, not a tutorial; after reading it you will be better able to decide how to go about learning the language. Depending on your background and experience, you may determine that you need to go learn some more about XML or object oriented programming before addressing LZX. On the other hand if you find these concepts accessible you may want to jump right in and begin coding, in which case we suggest starting with the <a href="${tutorials}laszlo_basics.html">Laszlo Basics</a> tutorial.</p>

<h2>Overview of Syntax and Semantics</h2>

<p>In LZX, XML tags are used to create JavaScript objects, and Javascript is used inside of LZX programs to
 manipulate objects created by tags. In most cases, anything that can be done with a tag can be accomplished in 
JavaScript, and vice versa. However, this equivalence is not universally true, and moreover one technique is 
virtually always vastly superior to another in any situation. <em>Learning</em> LZX basically comes down to 
learning the tags and APIs; <em>mastering</em> the language requires a developing subtle understanding of how 
the procedural and declarative approaches differ, and learning how and when to use each.</p>

<p>LZX strictly adheres to XML and JavaScript syntax</p>
<note>
In earlier releases, LZX did not enforce case sensitivity in JavaScript. With OpenLaszlo release 3.0 LZX is a completely 
case sensitive language. See below for a more in depth discussion.
</note>

<p>The following sections offer a brief refresher on the two kinds of
LZX syntax. See below for a discussion of how JavaScript and XML
syntaxes play together in typical LZX programs.</p>

<h3>XML</h3>

<p>XML, the eXtensible Markup Language, is a W3C standard for encoding
data. You will need a general familiarity with XML concepts in order
to write programs in the LZX language for two reasons: in the first
place, most of the functionality of LZX is implemented in an XML tag
set. LZX programs themselves are valid XML documents; LZX programs
that are not valid XML simply will not compile. Secondly, LZX programs
only operate on data encapsulated in XML.</p>

<p>If you understand how tags and attributes are represented in XML, are comfortable with the concepts of roots and nodes, and know how nesting works you probably know enough to get started with LZX. For more information and links to any number of online books and tutorials about XML, visit the <a href="http://www.w3.org/XML/">W3C web site</a>.</p>
<p>Another distinction between XML and JavaScript is that in XML the type names are lowercase ("string", "number"), while in JavaScript they're  should say capitalized, e.g. "String", "Number".  The XML type names are used in &lt;attribute name="foo" type="string"/&gt;; they're lowercase for compatibility with the XML Schema Description datatypes.
</p>
<h4>XML and HTML</h4>
<p>
If you have experience with HTML but not XML, you'll find many similarities. Here's some notes on how XML differs from the HTML, for people who are only familiar with HTML.  These apply to all XML; they may particularly catch people up with respect to text markup, which uses tags (&lt;p&gt;, &lt;i&gt;, &lt;br&gt;) with the same names and meanings as HTML tags:</p>
<ul>
	<li>- Case matters.  &lt;b&gt; is different from &lt;B&gt;.  (&lt;b&gt; exists in LZX as a tag for marking up bold text in a &lt;text&gt; element.  &lt;B&gt; does not exist.)</li>
	<li>- Attribute values must be quotes, by " or '.  &lt;view width=100&gt; is invalid XML; use &lt;view width='100'&gt; or &lt;view width="100"&gt; instead.</li>
	<li>- Empty elements must be closed.  &lt;br&gt; is valid HTML; in XML use &lt;br&gt;&lt;/br&gt; or &lt;br/&gt; instead.</li>
</ul>


<h4>Namespaces</h4>
<p>
Laszlo applications can be written with a namespace:</p>
<pre>
  &lt;canvas xlmns="http://www.laszlosystems.com/2003/05/lzx"&gt;...&lt;/canvas&gt;
</pre>
<p>
or without:</p>
<pre>
  &lt;canvas&gt;...&lt;/canvas&gt;
</pre>
<p>
If there is no namespace, the compiler defaults it to the LZX namespace (<a href="http://www.laszlosystems.com/2003/05/lzx">http://www.laszlosystems.com/2003/05/lzx"</a>).
</p>
<h3><a name="javascript">JavaScript</a></h3>

<p>JavaScript is a language originally written at Netscape by Brendan Eich for incorporation in the Netscape 2.0 browser. It was instantly successful and widely adopted in other browsers, and to preserve its emerging value as a standard, the European Computer Manufacturer's Association (ECMA) codified the language as ECMAScript and now maintains control of its evolution. Although there may be subtle differences between any implementation of JavaScript and the language formally specified by the standards body, in colloquial usage the terms JavaScript and ECMAScript are often used interchangeably. While perhaps a little more accurate to say that "ECMAScript" refers to the pure language while "JavaScript" means both the language and the associated libraries that are available on most browsers, in this book we follow general usage and use the terms loosely, trusting that it will be clear from the context what we're talking about. The term "script" refers to any (procedural) code written in Javascript.</p>

<p>LZX incorporates a partial implementation of the <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262 Edition 3 specification</a>.</p>

<p>In order to write reasonable LZX code you will need to be comfortable with these aspects of JavaScript:</p>
<ul>
<li> basic control structures (<code>for</code>, <code>while</code>,
etc.);</li>
<li> the object model;</li>
<li> "loose" data typing;</li>
<li> scoping, that is, the range of namespaces within a program.</li>
</ul>

<p>Depending on your background, you may find certain aspects of LZX familiar or foreign. For example, if you have experience with Java but not JavaScript, you will need to be aware of key differences in the languages, in particular with regard to data typing, the object model, and the scope or namespace of variables.</p>

<p>Like other so-called scripting languages such as Perl and Python, Javascript is a loosely-typed language &#x2014; you can declare a variable without specifying its type. This makes for rapid prototyping and arguably more readable code, but it also makes it possible for data-type errors to go undetected.</p>

<p>JavaScript's approach to object-oriented programming lacks the rigor or Java's. There are no packages or interfaces, for example, nor is it possible to finalize classes. Finally, the behavior of local and global variables in JavaScript is sometimes surprising to Java programmers.</p>

<p>Conversely if you are an experienced JavaScript programmer you may have to "unlearn" certain assumptions, in particular with regard to the availability of certain libraries and functions, and also with regard to case sensitivity. Moreover, LZX has a more complete object oriented programming model than does simple JavaScript. That is, LZX has classes and inheritance.</p>

<p>If you have experience with neither Java nor JavaScript you may want to first work through a JavaScript tutorial like the ones available at <a href="http://www.w3schools.com/js/default.asp">w3schools.com</a> before delving too deeply into LZX.</p> 

<h3>The "dot" syntax</h3> 

<p>LZX employs the "dot" (period) syntax to indicate relationships between objects and their members. Consider the expression</p> 

<p><code>this.that</code></p>

<p>When read as JavaScript, <code>this</code> refers to an object, and <code>that</code> refers to a property of that object, where a property might be, say, a method. Now consider the following LZX code fragment:</p> 

<code>
&lt;view name="beatles"&gt; 
  &lt;view name="george"/&gt; 
&lt;/view&gt;
</code>  

<p>in this case it may sometimes be convenient to refer to the interior view, "george" as</p> 

<p><code>beatles.george</code></p> 

<p>which case <varname>george</varname> is a "child" of <varname>beatles</varname> .</p> 

<p>As will be discussed further below, LZX affords various was to define attributes of, and methods on, objects or classes. For example, the following code samples (which create a view named <varname>myview</varname> and set its background color to red) are equivalent:</p> 

<p>JavaScript:</p> 

<pre>myview = new LzView;</pre> 

<pre>myview.setAttribute (bgcolor, red);</pre>

<p>XML tag:</p> 

<pre>&lt;view name="myview" bgcolor="red"/&gt;</pre>

<p>and in both cases the background color of <code>myview</code> could be accessed by subsequent code as <code>myview.bgcolor</code> . The "dot" convention thus provides a convenient way of referring to objects regardless of how they came into existence &#x2014; that is, whether by declarative tag or procedural code.</p> 
<h3>Case Sensitivity</h3>
<p>
The case-sensitivity of LZX depends on the target for which you're compiling.  As of release 3.1 you may compile for swf6, swf7, or swf8 output. 
Applications compiled for swf6 are not case-sensitive.  You cannot use case alone to distinguish identifiers.  For example, if you name a local variable <tt>date</tt>, for example, you will not be able to call the JavaScript<tt> Date</tt> constructor as in <tt>new Date()</tt>.
</p>
<p>
The swf7 target is the default; applications compiled for swf7 and swf8 are entirely case-sensitive.  This means that whenever you use a variable it must be in the case in which it was defined.</p>
<p>
Applications that work in swf6 may not work in swf7, and vice versa, for these reasons.</p>

<p>Regardless of the target, having variables that differ only in case is, depending on the target, at best confusing. Therefore it's good practice to avoid using names that are spelled the same but differ only in capitalization.</p>

<h3>The LZX DTD and Schema</h3> 

<p>An XML schema defines the LZX tag set and can be used to configure an editor. The DTD is also available for the curious, although there is no need for you to be aware of it for programming purposes.</p>

<p>The LZX schema is used by the OpenLaszlo Compiler to ensure
that LZX programs are formally correct. For example, the schema
specifies what attributes can be included in an opening
<tagname>view</tagname> tag. If your program contains a
<tagname>view</tagname> tag that includes an attribute not defined by
the schema, it will compile with a warning.</p>

<p>LZX allows you to define your own tags. User defined tags do not
get incorporated into the schema that is available to your editor,
although they are used in the internal schema that the compiler uses
to test that program's validity.</p>


<!--  later chapters will explain implications of this fact for debugging your programs.
-->

<h2><a name="objects-and-attributes"/>Objects and Attributes</h2> 


<p>LZX incorporates the standard object-oriented programming concepts of inheritance, encapsulation, and polymorphism. In general, a tag in a Laszlo program corresponds to an object that is an instance of the class of that name. For example, the <tagname>view</tagname> tag corresponds to an <classname>LzView</classname> object.</p> 

<p>To a first approximation, then, LZX can be described as a rule-based declarative language for manipulating visual (JavaScript) objects called views, where rules are expressed as constraints on the values of the attributes of those objects.</p> 

<p>The following paragraphs summarize some of the key object-oriented aspects of the LZX language. These ideas are examined at greater length elsewhere in this Guide, particularly in <xref linkend="class-inheritance">Chapter 21, "Extending LZX Classes</xref>.</p>

<h3>Objects</h3> 

<p>An object is a data type that contains named pieces of data. Depending on context, a named datum might be called a <em>property</em> or an <em>attribute</em> of that object. For example, each <code>view</code> object has 49 attributes, such as height, width, horizontal position, vertical position, and so forth. Values are generally assigned to the attributes of objects when the objects are created; attributes that you do not specifically set are assigned default values.</p> 

<p>You can create new kinds of LZX objects by using the <tagname>class</tagname> tag. Each new class you create must be given a name and the name of a class that it's "extending." The newly created objects inherit all the properties of the class you extended, plus any additional properties you may define. For example consider the trivial case</p> 

<pre>&lt;class name="myview" extends="view"/&gt;</pre>

<p>In this case you have defined a new kind of object called a <varname>myview</varname> that has all the properties of a <code>view</code>. <xref linkend="initialization-and-instantiation">Later chapters</xref> discusses in depth when and how objects are defined in your code and built by the compiler and runtime.</p> 

<h3>Attributes</h3> 

<p>In LZX, the word "attribute" has two related but subtly different meanings, one syntactical and one semantic. In the XML, syntactical, sense, an attribute is a named value associated with an XML element and specified in that element's opening tag. Thus in the XML tag</p> 

<pre>&lt;boss demeanor="friendly"/&gt;</pre>

<p><attribute>demeanor</attribute> is an attribute of the tag <code>boss</code> . This meaning of "attribute" applies whenever the context is XML structure. Note that the value assigned to an attribute is enclosed in double quotation marks.</p> 

<p>Because LZX tags correspond to JavaScript classes, "attribute" takes on the additional semantic weight of property of a JavaScript object. Thus the LZX tag</p> 

<pre>&lt;view height="20" width="30"/&gt;</pre>

<p>causes the creation of a view object with the specified values for the attributes <attribute>height</attribute> and <attribute>width</attribute>.</p> 

<p>The <tagname>attribute</tagname> tag can be used to set JavaScript attributes of objects. For example,</p> 

<pre> 
&lt;view name="myview"&gt; 
  &lt;attribute height="20"/&gt; 
  &lt;attribute width="30"/&gt; 
&lt;/view&gt;  
</pre>

<p>is equivalent, in LZX, to the earlier one-line version. Thus <attribute>height</attribute> is an attribute of the view, in the semantic sense, even though it is not in the XML sense of being contained in the opening tag. <attribute>height</attribute> is also an attribute, in the XML sense, of the first <tagname>attribute</tagname> tag. Its value can be referenced by script as <code>myview.height</code>.</p> 

<p>You also use the <tagname>attribute</tagname> tag to define new attributes for classes you create. For example</p> 

<example executable="false">
&lt;class name="froboz" extends="view"&gt; 
  &lt;attribute name="whatnot" value="17"&gt; 
&lt;/class&gt;
</example>

<p>Defines a new kind of view object, <code>froboz</code>, that has fifty attributes: the 49 that it has inherited from view, plus the new attribute named <attribute>whatnot</attribute>.</p> 

<p>We have seen that attributes can be set, that is, assigned values, in LZX tags. It is also possible to set attribute values in script using the <method>setAttribute</method> method. Additionally, values of attributes can be read, or "gotten" in script (but not in tags) using the <method>getAttribute</method> method. (Methods will be explained below).</p> 

<p>Assume the existence of a view named <varname>johnny</varname>. This view may have been created by a tag or in script; how the view came into existence does not matter.</p> 

<p>The JavaScript code to set the height of this view to 100 pixels would be:</p> 
<p><code>johnny.setAttribute("height", 100);</code></p> 

<p>and to read the value the height would be</p> 

<p><code>johnny.getAttribute("height");</code></p> 

<p>Every time that an attribute is set, that is, every time the value of an attribute changes, an object called an <code>event</code> is generated. The next section discusses what events are, and how they work in running LZX programs.</p> 

<h2>Events and Methods</h2> 

<h3>Events</h3> 

<p>Events are the mechanism by which objects communicate with each other when something changes. For example, an event might be generated when a mouse button is clicked, or when data arrives from a server, or when a view has been constructed.</p> 

<p>In LZX programs, events are not broadcast, but rather they are communicated in a point-to-point fashion using <code>delegates</code>, which are basically function pointers that are referenced when events happen. This implementation increases flexibility and reduces the overhead of using events. However, for the purposes of the discussion in this chapter we're going to ignore delegates and speak of events in a slightly less rigorous manner, saying, for example when such-and-such an event <em>occurs</em>, thus and such <em>happens,</em> leaving aside for now an explanation of <em>how</em> it happens.</p> 

<p>Views have approximately two dozen defined events, as listed 
on the entry for <tagname link="true">view</tagname> in the LZX Reference Manual. Many of these
events that deal with user input, such as <event>onblur</event>,
<event>onclick</event>, <event>onkeydown</event>, will be familiar to
JavaScript programmers. Other events, such as <event>onheight</event>
and <event>onopacity</event>, pertain to views' visible
attributes. Finally, the <event>oninit</event> and
<event>onconstruct</event> events are related to the creation of the
instances of view objects. Similarly, other system-defined LZX objects
such as Datasets (see below) have events associated with them.</p>

<p>Events and attributes often work as pairs, and in fact, the default
behavior of the setAttribute method is to set the named property and
send the event called "<code>on</code>" + property. For instance, when a
view changes its <attribute>x</attribute> (horizontal) position, it
sends the event <event>onx</event> with the new value for its
<attribute>x</attribute> property. This means that in addition to
system-defined events, there exists an event for each attribute you
define.</p>

<p>When an event happens, control is transferred to its associated event-handler (if one is defined). Events can be sent with a single argument, which usually conveys information about the property that changed.</p> 

<p>Elsewhere in this Guide we discuss how events are implemented in
LZX, and how the event architecture bears upon program design. In
particular, <xref linkend="delegates"/> discusses the
relationship between events and delegates.</p>

<h3>Methods</h3> 

<p>In LZX, a method is a JavaScript function associated with a particular object.</p>

<p>IFunctions are invoked using the <code>()</code>
operator. Thus,</p>

<pre>
&lt;view name="dog"&gt;   
  &lt;method name="bark"&gt; 
    &lt;!-- some JavaScript code ---&gt; 
  &lt;/method&gt; 
&lt;/view&gt;
</pre>

<p>Defines a function that is executed when invoked by name, as in</p>

<p><code>dog.bark();</code></p> 

<p>In JavaScript, the <code>this</code> keyword is used to refers to the object though which the function was invoked. </p>
<h3>Handlers</h3>
<p>
A handler is like a method. But whereas a method is invoked by its name, a hander msut be associated with a particular event. The handler
script will be executed when the referenced view receives an event
with this name. For example,</p>

<pre>
&lt;view&gt; 
  &lt;handler name="onclick"&gt; 
    &lt;!-- some JavaScript code ---&gt; 
  &lt;/handler&gt; 
&lt;/view&gt;
</pre>

<p>defines a function that is executed when the view is clicked on. 
Consider</p> 

<pre> 
&lt;view&gt; 
  &lt;method name="bark"&gt; 
    &lt;!-- some JavaScript code ---&gt; 
  &lt;/method&gt; 
  &lt;handler name="onclick"&gt; 
    this.bark()  
  &lt;/handler &gt; 
&lt;view&gt;
</pre>  

<p>When the view is clicked on, the <event>onclick</event> event causes the execution of the <method>handler</method> which in turn invokes the method named <method>bark</method>.  Event handlers are often identified in an opening tag, as in</p> 

<pre>
&lt;view onclick="clickHandler()"&gt; 
  &lt;method name="clickHandler"&gt; 
    &lt;!-- some JavaScript code --&gt; 
  &lt;/method&gt; 
&lt;/view&gt; 
</pre>

<p>There are three general categories of methods and handler:</p> 
<ul> 
<li>   "On init" methods that are invoked when their parent object is created;</li> 
<li>   handlers that are invoked when their parent object receives a specified event;</li> 
<li>   named methods that are explicitly invoked by other methods.</li> 
</ul>

<p>Note that you can define a method using conventional Javascript syntax, but in LZX the preferred way to declare a method is with the <tagname>method</tagname> tag.</p> 

<p>Also note that in LZX, unlike many other object oriented systems,
you can override a method in an instance of an object. This topic is
covered in <xref linkend="class-inheritance">
extending LZX classes</xref>.</p>

<h2>Constraints</h2> 

<!-- There's a copy of this next section in constraints.  Change that if you change this. -->

<p>In LZX, a constraint is an attribute whose value is a function of other attribute values.  The syntax for coding a constraint is</p> 

<pre>$<i>when</i>{<i>expression</i>}</pre>

<p>where:</p>
<ul>
  <li><code>$</code> is the token indicating a constraint</li>
  
  <li><code><i>when</i></code> is an optional compiler directive: <code>immediately</code>, <code>once</code>, or <code>always</code>.  <code>$always{<i>expression</i>}</code> can be abbreviated to <code>${<i>expression</i>}</code> </li> 
  
  <li><code>{</code> and <code>}</code> are tokens delimiting the
  expression to be evaluated</li>
  
  <li><code><i>expression</i></code> is a JavaScript expression</li>
</ul>

<p>As we have seen above, whenever the value of an attribute
changes, its <event>on</event> event is generated. Because a
constraint is an attribute whose value is dependent upon the values of
one or more other attribute(s), the value of the constraint is
recalculated whenever it receives the <event>on</event> event for the
attributes on which it depends.</p>

<p>Consider</p> 

<pre>
&lt;view name="someView" 
      width="${someAttribute + someOtherAttribute}" 
 /&gt;
</pre>

<p>The value of <code>someView.width</code> is recomputed whenever an <code>onsomeAttribute</code> or <code>onsomeOtherAttribute</code> event occurred.</p> 

<p>So for example</p> 

<pre>
&lt;view name="beatles" width="${this.paul.width + 28}"&gt; 
  &lt;view name="paul" onclick="clickhandler()" &gt; 
    &lt;!-- clickhandler method here to increase paul's width based on user clicking mouse --&gt; 
  &lt;/view&gt; 
&lt;/view&gt;
</pre>

<p>The width of <code>beatles</code> will increase or decrease as a function of <code>paul</code>'s width; the expression <code>this.paul.width + 28</code> is a constraint.</p> 

<p>This, of course is a trivial example, but it serves to make the
point that in declaring the structure of your objects in LZX you also
declare the rules by which they will relate to each other. Constraints
are a fundamental concept in LZX programming, and learning to
"think in LZX" is a mostly a matter of learning to properly
model your system's behavior in terms of the constraints on its
constituent parts. <xref linkend="constraints">Chapter
7</xref> covers constraints in depth.</p>

<h3>Lexical and View Hierarchies</h3> 

<p>An LZX application is expressed as a hierarchy of objects, usually visual objects, all of which are contained in a single object called the Canvas. Recall that LZX programs are XML documents, the Canvas is the root element. The simplest LZX program is thus:</p> 

<pre>&lt;canvas/&gt;</pre>

<p>This program compiles and executes, but has no output. As the simplest visual object is the View, a minimal LZX program would look something like:</p> 

<pre>
&lt;canvas&gt;
  &lt;view&gt;
    &lt;text&gt; Hello World!&lt;/text&gt; 
  &lt;/view&gt; 
&lt;/canvas&gt;
</pre>

<p>This code clearly defines a hierarchy of three objects. We can make their visual relationship more visible by giving the canvas and view sizes and background colors:</p> 

<p>In this simple case, the lexical hierarchy in the code corresponds to the visual hierarchy in the canvas. In fact, a <code>&lt;text&gt;</code> object is an instance of a class derived from <code>&lt;view&gt;</code> . The typical LZX program repeats this pattern on a larger scale: the canvas contains views which contain other views, and so forth. Classes are used to replicate view groupings; components such as buttons, windows, input fields and sliders are examples of classes built from views.</p> 

<p>LZX affords a variety of ways to simplify the relationships among views. For example, there are several categories of layouts that handle the "housekeeping" of placing views in relationship to each other. These are described in <xref linkend="layout-and-design"/>.</p> 

<p>However, the relationship between the textual hierarchy in the code and the visual hierarchy on the canvas is not always as neat as in the example above. In particular, LZX's powerful data binding semantics make it possible for a single <code>&lt;view&gt;</code> tag in the text to cause the creation of an arbitrary number of instances of <code>view</code> objects. In such cases it becomes very important to have a precise way of talking about complex relationships among objects. <xref linkend="views">Chapter 4, View Basics,</xref> covers this topic in depth.</p> 

<h3>Lexical Scope</h3> 

<p>In LZX the concepts of local and global namespaces, or scopes, are basically the same as in JavaScript. Having said that, it should be pointed out that JavaScript follows rules that are sometimes surprising to Java Programmers.</p> 

<p>In JavaScript, all variables are global unless they are preceded by the keyword <code>var</code>.</p>

<p>Thus</p> 

<pre>a= 7; // defines a global variable a</pre>

<p>and</p> 

<pre>var a = 7 // defines a local variable a</pre>

<p>This syntax means, for example, that an assignment in a method definition can set an instance of global variable:</p> 

<pre>for (a = 0; a &lt;n; a++);</pre>
 
<p>Creates a global variable named <varname>a</varname>, or changes the value of this variable if it already exists. What the programmer meant to write was</p> 

<pre>for (var a = 0; a &lt;n; a++);</pre>

<p>In LZX, the <attribute>name</attribute> attribute is local and the <attribute>id</attribute> attribute is global. Thus</p> 

<example executable="false">
&lt;canvas&gt; 
  &lt;view name="john" id="grandfather"&gt; 
    &lt;view name="john" id="father"&gt; 
      &lt;view name="john" id="son"/&gt; 
    &lt;/view&gt; 
  &lt;/view&gt; 
&lt;/canvas&gt;
</example>

<p>is a valid name scheme. The innermost view can be referenced by
<code>Canvas.john.john.john</code> or simply <code>son</code>.</p>

<p>As will be discussed below, functions created using the
<tagname>script</tagname> tag can be accessed from anywhere in the
program.</p>

<h2>Data Access, Manipulation, and Binding</h2> 

<p>LZX is designed to make it easy to write data-driven applications in which the values of data sources define the appearance and actions of the program. It does this through tags and APIs that allow you to get access to data over http, manipulate XML data in memory, and, significantly, bind the data hierarchy to the view hierarchy.</p> 

<p>The following paragraphs summarize these key features of the LZX data-handling architecture. <xref linkend="data">Chapter 9, Working with Data,</xref> discusses this subject in depth.</p> 

<h3>Data Access</h3> 

<p>LZX programs manipulate XML-formatted data, which may be</p> 
<ul> 
<li>   embedded in the program text, </li> 
<li>   read in from a source when the program is compiled, or</li> 
<li>   read in from a source when the program is running.</li> 
</ul> 

<p>XML sources are stored as objects called datasets. The <tagname>dataset</tagname> tag has attributes that allow you to, for example, control caching on the client and server, include or exclude http headers, queue requests, and so forth. Objects created by <tagname>dataset</tagname> are called LzDatasets. Methods on LzDatasets allow you to, for example, get and set query strings, parameters and so forth.</p> 

<h3>   Data Manipulation</h3> 

<p>LZX employs datapointers, which are objects that represent pointers to nodes in datasets, to locate and manipulate content. Datapointers support a subset of XPath, which is a W3C standard specification for identifying paths of an XML document, or in the case of LZX, datasets. XPath uses a notation similar to the UNIX file-system to refer to nodes within a dataset. Datapointers can be repositioned using both procedural calls such as <method>selectNext</method> and by running an XPath request using <method>setXPath</method>.</p> 

<p>Because it incorporates sophisticated pattern matching, XPath notation is extremely concise and powerful. A single XPath expression can represent an arbitrarily large number of XML elements. Using methods such as <method>addNode</method>, <method>setNodeName</method>, <method>setXpath</method>, and <method>selectParent</method>, you can build and manipulate XML structures.</p> 

<h3>Data Binding</h3> 

<p>LZX provides a unique way of merging any arbitrarily shaped data hierarchy with any display hierarchy; this capability is called data binding. It is implemented in such a way that the data context of a child in the display hierarchy is implicitly the data context of its parent. Moreover, it is possible to instruct the system to create an arbitrary bit of view hierarchy to represent each element in a set of selected data.</p> 

<p>The way this is done is by binding views to datapointers. A <code>datapath</code> is a special case of datapointer that explicitly marries the data hierarchy to the view hierarchy, as in, for example:</p> 

<pre>&lt;view name="bob" datapath="testdata:/*"&gt;</pre>

<p>where <varname>testdata</varname> refers to a dataset defined earlier in the program.</p> 

<p>If this sounds a little abstract, well, it is. Therefore we'll keep the discussion short here and defer longer explanations to <xref linkend="data"/>; you may also want to examine some of the examples on <a href="http://www.laszlosystems.com/demos">http://www.laszlosystems.com/demos</a> to get a feel for what can be done when applications are truly data-driven.</p> 

<p>The key thing to understand is that while other languages and technologies have implemented merge algorithms that may appear similar on the surface, LZX's data binding is novel in the creation of program objects that retain a live connection with the entities of the data source.</p> 

<h2>Combining Tags and Script in LZX Programs</h2> 

<p>As mentioned earlier, virtually all nontrivial LZX programs contain both (XML) tags and script. Tags are used declaratively, that is, to define objects and their attributes. Script is used procedurally, that is, to explicitly define series of steps. Although the two kinds of code are liberally intermixed within LZX &#x2014; for example, script can appear within tags &#x2014; each syntax locally maintains its integrity.</p> 

<p>So for example, within declarative LZX code, comments are denoted</p> 
<pre>&lt;!-- XML comment --&gt;</pre>
<p>while within JavaScript, comments are denoted</p> 
<pre>// JavaScript comment</pre>
<p>Thus LZX is similar to an alloy of two metals that do not chemically combine.</p> 

<p>Because the declarative and procedural portions of a program can be so intertwined, it can be a little tricky, at first, to recognize them within a program. However, once you gain a little experience and begin to grasp the underlying logic of LZX you will find that you hardly notice the alternating syntaxes. The following paragraphs explain how and why to employ the two "flavors" of LZX. Consult the documentation for your IDE or text editor to learn how to use the LZX DTD or schema to give visual cues that indicate what portions of the program are in each syntax.</p> 

<h3>How to Combine Tags and Script</h3> 

<p>Let's start by making a distinction between what is syntactically allowable and what is meaningful.</p> 

<h4>What's Allowable</h4> 

<p>Remember that all LZX programs are well-formed XML files. That means that all portions of the program, including embedded JavaScript, must conform to XML rules. Therefore where JavaScript uses characters that are meaningful to XML, such as the left angle bracket &lt;, you must make sure that those characters don't confuse the XML parser. You can do that in either of two ways:</p> 

<ul>
  <li>by explicitly <dfn>escaping</dfn> delimiter characters with an
  <dfn>entity reference</dfn>. (The entity reference for the left
  angle bracket is <code>&amp;lt;</code>).</li>
  <li>by using the XML <code>CDATA</code> construct to define a block
  of <dfn>character data</dfn>.</li>
</ul> 

<p>This is the sum total of rules for making sure that XML does not trip on JavaScript.</p> 

<h4>What's Meaningful</h4> 

<p>Although the admixture of two different sets of language rules in one language does create opportunities for confusion, it's fairly easy to recognize how LZX programs are structured, and what kind of code goes where. There are only a few contexts in which script code can appear in LZX programs. After you learn to recognize these contexts you are unlikely to be confused about what syntax applies. Javascript is used:</p> 
<ul> 
<li>between an opening and closing <code>&lt;script&gt;</code> and <code>&lt;/script&gt;</code> tag;</li>
<li>between an opening and closing <code>&lt;method&gt;</code> and <code>&lt;/method&gt;</code> tag;</li>
<li>with the double-quoted right hand value of an assignment statement within certain tags, such as <code>oninit="<i>script expression</i>"</code> .</li> 
</ul>



<h3>When to Use Tags and When to Use Script</h3> 

<p>As we said earlier, most things that you can do in LZX can be done either with XML tags or JavaScript APIs, and mastering LZX requires a developing subtle understanding of how and when to use each. You will find, in general, that tags are best for computations that can be done at compile-time &#x2014; such as laying out the canvas &#x2014; and script is best for run-time things, such as responding to user input. But in order for you to make any use of that information you need to understand what is done at compile time and what is done at run time, and much of that is under your control, and dependant on the problem you're trying to solve.</p> 

<p>In other words, there is no simple set of unambiguous rules that tell you when to use tags versus when to use script. But there are, however, design patterns common to all well-made LZX programs.</p> 

<p>Remember, LZX is primarily a language for manipulating visual objects called views. So the question of when to use tags versus script is usually asked in the context of the <em>creation of views and manipulation of their attributes</em>. Script can be used for other things, such as global functions, but in those instances the need to write procedural code (i.e., script) is usually clear-cut. The finesse part has to do with manipulating views and their attributes.</p> 

<p>For example, a simple two-word constraint might express a relationship between views that would require thirty lines of code to express. Most of the time the constraint is the better programming solution. But not always.</p> 

<p>Although there are no absolutes, there are some general principles that inform the philosophy of development in LZX:</p> 
<ul> 
<li>   Use tags when that is the only option.</li> 
<li>   Use JavaScript when that is the only option.</li> 
<li>   If something can be done with either tags or script, use tags (unless there is a good reason not to).</li> 
</ul>

<p>Each of these principles is described briefly below.</p>

<todo>Please see
also Using the LZX Reference Manual in <fixme>FIXME</fixme> for an
explanation of how to use that document to learn what your options in
any instance.</todo>

<h4>Use tags when that is the only option</h4> 

<p>There are certain tags that perform functions that cannot be done using script. For example, the root node (and enclosing tag) of every LZX program is <tagname>canvas</tagname>. Every LZX program begins with <code>&lt;canvas&gt;</code> and ends with <code>&lt;/canvas&gt;</code>; there is no alternative structure using script. Similarly there are no script equivalents for <tagname>splash</tagname>, <tagname>method</tagname>, <tagname>attribute</tagname>, <tagname>resource</tagname>, <tagname>font</tagname>, and several other tags. Moreover, within certain tag definitions there are certain attributes that can only be set in the tag.</p> 

<h4>Use JavaScript when that is the only option.</h4> 

<p>There are several JavaScript APIs that perform functions that cannot be done using tags. For example, <code>LzDelegate, LzEvent, LzParam</code> and similar APIs perform operations that cannot be done using tags. Similarly, there are certain attributes of objects that can only be referenced by script, even for objects that were created with tags. For example, consider</p> 

<p><code>&lt;view name="franklin"&gt;</code></p> 

<p>There is an attribute, <code>franklin.subviews,</code> that can be accessed by script; it is not possible to set or access that attribute in a tag.</p> 

<h4>If something can be done with either tags or script, use tags.</h4> 

<p>In the large number of cases where it is possible to do something using either tags or views, it is generally better to use tags. For example you can create a new view called "sam" using tags</p> 

<p><code>&lt;view name="sam"&gt;</code></p> 
<p>or script</p> 
<p><code>sam = new LzView();</code></p> 

<p>When you use the tag syntax you can quite naturally create hierarchies of nested subviews, define attributes as constraints, and lay out your code in a way that helps you conceptualize the placement of views on the canvas. Achieving any of these results in pure JavaScript would be a colossal pain and negate much of the benefit of the language. Learning to think in LZX means learning to think in terms of views that act nearly autonomously according to the constraints you establish at their creation.</p> 

<h4>Unless there is a good reason not to.</h4> 

<p>Sometimes it's better to write procedural code instead of declarative code. This may become necessary, for example, to achieve optimal performance: multiply-constrained systems can sometimes become CPU bound. Other times procedural code may make your program's behavior easier to understand: complex rule-based view systems sometimes become inscrutable.</p> 

<fixme>Appendix _____ contains a schematic overview of what functions can be done by tag alone, script alone, or by both.</fixme>

<h2>Compilation and Execution</h2> 
<p>LZX programs are compiled by the OpenLaszlo Compiler, downloaded as byte code, and executed on the client.  In writing your program you can make trade-offs between compilation performance, download and startup up time, and runtime performance.</p> 

<p>As in other scripting languages such as Perl and Python, LZX programs execute in approximately linear order. That is to say, if you were to write</p> 

<pre>
&lt;view name="outside"&gt; 
  &lt;view name="inside"/&gt; 
&lt;/view&gt;
</pre>

<p>Then <varname>inside</varname> would be built before
<varname>outside</varname>. However in many cases you may wish to
control the order in which objects are built, or initialized. LZX
gives you fine grained control over initialization and instantiation
of views.</p>

<p>The <tagname>splash</tagname> tag allows you use the canvas to
display information while the program is being initialized.</p>

<!-- 
<h2>   Schematic of LZX API Categories</h2></p></p>
-->
</body>
</html>
<!-- * X_LZ_COPYRIGHT_BEGIN ***************************************************
* Copyright 2001-2006 Laszlo Systems, Inc.  All Rights Reserved.              *
* Use is subject to license terms.                                            *
* X_LZ_COPYRIGHT_END ****************************************************** -->
