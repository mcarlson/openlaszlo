<!-- * X_LZ_COPYRIGHT_BEGIN ***************************************************
* Copyright 2001-2006 Laszlo Systems, Inc.  All Rights Reserved.              *
* Use is subject to license terms.                                            *
* X_LZ_COPYRIGHT_END ****************************************************** -->
<!-- @LZX_VERSION@                                                          -->
<library>

    <!-- loads one month of data at a time; source is set by dataloader below-->
    <datasource name="http">
        <dataset name="serverdata" ondata="dataloader.run()"/>
    </datasource>

    <!-- The file that holds the settings (locations of scripts, etc) for the app. -->
    <dataset name="calSettings" type="http" src="calsettings.xml" request="true" />
    <datapointer name="cSetDP" xpath="calSettings:/calsettings">
        <method event="ondata">
            calList.setSrc(this.xpathQuery('clist/text()'));
            calList.doRequest();
        </method>
    </datapointer>

    <!-- The location of the conversion script. -->
    <attribute name="convLoc" value="${cSetDP.xpathQuery('convertscript/text()')}" />
    
    <!-- Selected month and year. -->
    <attribute name="selmon" type="number" value="0"/>
    <attribute name="selyear" type="number" value="0000"/>
    
    <!-- This is the blank dataset that we'll use to build up all the iCal data from
        multiple files.  (Doing it this way also keeps us from having to completely
        rewrite the entire app just to get it to work with converted iCal data.) -->
    <dataset name="builddata" />

    <!-- The list of calendars, generated by a PHP scandir of the available
        calendar files. -->
    <dataset name="calList" type="http" request="false" />

    <!-- A pointer to the calendar list to be used for data requests. -->
    <datapointer name="clistDP" xpath="calList:/calendars" ondata="calgrid.finishStartSequence()"/>

    <!-- This is the iCal data, converted to RDF by an external PHP script.
        The source will be set later based on whatever calendars exist in calList. -->
    <dataset name="icalData" type="http" request="false" queuerequests="true" />

    <!-- controls loading of server data; once data has loaded calls
        notifies localdatacontroller -->
    <datapointer name="dataloader" xpath="serverdata:/*" >
        <attribute name="reqq" value="[]"/>
        <attribute name="requestrunning" value="false"/>

        <method name="run">
            this.requestrunning = false;
            localdatacontroller.mergeInsert(this);
            this.doNextRequest();
        </method>

        <!-- keep going if we get an error -->
        <method event="onerror">
            this.requestrunning = false;
            this.doNextRequest();
        </method>

        <method name="loadData" args="mo, yr">
            <![CDATA[
            var calcount = clistDP.getNodeCount();
            for(var i = 1; i <= calcount; i++){
                canvas.setAttribute('selmon', mo);
                canvas.setAttribute('selyear', yr);
                var cal = clistDP.xpathQuery('cal[' + i + ']/text()');
                var convertlocation = canvas.convLoc;
                var cal = convertlocation + '?filename=' + cal;
                icalData.setSrc(cal);
                icalData.doRequest();
            }
            ]]>
        </method>

        <method name="doNextRequest" >
            if(!this.reqq.length) return;
            var nr = this.reqq.shift();
            this.requestrunning = true;
            http.serverdata.setAttribute('src', nr);
            http.serverdata.doRequest();
        </method>

        <method name="enqueueRequest" args="r">
            this.reqq.push(r);
            if(!this.requestrunning){
                this.doNextRequest();
            }
        </method>
    </datapointer>

    <!-- Datapointer to point to the iCal data. -->
    <datapointer name="icalDP" xpath="icalData:/rdf:RDF[1]/Vcalendar[1]">
        <method event="ondata">
            <![CDATA[
            var mo = canvas.selmon - 1;
            var yr = canvas.selyear;
            var lastmon = (mo - 1 < 1 ? 12 : (mo - 1));
            var nextmon = (mo + 1 > 12 ? 1 : (mo + 1));
            buildMonthDP.constructData(lastmon, yr);
            buildMonthDP.constructData(mo, yr);
            buildMonthDP.constructData(nextmon, yr);
            ]]>
        </method>
    </datapointer>
    
    <!-- This datapointer will build all the data for the month in a manner
        palatable to the way data was already handled in the app. -->
    <datapointer name="buildMonthDP" xpath="builddata:/">
        <method event="oninit">
            this.addNode('vcalendar');
            this.setXPath('vcalendar[1]');
        </method>

        <!-- Build the data, when requested. -->
        <method name="constructData" args="mo, yr">
            <![CDATA[
            this.setXPath('builddata:/vcalendar[1]');
            if(this.getNodeName() == 'vcalendar'){
                // If, and only if, we're in the <vcalendar> tag, add/move into the year tag,
                // checking first to make sure we're not creating a duplicate.
                var yearcount = this.getNodeCount();
                if(yearcount != 0){ // If there's something at this level, it's probably a year.
                    var yeardouble = false;
                    for(var i = 1; i <= yearcount; i++){
                        this.setXPath('builddata:/vcalendar[1]/*['+i+']');
                        if(this.getNodeName() == 'year'+yr){
                            yeardouble = true;
                        }
                    }
                    this.setXPath('builddata:/vcalendar[1]');
                    if(yeardouble != true){
                        this.addNode('year'+yr);
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]');
                    } else {
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]');
                    }
                } else {
                    this.addNode('year'+yr);
                    this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]');
                }
            }

            // Get the number of "component" tags in the iCal data.
            var sizeCal = icalDP.getNodeCount('//*');
            var numComponents = 0;
            var countToken = 1;
            while(countToken <= sizeCal){
                if(icalDP.xpathQuery('*[' + countToken + ']/name()') == 'component'){
                    numComponents++;
                }
                countToken++;
            }

            // Now, add the iCal information to the datapointer.
            countToken = 1;
            while(countToken <= numComponents){
                // Cycle through, getting data from icalDP.

                // Figure out the date and month.
                var calDate = icalDP.xpathQuery('component[' + countToken + ']/Vevent/dtstart/dateTime/text()');
                if(calDate != null){
                    var calYear = calDate.slice(0, 4); // Separates the year.
                    var calMonth = calDate.slice(5, 7); // Separates the month.
                    var calDay = calDate.slice(8, 10); // Separates the day.
                }
                if(calYear == yr && calMonth == mo){
                    // If the year and month in the data match the selected year and month, build
                    // the data for the month.
                    this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]');

                    // Add the month tag, unless there's one already there.
                    var monthcount = this.getNodeCount();
                    if(monthcount != 0){
                        var monthdouble = false;
                        for(var i = 1; i <= monthcount; i++){
                            this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/*['+i+']');
                            if(this.getNodeName() == 'month'+mo){
                                monthdouble = true;
                            }
                        }
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]');
                        if(monthdouble != true){
                            this.addNode('month'+mo);
                            this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]');
                        } else {
                            this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]');
                        }
                    } else {
                        this.addNode('month'+mo);
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]');
                    }

                    icalDP.setXPath('component[' + countToken + ']/Vevent');

                    // Get data from our converted iCal file.
                    var calSum = icalDP.xpathQuery('summary/text()');
                    var calLoc = icalDP.xpathQuery('location/text()');
                    var calDesc = icalDP.xpathQuery('description/text()');
                    var calPart = icalDP.xpathQuery('participants/text()');
                    var calUID = icalDP.xpathQuery('uid/text()');
                    var calCategory = icalDP.xpathQuery('/rdf:RDF[1]/Vcalendar[1]/x:wrCalname[1]/text()');

                    // Get more specific starting time info from our calDate variable.
                    if(calDate != null){
                        var calHour = calDate.slice(11, 13);
                        var calMin = calDate.slice(14, 16);
                    }

                    // Get ending time information
                    var calEnd = icalDP.xpathQuery('dtend/dateTime/text()');
                    if(calEnd != null){
                        var calEYear = calEnd.slice(0, 4);
                        var calEMonth = calEnd.slice(5, 7);
                        var calEDay = calEnd.slice(8, 10);
                        var calEHour = calEnd.slice(11, 13);
                        var calEMin = calEnd.slice(14, 16);
                    } else {
                        var calDuration = icalDP.xpathQuery('duration/text()');
                        if(calDuration != null){
                            var calDurHour = calDuration.slice(2);
                            var findH = calDurHour.indexOf('H');
                            var calDurMin = calDurHour.slice((findH + 1));
                            if(calDurMin != ''){
                                var findM = calDurMin.indexOf('M');
                                calDurMin = calDurMin.slice(0, findM);
                            } else {
                                calDurMin = 00;
                            }
                            calDurHour = calDurHour.slice(0, findH);
                            var calEMin = Number(calMin) + Number(calDurMin);
                            var calEHour = Number(calHour) + Number(calDurHour);
                            var calEDay = calDay;
                            var calEMonth = calMonth;
                            var calEYear = calYear;
                            if(calEHour >= 24){
                                calEDay = Number(calEDay) + Number(Math.floor(calEHour / 24));
                                calEHour = (calEHour - (24 * Math.floor(calEHour / 24)));
                            }
                            if(calMonth == 3 && calEDay > 28){
                                if(calYear % 4 != 0){
                                    calEMonth = Number(calEMonth) + 1;
                                    calEDay -= 28;
                                } else {
                                    if(calEDay > 29){
                                        calEMonth = Number(calEMonth) + 1;
                                        calEDay -= 29;
                                    }
                                }
                            }
                            if(calEDay > 31 && (calMonth == 2 || calMonth == 4 || calMonth == 6 || calMonth == 8
                                || calMonth == 9 || calMonth == 11 || calMonth == 13)){
                                calEMonth = Number(calEMonth) + 1;
                                calEDay -= 31;
                            }
                            if(calEDay > 30 && (calMonth == 5 || calMonth == 7 || calMonth == 10 || calMonth == 12)){
                                calEMonth = Number(calEMonth) + 1;
                                calEDay -= 30;
                            }

                            //Debug.write('Starttime: ' + calYear + ' ' + calMonth + ' ' + calDay + ' ' + calHour + ' ' + calMin);
                            //Debug.write('Endtime: ' + calEYear + ' ' + calEMonth + ' ' + calEDay + ' ' + calEHour + ' ' + calEMin);
                        }
                    }
                    
                    // A little fix for iCal's "all day events", so that we don't end up with NaN for the
                    // start and end times.
                    if(calHour == ''){
                        calHour = 01;
                        calEHour = 23;
                        calMin = 00;
                        calEMin = 59;
                    }

                    // Start adding nodes
                    
                    // Check to make sure the day doesn't already exist.  If it does,
                    // just use the existing day.  (Prevents duplicate day tags.)
                    daycount = this.getNodeCount();
                    if(daycount != 0){
                        var daydouble = false;
                        for(var i = 1; i <= daycount; i++){
                            this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]/*['+i+']');
                            if(this.getNodeName() == 'day'+calDay){
                                daydouble = true;
                            }
                        }
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]');
                        if(daydouble != true){
                            this.addNode('day'+calDay);
                            this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]/day'+calDay+'[1]');
                        } else {
                            this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]/day'+calDay+'[1]');
                        }
                    } else {
                        this.addNode('day'+calDay);
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]/day'+calDay+'[1]');
                    }

                    // Check for duplicate data, so we're not inserting things over and over again if the same
                    // build function is called more than once while loading all the different files.
                    eventcount = this.getNodeCount();
                    var dupeevent = false;
                    if(eventcount != 0){
                        for(var i = 1; i <= eventcount; i++){
                            this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]/day'+calDay+'[1]/event['+i+']');
                            if(this.xpathQuery('summary[1]/@value') == calSum){
                                // The thing is, because we're loading data every month, and we're, in this version,
                                // only reading from files and not writing to them, if we change data in a month
                                // and then go to a different month and then return, the original data will reload.
                                // This will be fixed when we implement writing to the data files, but is kind of
                                // unavoidable now, unless we load all the data at once and never again, which seems
                                // inefficient and problematic.
                                if(this.xpathQuery('start[1]/@hour') == calHour){
                                    dupeevent = true;
                                }
                            }
                        }
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]/day'+calDay+'[1]');
                    }
                    
                    if(dupeevent != true){
                        this.addNode('event');
                        this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]/month'+mo+'[1]/day'+calDay+'[1]/event['+(Number(this.getNodeCount()) <= 1 ? 1 : Number(this.getNodeCount()))+']');

                        this.addNode('summary', null, {value: calSum});
                        this.addNode('location', null, {value: calLoc});
                        this.addNode('comment', null, {value: calDesc});
                        this.addNode('uid', null, {value: calUID});
                        this.addNode('category', null, {value: calCategory});

                        // Add start and end date tags
                        this.addNode('start');
                        this.setXPath('start[1]');
                        this.setNodeAttribute('year', calYear);
                        this.setNodeAttribute('month', calMonth);
                        this.setNodeAttribute('day', calDay);
                        this.setNodeAttribute('hour', calHour);
                        this.setNodeAttribute('minute', calMin);
                        this.selectParent();
                        this.addNode('end');
                        this.setXPath('end[1]');
                        this.setNodeAttribute('year', calEYear);
                        this.setNodeAttribute('month', calEMonth);
                        this.setNodeAttribute('day', calEDay);
                        this.setNodeAttribute('hour', calEHour);
                        this.setNodeAttribute('minute', calEMin);
                        this.selectParent();
                    }

                    // Reset the positions for the next iteration
                    icalDP.setXPath('icalData:/rdf:RDF[1]/Vcalendar[1]');
                    this.setXPath('builddata:/vcalendar[1]/year'+yr+'[1]');
                }
                countToken++;
            }
            ]]>
        </method>
    </datapointer>

    <datapointer name="datatester">
        <method name="hasNode" args="mo, yr">
            this.setXPath('eventdata:/vcalendar/year' + yr + '/month' + mo);
            //this is unfortunate, but there's no easy way to see if this
            //succeeded as v1
            return this.getNodeName() == "month"+mo;
        </method>
    </datapointer>

    <!-- walks down local and server dataset node hierarchies while it finds
         matching nodes. when there is a mismatch, inserts server data -->
    <datapointer name="localdatacontroller" xpath="builddata:/">    
        <method name="mergeInsert" args="optr">
            var ptr = optr.dupePointer();
            this.setXPath('builddata:/');

            while(ptr.getNodeCount() == 1){
                var op = this.p;
                this.setXPath(ptr.getNodeName());
                if(this.getNodeName() != ptr.getNodeName()){
                    this.setPointer(op);
                    break;
                }
                ptr.selectChild()
            }

            var t = getTimer();
            this.addNodeFromPointer(ptr);
            //Debug.write('localdatactrlr: ' + this.xpathQuery());
            //Debug.write( "time to addNode: " + ( getTimer() - t ) );
        </method>
    </datapointer>

    <!-- local data set -->
    <dataset name="eventdata" />

    <!-- used for adding events -->
    <dataset name="blankEvent">
        <event>
            <summary value=""/>
            <comment value=""/>
            <start year="" month="" day="" hour="" minute="" />
            <end year="" month="" day="" hour="" minute="" />
            <category value=""/>
            <uid value=""/>
        </event>
    </dataset>

    <!-- Assigned to the panel when deleting an event -->
    <dataset name="noEvent">
        <event>
            <summary value=""/>
            <comment value=""/>
            <start year="" month="" day="" hour="" minute="" />
            <end year="" month="" day="" hour="" minute="" />
            <category value=""/>
            <uid value=""/>
        </event>
    </dataset>

    <datapointer id="alleventsDP" xpath="builddata:/"/>
    <datapointer id="currenteventDP" />
    <datapointer id="blankeventDP" xpath="blankEvent:/"/>
    <datapointer id="tempDP" xpath="builddata:/"/>

    <!-- This node provides some useful methods for manipulating the 
         local data -->
    <node id="eventDataMgr">
        <method name="addEvent">
            // Add event is called by the "Add Event" button to 
            //create a new event

            alleventsDP.setXPath('builddata:/vcalendar[1]');

            // Set the blank event pointer to the top of the event
            blankeventDP.setXPath('blankEvent:/event[1]');

            // Set the right current cal day for new events
            var selDay = calgrid.daySelectionMgr.getSelection()[0];
            if(selDay){
                blankeventDP.setNodeAttribute('selected',true);
                blankeventDP.setXPath('start[1]');
                blankeventDP.setNodeAttribute('year',
                         selDay.startdate.getFullYear());
                blankeventDP.setNodeAttribute('month',
                             selDay.startdate.getMonth()+1);
                blankeventDP.setNodeAttribute('day',
                             selDay.startdate.getDate());

                blankeventDP.setNodeAttribute('hour', 9 );
                blankeventDP.setNodeAttribute('minute', 0 );

                blankeventDP.setXPath('../end[1]');

                blankeventDP.setNodeAttribute('year',
                             selDay.startdate.getFullYear());
                blankeventDP.setNodeAttribute('month',
                             selDay.startdate.getMonth()+1);
                blankeventDP.setNodeAttribute('day',
                             selDay.startdate.getDate());

                blankeventDP.setNodeAttribute('hour', 10 );
                blankeventDP.setNodeAttribute('minute', 0 );


                blankeventDP.setXPath('../summary[1]');
                blankeventDP.setNodeAttribute('value', "New Event" );

                blankeventDP.selectParent();
            }

            // Move to OR create the node tree for this event
            // Each event should be in the right part of the 
            // tree of data (yearXXXX/monthX/dayX/)
            // The location in the tree is derived from the new 
            // events start data
            var year = blankeventDP.xpathQuery('start/@year');
            var month = blankeventDP.xpathQuery('start/@month');
            var day = blankeventDP.xpathQuery('start/@day');
            getNewNode(alleventsDP,'year'+year);
            getNewNode(alleventsDP,'month'+month);
            getNewNode(alleventsDP,'day'+day);

            // Add the event
            currenteventDP.setNodeAttribute( "selected" , false );
            var newPoint = alleventsDP.addNodeFromPointer(blankeventDP);

            // Set the event data pointer to the top of the event data
            alleventsDP.setXPath('builddata:/vcalendar[1]');
        </method>

        <method name="moveEvent" args="year,month,day">
            updateEventDate(currenteventDP,year,month,day); 
            //Make node attributes match dataset location

            alleventsDP.setXPath('builddata:/vcalendar[1]');

            // Create the node tree for this event
            getNewNode(alleventsDP,'year'+year);
            getNewNode(alleventsDP,'month'+month);
            getNewNode(alleventsDP,'day'+day);

            tempDP.setFromPointer( currenteventDP );
            // Copy current data to new location
            // If the record being moved is selected (usually the case, 
            // currenteventDP changes after this call
            var newPoint = alleventsDP.addNodeFromPointer(currenteventDP);

            //Delete the original node
            tempDP.deleteNode();

            // Set the event data pointer to the top of the event data
            alleventsDP.setXPath('builddata:/vcalendar[1]');
        </method>

        <method name="deleteEvent">
            // Deletes the current node
            currenteventDP.deleteNode();
            //currenteventDP.setXPath('blankEvent:/event[1]');
            eventselector.hide();
            currenteventDP.setPointer( noEvent.getFirstChild() );
        </method>

        <method name="changeEventTime" args="shour, smin">
            // Changes the current event's time
            tempDP.setFromPointer( currenteventDP );

            var emintmp = tempDP.xpathQuery( "end[1]/@min" );
            var smintmp = tempDP.xpathQuery( "start[1]/@min" );
            if (typeof(emintmp) == 'undefined') emintmp = 0;
            if (typeof(smintmp) == 'undefined') smintmp = 0;

            var evlen = tempDP.xpathQuery("end[1]/@hour") * 60 + emintmp - 
                (tempDP.xpathQuery("start[1]/@hour") * 60 - smintmp);

            var evlenhour = Math.floor( evlen / 60 );
            var evlenmin = evlen - ( evlenhour * 60 );

            tempDP.setXPath('start[1]');
            tempDP.setNodeAttribute('hour', shour);
            tempDP.setNodeAttribute('minute', smin);

            tempDP.setXPath('../end[1]');
            tempDP.setNodeAttribute('hour', shour + evlenhour);
            tempDP.setNodeAttribute('minute', smin + evlenmin );
        </method>

        <method name="getNewNode" args="dp,node">
            <![CDATA[
            //Returns the pointer to the requested node and makes one if needed

            if ( dp.xpathQuery(node+'/name()') == null){
                dp.addNode(node);
            }
            dp.setXPath(node);

            return (dp);
            ]]>
        </method>

        <method name="updateEventDate" args="dp,year,month,day">
            //This changes the attributes of the event's 
            //data to the right year,month,day
            //debug.write("updateEventDate");
            //debug.write("Year: "+year+"  month: "+month+"  day: "+day);

            tempDP.setFromPointer( dp );

            tempDP.setXPath('start[1]');
            tempDP.setNodeAttribute('year',year);
            tempDP.setNodeAttribute('month',month);
            tempDP.setNodeAttribute('day',day);

            tempDP.selectParent();

            tempDP.setXPath('end[1]');
            tempDP.setNodeAttribute('year',year);
            tempDP.setNodeAttribute('month',month);
            tempDP.setNodeAttribute('day',day);
        </method>

        <method name="getShortTime" args="DP">
            //Pass this a datapointer of Start or End node
            //returns H[a/p]  example: 1p

            var h = DP.getNodeAttribute('hour');
            if (h=="")return;

            var ap='a';

            if (h &gt; 11) ap='p';
            if (h &gt; 12) h-=12;
            if (h==0) h='12';
            return h+ap;
        </method>

        <method name="getLongTime" args="DP">
            //Pass this a datapointer of Start or End node
            //returns HH:MM [a/p]  example: 1:45p

            var h = DP.getNodeAttribute('hour');
            if (h=="")return;
            var m = DP.getNodeAttribute('minute')

            if (Number(m)==0 || m==null) m='0';
            if (Number(m)&lt;10) m='0'+m;

            var ap='a';

            if (h &gt; 11) ap='p';
            if (h &gt; 12) h-=12;

            return h+':'+m+ap;

        </method>

        <method name="getLongDate" args="DP">
            //Pass this a datapointer of Start or End node
            //returns MONTH DD,YYYY   example: April 28, 2003

            if (DP.getNodeAttribute('month')=="") return ("");

            return canvas.calMonths[(DP.getNodeAttribute('month')-1)] + " " +
                               DP.getNodeAttribute('day') + ", " +
                               DP.getNodeAttribute('year');
        </method>

        <method name="changeDay" args="whichWay">
            // Moves the current event to the next or previous day
            // Assumes updateEventDate has fixed any incorrect start tag data

            // Get current date info
            var year = Number(currenteventDP.xpathQuery('start[1]/@year'));
            var month = Number(currenteventDP.xpathQuery('start[1]/@month'));
            var day = Number(currenteventDP.xpathQuery('start[1]/@day'));

            var tempDate = new Date();
            tempDate.setFullYear(year);
            tempDate.setMonth(month-1);
            tempDate.setDate(day);

            //Change day
            tempDate=new Date(tempDate.valueOf() + whichWay * 86400000);

            year = tempDate.getFullYear();
            month = Number(tempDate.getMonth())+1;
            day = tempDate.getDate();


            moveEvent(year,month,day);

        </method>

        <method name="changetime" args="startEnd,whichWay"><![CDATA[
            // Moves the current event to the next or previous day
            // startEnd is either 'start' or 'end'
            // whichWay is either +1 or -1

            // Get current date info (need start and end for rules)
            var sHour = Number(currenteventDP.xpathQuery('start[1]/@hour'));
            var sMinute = Number(currenteventDP.xpathQuery('start[1]/@minute'));
            if (sHour + '' == 'NaN') sHour = 0;
            if (sMinute + '' == 'NaN') sMinute = 0;
            if ( startEnd == "start" ){

                sMinute += 15 * whichWay;
                if ( sMinute < 0 ) {
                    sMinute += 60;
                    sHour -= 1;
                } else if ( sMinute > 59 ) {
                    sMinute -= 60;
                    sHour += 1;
                }
                this.changeEventTime( sHour, sMinute );
            }else{
                var eHour = Number(currenteventDP.xpathQuery('end[1]/@hour'));
                var eMinute = Number(currenteventDP.xpathQuery('end[1]/@minute'));

                if ( eHour * 60 + eMinute + whichWay * 15 > 
                         sHour * 60 + sMinute )  {

                    eMinute += 15 * whichWay;
                    if ( eMinute < 0 ) {
                        eMinute += 60;
                        eHour -= 1;
                    } else if ( eMinute > 59 ) {
                        eMinute -= 60;
                        eHour += 1;
                    }
                    tempDP.setFromPointer( currenteventDP );
                    tempDP.setXPath('end[1]');
                    tempDP.setNodeAttribute( 'hour' , eHour );
                    tempDP.setNodeAttribute( 'minute' , eMinute );
                }
            }
            ]]>
        </method>
    </node>

</library>