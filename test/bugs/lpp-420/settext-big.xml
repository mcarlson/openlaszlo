<text>
<![CDATA[
> 330kb of text follows
> 
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
> The Cathedral and the Bazaar
> 
> Linux is subversive. Who would have thought even five years ago (1991)
> that a world-class operating system could coalesce as if by magic out
> of part-time hacking by several thousand developers scattered all over
> the planet, connected only by the tenuous strands of the Internet?
> 
> Certainly not I. By the time Linux swam onto my radar screen in early
> 1993, I had already been involved in Unix and open-source development
> for ten years. I was one of the first GNU contributors in the
> mid-1980s. I had released a good deal of open-source software onto the
> net, developing or co-developing several programs (nethack, Emacs's VC
> and GUD modes, xlife, and others) that are still in wide use today. I
> thought I knew how it was done.
> 
> Linux overturned much of what I thought I knew. I had been preaching
> the Unix gospel of small tools, rapid prototyping and evolutionary
> programming for years. But I also believed there was a certain
> critical complexity above which a more centralized, a priori approach
> was required. I believed that the most important software (operating
> systems and really large tools like the Emacs programming editor)
> needed to be built like cathedrals, carefully crafted by individual
> wizards or small bands of mages working in splendid isolation, with no
> beta to be released before its time.
> 
> Linus Torvalds's style of development--release early and often,
> delegate everything you can, be open to the point of promiscuity--came
> as a surprise. No quiet, reverent cathedral-building here--rather, the
> Linux community seemed to resemble a great babbling bazaar of
> differing agendas and approaches (aptly symbolized by the Linux
> archive sites, who'd take submissions from anyone) out of which a
> coherent and stable system could seemingly emerge only by a succession
> of miracles.
> 
> The fact that this bazaar style seemed to work, and work well, came as
> a distinct shock. As I learned my way around, I worked hard not just
> at individual projects, but also at trying to understand why the Linux
> world not only didn't fly apart in confusion but seemed to go from
> strength to strength at a speed barely imaginable to
> cathedral-builders.
> 
> By mid-1996 I thought I was beginning to understand. Chance handed me
> a perfect way to test my theory, in the form of an open-source project
> that I could consciously try to run in the bazaar style. So I did--and
> it was a significant success.
> 
> This is the story of that project. I'll use it to propose some
> aphorisms about effective open-source development. Not all of these
> are things I first learned in the Linux world, but we'll see how the
> Linux world gives them particular point. If I'm correct, they'll help
> you understand exactly what it is that makes the Linux community such
> a fountain of good software--and, perhaps, they will help you become
> more productive yourself.
> 
> The Mail Must Get Through
> 
> Since 1993 I'd been running the technical side of a small free-access
> Internet service provider called Chester County InterLink (CCIL) in
> West Chester, Pennsylvania. I co-founded CCIL and wrote our unique
> multiuser bulletin-board software--you can check it out by telnetting
> to locke.ccil.org. Today it supports almost three thousand users on
> thirty lines. The job allowed me 24-hour-a-day access to the net
> through CCIL's 56K line--in fact, the job practically demanded it!
> 
> I had gotten quite used to instant Internet email. I found having to
> periodically telnet over to locke to check my mail annoying. What I
> wanted was for my mail to be delivered on snark (my home system) so
> that I would be notified when it arrived and could handle it using all
> my local tools.
> 
> The Internet's native mail forwarding protocol, SMTP (Simple Mail
> Transfer Protocol), wouldn't suit, because it works best when machines
> are connected full-time, while my personal machine isn't always on the
> Internet, and doesn't have a static IP address. What I needed was a
> program that would reach out over my intermittent dialup connection
> and pull across my mail to be delivered locally. I knew such things
> existed, and that most of them used a simple application protocol
> called POP (Post Office Protocol). POP is now widely supported by most
> common mail clients, but at the time, it wasn't built in to the mail
> reader I was using.
> I needed a POP3 client. So I went out on the Internet and found
> one. Actually, I found three or four. I used one of them for a while,
> but it was missing what seemed an obvious feature, the ability to hack
> the addresses on fetched mail so replies would work properly.
> The problem was this: suppose someone named `joe' on locke sent me
> mail. If I fetched the mail to snark and then tried to reply to it, my
> mailer would cheerfully try to ship it to a nonexistent `joe' on
> snark. Hand-editing reply addresses to tack on <@ccil.org> quickly got
> to be a serious pain.
> This was clearly something the computer ought to be doing for me. But
> none of the existing POP clients knew how! And this brings us to the
> first lesson:
> 1. Every good work of software starts by scratching a developer's
> personal itch.
> Perhaps this should have been obvious (it's long been proverbial that
> ``Necessity is the mother of invention'') but too often software
> developers spend their days grinding away for pay at programs they
> neither need nor love. But not in the Linux world--which may explain
> why the average quality of software originated in the Linux community
> is so high.
> So, did I immediately launch into a furious whirl of coding up a
> brand-new POP3 client to compete with the existing ones? Not on your
> life! I looked carefully at the POP utilities I had in hand, asking
> myself ``Which one is closest to what I want?'' Because:
> 2. Good programmers know what to write. Great ones know what to
> rewrite (and reuse).
> While I don't claim to be a great programmer, I try to imitate one. An
> important trait of the great ones is constructive laziness. They know
> that you get an A not for effort but for results, and that it's almost
> always easier to start from a good partial solution than from nothing
> at all.
> Linus Torvalds, for example, didn't actually try to write Linux from
> scratch. Instead, he started by reusing code and ideas from Minix, a
> tiny Unix-like operating system for PC clones. Eventually all the
> Minix code went away or was completely rewritten--but while it was
> there, it provided scaffolding for the infant that would eventually
> become Linux.
> In the same spirit, I went looking for an existing POP utility that
> was reasonably well coded, to use as a development base.
> The source-sharing tradition of the Unix world has always been
> friendly to code reuse (this is why the GNU project chose Unix as a
> base OS, in spite of serious reservations about the OS itself). The
> Linux world has taken this tradition nearly to its technological
> limit; it has terabytes of open sources generally available. So
> spending time looking for some else's almost-good-enough is more
> likely to give you good results in the Linux world than anywhere else.
> And it did for me. With those I'd found earlier, my second search made
> up a total of nine candidates--fetchpop, PopTart, get-mail, gwpop,
> pimp, pop-perl, popc, popmail and upop. The one I first settled on was
> `fetchpop' by Seung-Hong Oh. I put my header-rewrite feature in it,
> and made various other improvements which the author accepted into his
> 1.9 release.
> A few weeks later, though, I stumbled across the code for popclient by
> Carl Harris, and found I had a problem. Though fetchpop had some good
> original ideas in it (such as its background-daemon mode), it could
> only handle POP3 and was rather amateurishly coded (Seung-Hong was at
> that time a bright but inexperienced programmer, and both traits
> showed). Carl's code was better, quite professional and solid, but his
> program lacked several important and rather tricky-to-implement
> fetchpop features (including those I'd coded myself).
> Stay or switch? If I switched, I'd be throwing away the coding I'd
> already done in exchange for a better development base.
> A practical motive to switch was the presence of multiple-protocol
> support. POP3 is the most commonly used of the post-office server
> protocols, but not the only one. Fetchpop and the other competition
> didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
> of perhaps adding IMAP (Internet Message Access Protocol, the most
> recently designed and most powerful post-office protocol) just for
> fun.
> But I had a more theoretical reason to think switching might be as
> good an idea as well, something I learned long before Linux.
> 3. ``Plan to throw one away; you will, anyhow.'' (Fred Brooks, The
> Mythical Man-Month, Chapter 11)
> Or, to put it another way, you often don't really understand the
> problem until after the first time you implement a solution. The
> second time, maybe you know enough to do it right. So if you want to
> get it right, be ready to start over at least once [JB].
> Well (I told myself) the changes to fetchpop had been my first try. So
> I switched.
> After I sent my first set of popclient patches to Carl Harris on 25
> June 1996, I found out that he had basically lost interest in
> popclient some time before. The code was a bit dusty, with minor bugs
> hanging out. I had many changes to make, and we quickly agreed that
> the logical thing for me to do was take over the program.
> Without my actually noticing, the project had escalated. No longer was
> I just contemplating minor patches to an existing POP client. I took
> on maintaining an entire one, and there were ideas bubbling in my head
> that I knew would probably lead to major changes.
> In a software culture that encourages code-sharing, this is a natural
> way for a project to evolve. I was acting out this principle:
> 4. If you have the right attitude, interesting problems will find
> you.
> But Carl Harris's attitude was even more important. He understood that
> 5. When you lose interest in a program, your last duty to it is to
> hand it off to a competent successor.
> Without ever having to discuss it, Carl and I knew we had a common
> goal of having the best solution out there. The only question for
> either of us was whether I could establish that I was a safe pair of
> hands. Once I did that, he acted with grace and dispatch. I hope I
> will do as well when it comes my turn.
> And so I inherited popclient. Just as importantly, I inherited
> popclient's user base. Users are wonderful things to have, and not
> just because they demonstrate that you're serving a need, that you've
> done something right. Properly cultivated, they can become
> co-developers.
> Another strength of the Unix tradition, one that Linux pushes to a
> happy extreme, is that a lot of users are hackers too. Because source
> code is available, they can be effective hackers. This can be
> tremendously useful for shortening debugging time. Given a bit of
> encouragement, your users will diagnose problems, suggest fixes, and
> help improve the code far more quickly than you could unaided.
> 6. Treating your users as co-developers is your least-hassle route
> to rapid code improvement and effective debugging.
> The power of this effect is easy to underestimate. In fact, pretty
> well all of us in the open-source world drastically underestimated how
> well it would scale up with number of users and against system
> complexity, until Linus Torvalds showed us differently.
> In fact, I think Linus's cleverest and most consequential hack was not
> the construction of the Linux kernel itself, but rather his invention
> of the Linux development model. When I expressed this opinion in his
> presence once, he smiled and quietly repeated something he has often
> said: ``I'm basically a very lazy person who likes to get credit for
> things other people actually do.'' Lazy like a fox. Or, as Robert
> Heinlein famously wrote of one of his characters, too lazy to fail.
> In retrospect, one precedent for the methods and success of Linux can
> be seen in the development of the GNU Emacs Lisp library and Lisp code
> archives. In contrast to the cathedral-building style of the Emacs C
> core and most other GNU tools, the evolution of the Lisp code pool was
> fluid and very user-driven. Ideas and prototype modes were often
> rewritten three or four times before reaching a stable final form. And
> loosely-coupled collaborations enabled by the Internet, a la Linux,
> were frequent.
> Indeed, my own most successful single hack previous to fetchmail was
> probably Emacs VC (version control) mode, a Linux-like collaboration
> by email with three other people, only one of whom (Richard Stallman,
> the author of Emacs and founder of the Free Software Foundation) I
> have met to this day. It was a front-end for SCCS, RCS and later CVS
> from within Emacs that offered ``one-touch'' version control
> operations. It evolved from a tiny, crude sccs.el mode somebody else
> had written. And the development of VC succeeded because, unlike Emacs
> itself, Emacs Lisp code could go through release/test/improve
> generations very quickly.
> The Emacs story is not unique. There have been other software products
> with a two-level architecture and a two-tier user community that
> combined a cathedral-mode core and a bazaar-mode toolbox. One such is
> MATLAB, a commercial data-analysis and visualization tool. Users of
> MATLAB and other products with a similar structure invariably report
> that the action, the ferment, the innovation mostly takes place in the
> open part of the tool where a large and varied community can tinker
> with it.
> he Social Context of Open-Source Software
> It is truly written: the best hacks start out as personal solutions to
> the author's everyday problems, and spread because the problem turns
> out to be typical for a large class of users. This takes us back to
> the matter of rule 1, restated in a perhaps more useful way:
> 18. To solve an interesting problem, start by finding a problem
> that is interesting to you.
> So it was with Carl Harris and the ancestral popclient, and so with me
> and fetchmail. But this has been understood for a long time. The
> interesting point, the point that the histories of Linux and fetchmail
> seem to demand we focus on, is the next stage--the evolution of
> software in the presence of a large and active community of users and
> co-developers.
> In The Mythical Man-Month, Fred Brooks observed that programmer time
> is not fungible; adding developers to a late software project makes it
> later. As we've seen previously, he argued that the complexity and
> communication costs of a project rise with the square of the number of
> developers, while work done only rises linearly. Brooks's Law has been
> widely regarded as a truism. But we've examined in this essay an
> number of ways in which the process of open-source development
> falsifies the assumptionms behind it--and, empirically, if Brooks's Law
> were the whole picture Linux would be impossible.
> Gerald Weinberg's classic The Psychology of Computer Programming
> supplied what, in hindsight, we can see as a vital correction to
> Brooks. In his discussion of ``egoless programming'', Weinberg
> observed that in shops where developers are not territorial about
> their code, and encourage other people to look for bugs and potential
> improvements in it, improvement happens dramatically faster than
> elsewhere. (Recently, Kent Beck's `extreme programming' technique of
> deploying coders in pairs looking over one anothers' shoulders might
> be seen as an attempt to force this effect.)
> Weinberg's choice of terminology has perhaps prevented his analysis
> from gaining the acceptance it deserved--one has to smile at the
> thought of describing Internet hackers as ``egoless''. But I think his
> argument looks more compelling today than ever.
> The bazaar method, by harnessing the full power of the ``egoless
> programming'' effect, strongly mitigates the effect of Brooks's
> Law. The principle behind Brooks's Law is not repealed, but given a
> large developer population and cheap communications its effects can be
> swamped by competing nonlinearities that are not otherwise
> visible. This resembles the relationship between Newtonian and
> Einsteinian physics--the older system is still valid at low energies,
> but if you push mass and velocity high enough you get surprises like
> nuclear explosions or Linux.
> The history of Unix should have prepared us for what we're learning
> from Linux (and what I've verified experimentally on a smaller scale
> by deliberately copying Linus's methods [EGCS]). That is, while coding
> remains an essentially solitary activity, the really great hacks come
> from harnessing the attention and brainpower of entire
> communities. The developer who uses only his or her own brain in a
> closed project is going to fall behind the developer who knows how to
> create an open, evolutionary context in which feedback exploring the
> design space, code contributions, bug-spotting, and other improvements
> come from from hundreds (perhaps thousands) of people.
> But the traditional Unix world was prevented from pushing this
> approach to the ultimate by several factors. One was the legal
> contraints of various licenses, trade secrets, and commercial
> interests. Another (in hindsight) was that the Internet wasn't yet
> good enough.
> Before cheap Internet, there were some geographically compact
> communities where the culture encouraged Weinberg's ``egoless''
> programming, and a developer could easily attract a lot of skilled
> kibitzers and co-developers. Bell Labs, the MIT AI and LCS labs, UC
> Berkeley--these became the home of innovations that are legendary and
> still potent.
> Linux was the first project for which a conscious and successful
> effort to use the entire world as its talent pool was made. I don't
> think it's a coincidence that the gestation period of Linux coincided
> with the birth of the World Wide Web, and that Linux left its infancy
> during the same period in 1993--1994 that saw the takeoff of the ISP
> industry and the explosion of mainstream interest in the
> Internet. Linus was the first person who learned how to play by the
> new rules that pervasive Internet access made possible.
> While cheap Internet was a necessary condition for the Linux model to
> evolve, I think it was not by itself a sufficient condition. Another
> vital factor was the development of a leadership style and set of
> cooperative customs that could allow developers to attract
> co-developers and get maximum leverage out of the medium.
> But what is this leadership style and what are these customs? They
> cannot be based on power relationships--and even if they could be,
> leadership by coercion would not produce the results we see. Weinberg
> quotes the autobiography of the 19th-century Russian anarchist Pyotr
> Alexeyvich Kropotkin's Memoirs of a Revolutionist to good effect on
> this subject:
> Having been brought up in a serf-owner's family, I entered active
> life, like all young men of my time, with a great deal of
> confidence in the necessity of commanding, ordering, scolding,
> punishing and the like. But when, at an early stage, I had to
> manage serious enterprises and to deal with [free] men, and when
> each mistake would lead at once to heavy consequences, I began to
> appreciate the difference between acting on the principle of
> command and discipline and acting on the principle of common
> understanding. The former works admirably in a military parade,
> but it is worth nothing where real life is concerned, and the aim
> can be achieved only through the severe effort of many converging
> wills.
> The ``severe effort of many converging wills'' is precisely what a
> project like Linux requires--and the ``principle of command'' is
> effectively impossible to apply among volunteers in the anarchist's
> paradise we call the Internet. To operate and compete effectively,
> hackers who want to lead collaborative projects have to learn how to
> recruit and energize effective communities of interest in the mode
> vaguely suggested by Kropotkin's ``principle of understanding''. They
> must learn to use Linus's Law.[SP]
> Earlier I referred to the ``Delphi effect'' as a possible explanation
> for Linus's Law. But more powerful analogies to adaptive systems in
> biology and economics also irresistably suggest themselves. The Linux
> world behaves in many respects like a free market or an ecology, a
> collection of selfish agents attempting to maximize utility which in
> the process produces a self-correcting spontaneous order more
> elaborate and efficient than any amount of central planning could have
> achieved. Here, then, is the place to seek the ``principle of
> understanding''.
> The ``utility function'' Linux hackers are maximizing is not
> classically economic, but is the intangible of their own ego
> satisfaction and reputation among other hackers. (One may call their
> motivation ``altruistic'', but this ignores the fact that altruism is
> itself a form of ego satisfaction for the altruist). Voluntary
> cultures that work this way are not actually uncommon; one other in
> which I have long participated is science fiction fandom, which unlike
> hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
> the enhancement of one's reputation among other fans) as the basic
> drive behind volunteer activity.
> Linus, by successfully positioning himself as the gatekeeper of a
> project in which the development is mostly done by others, and
> nurturing interest in the project until it became self-sustaining, has
> shown an acute grasp of Kropotkin's ``principle of shared
> understanding''. This quasi-economic view of the Linux world enables
> us to see how that understanding is applied.
> We may view Linus's method as a way to create an efficient market in
> ``egoboo''--to connect the selfishness of individual hackers as firmly
> as possible to difficult ends that can only be achieved by sustained
> cooperation. With the fetchmail project I have shown (albeit on a
> smaller scale) that his methods can be duplicated with good
> results. Perhaps I have even done it a bit more consciously and
> systematically than he.
> Many people (especially those who politically distrust free markets)
> would expect a culture of self-directed egoists to be fragmented,
> territorial, wasteful, secretive, and hostile. But this expectation is
> clearly falsified by (to give just one example) the stunning variety,
> quality, and depth of Linux documentation. It is a hallowed given that
> programmers hate documenting; how is it, then, that Linux hackers
> generate so much documentation? Evidently Linux's free market in
> egoboo works better to produce virtuous, other-directed behavior than
> the massively-funded documentation shops of commercial software
> producers.
> Both the fetchmail and Linux kernel projects show that by properly
> rewarding the egos of many other hackers, a strong
> developer/coordinator can use the Internet to capture the benefits of
> having lots of co-developers without having a project collapse into a
> chaotic mess. So to Brooks's Law I counter-propose the following:
> 19: Provided the development coordinator has a communications
> medium at least as good as the Internet, and knows how to lead
> without coercion, many heads are inevitably better than one.
> I think the future of open-source software will increasingly belong to
> people who know how to play Linus's game, people who leave behind the
> cathedral and embrace the bazaar. This is not to say that individual
> vision and brilliance will no longer matter; rather, I think that the
> cutting edge of open-source software will belong to people who start
> from individual vision and brilliance, then amplify it through the
> effective construction of voluntary communities of interest.
> Perhaps this is not only the future of open-source software. No
> closed-source developer can match the pool of talent the Linux
> community can bring to bear on a problem. Very few could afford even
> to hire the more than 200 (1999: 600, 2000: 800) people who have
> contributed to fetchmail!
> Perhaps in the end the open-source culture will triumph not because
> cooperation is morally right or software ``hoarding'' is morally wrong
> (assuming you believe the latter, which neither Linus nor I do), but
> simply because the closed-source world cannot win an evolutionary arms
> race with open-source communities that can put orders of magnitude
> more skilled time into a problem.
]]>
</text>
