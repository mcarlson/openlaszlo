# File: rng2dtd.py
# Author: Oliver Steele

# * P_LZ_COPYRIGHT_BEGIN ******************************************************
# * Copyright 2001-2004 Laszlo Systems, Inc.  All Rights Reserved.            *
# * Use is subject to license terms.                                          *
# * P_LZ_COPYRIGHT_END ********************************************************

"""Usage: %(progname)s rngfile [-o dtdfile]
"""

"""
TBD:
- types for components
- parenthesize dataset cm
- refs -> DTD entities

References:
- http://www.w3schools.com/dtd/dtd_attributes.asp
"""

import os
from rngparse import *
False, True = 0, 1

#
# DTD Writing
#

DtdProlog = """<!-- %(fname)s

    Laszlo Application Markup Language (LZX) DTD.

    Copyright (c) 2002-2003 Laszlo Systems, Inc.
    All Rights Reserved.

    This software is the proprietary information of Laszlo Systems, Inc.
    Use is subject to license terms.

    Generated by rng2dtd on %(date)s.
-->

<!ENTITY quot	"&#x0022;"> <!-- QUOTATION MARK -->
<!ENTITY amp	"&#38;#38;"> <!-- AMPERSAND -->
<!ENTITY lt	"&#38;#60;"> <!-- LESS-THAN SIGN -->
<!ENTITY gt	"&#x003E;"> <!-- GREATER-THAN SIGN -->
""" #" comment to make emacs happy

def getElementContentDTD(elt):
    cm = elt.contentModel
    cm = simplifycm(removeInterleaves(cm))
    isMixed = cmIsMixed(cm)
    # TODO: this allows CDATA on too many elements;
    # it ought to be used only on elements that extend
    # a mixed element or contain an attribute name="text" type="text|html"
    # (and rngparse ought to do this, or ask LPS for the schema)
    if cm and hasattr(elt, 'extends'):
        isMixed = True
    if isMixed: #cmIsMixed(cm):
        els = ['#PCDATA'] + \
              [s for s in cmelements(cm)
               if s != TEXT_PSEUDONAME]
        # TBD: simplify should have done this
        args = els; els = []
        for arg in args:
            if arg not in els:
                els.append(arg)
        cms = '(' + ' | '.join(els) + ')*'
    elif cm:
        cms = cm2s(cm, needParens=False)
        import re
        if re.match('#?[a-zA-Z]+[*?]', cms):
            cms = '(' + cms[:-1] + ')*'
        elif cms == '#PCDATA':
            cms = '(' + cms + ')'
    else:
        cms = 'EMPTY'
    return cms

def getAttributeTypeDTD(attr):
    if type(attr.type) == type(()):
        assert attr.type[0] == Choice
        choices = attr.type[1]
        if not choices:
            return 'CDATA'
        for s in choices:
            import re
            if not re.match(r'[a-zA-Z]\w*$', s):
                return 'CDATA'
        return '(' + ' | '.join([t for t in attr.type[1]]) + ')'
    return attr.type

def getAttributeDefaultDTD(attr):
    if attr.required:
        return '#REQUIRED'
    elif attr.default is None:
        return '#IMPLIED'
    else:
        s = attr.default
        s = s.replace('&', '&amp;')
        s = s.replace('<', '&lt;')
        s = s.replace('"', '&quot;')
        return '"%s"' % s

def writeDTD(schema, fname):
    f = open(fname, 'w')
    import time
    print >> f, DtdProlog % {'fname': fname, 'date': time.asctime()}
    names = removeDuplicates([e.name for e in schema.elements])
    names.sort()
    cc = max(16, *[len('<!ELEMENT %s' % name) + 2 for name in names])
    cc = 24
    for name in names:
        elements = [e for e in schema.elements if e.name == name]
        element = elements[0]
        # Merge elements with the same name.
        for e2 in elements[1:]:
            element = mergeElements(element, e2)
        writeElementDTD(schema, element, cc, f)
    f.close()

def writeElementDTD(schema, element, cc, f):
    import re
    if element.doc:
        print >> f, '<!-- %s -->' % element.doc
    pad = ' ' * max(cc - len('<!ELEMENT %s' % element.name), 1)
    print >> f, '<!ELEMENT %s%s%s>' % (element.name, pad, getElementContentDTD(element))
    def printattrs(attrs):
        if attrs:
            attrs.sort(lambda a, b:cmp(a.name, b.name))
            prefix = '<!ATTLIST %s%s' % (element.name, pad)
            p1 = (max(0, *[len(a.name) for a in attrs]) + 1)
            p1 = 16
            p2 = (max(0, *[len(getAttributeTypeDTD(a)) for a in attrs]) + 1)
            p2 = 16
            def padd(s, n):
                return s + ' ' * max(n - len(s), 1)
            for attr in attrs:
                # added this test to remove private attribs from lzx.dtd --MD
                if re.match('_', attr.name):
                    continue
                type = getAttributeTypeDTD(attr)
                default = getAttributeDefaultDTD(attr)
                f.write(prefix + padd(attr.name, p1) + padd(type, p2) + \
                        default)
                prefix = '\n' + ' ' * cc
            print >> f, '>'
    printattrs(element.attrs)
    print >> f

def updateSchema(schema):
    # add view attributes to class
    classElement = schema.getElement('class')
    # Choose the view that has an oninit attribute, to discard the
    # splash view.  Necessary because this is the public rng file,
    # which doesn't contain the unique name attribute
    def getAttrNames(e):
        return [a.name for a in e.attrs]
    viewElement = [e for e in schema.getElements('view')
                   if 'oninit' in getAttrNames(e)][0]
    classElement.attrs += [a for a in viewElement.attrs \
                          if a.name not in getAttrNames(classElement)]

#
# Main
#

def usage():
    import sys
    print __doc__ % {'progname': 'rng2dtd'}
    sys.exit(1)

def main(args):
    import sys, os
    if len(args) == 1:
        fname = args[0]
        dtdname = os.path.splitext(fname)[0] + '.dtd'
    elif len(args) == 3 and args[1] == '-o':
        fname, dtdname = args[0], args[2]
    else:
        usage()
    schema = readSchema(fname)
    updateSchema(schema)
    writeDTD(schema, dtdname)

def test():
    main(['lzx.rng'])

if __name__ == '__main__':
    import sys
    main(sys.argv[1:])
elif 0: # debugging
    readSchema('lzx.rng')
    #main(['lzx.rng'])
