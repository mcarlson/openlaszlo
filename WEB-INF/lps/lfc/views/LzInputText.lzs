/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @affects lztext
  * @topic LFC
  * @subtopic Text
  */

/**
  * <p>This tag creates an area of the canvas that the user can use to
  * edit text.  It is equivalent to the HTML <code>&lt;input
  * type="text"&gt;</code>, <code>&lt;input type="password"&gt;</code>,
  * and <code>textarea</code> tags.</p>
  * <p>See the documentation for the <tagname link="true">text</tagname>
  * tag for a description of the <attribute>width</attribute> and <attribute>height</attribute> attributes,
  * and of scrolling.</p>
  * <h2>Single-line input text</h2>
  * 
  * <p>With the <attribute>multiline</attribute> and
  * <attribute>password</attribute> attributes set to <code>false</code>
  * (the default), this tag is similar to the HTML <code>&lt;input
  * type="text"&gt;</code> tag.  In this use, long lines of text are
  * clipped according to the <attribute>width</attribute> attribute.</p>
  * 
  * <example title="Simple inputtext"><programlisting>&lt;canvas height="50"&gt;
  *   &lt;inputtext width="150"&gt;This text is editable.&lt;/inputtext&gt;
  * &lt;/canvas&gt;</programlisting></example>
  * 
  * <h2>Multi-line input text</h2>
  * 
  * <p>With the <attribute>multiline</attribute> attribute set to
  * <code>true</code>, this tag is similar to the HTML
  * <code>&lt;textarea&gt;</code> tag.  In this use, text is wrapped to
  * the length of the <attribute>width</attribute> attribute, and the user
  * can press Enter to create multiple lines of input.</p>
  * 
  * <example title="Simple inputtext"><programlisting>&lt;canvas height="50"&gt;
  *   &lt;inputtext width="150" multiline="true"&gt;This text is editable.&lt;/inputtext&gt;
  * &lt;/canvas&gt;</programlisting></example>
  * 
  * <h2>Passwords</h2>
  * 
  * <p>With <attribute>password</attribute> set to <code>true</code>, this
  * tag is similar to the HTML <code>&lt;input type="password"&gt;</code>
  * tag.  Input characters are displayed as the asterisk
  * ('<code>*</code>') character.</p>
  * 
  * <example title="Password inputtext"><programlisting>&lt;canvas height="20"&gt;
  *   &lt;inputtext width="100" password="true"&gt;password.&lt;/inputtext&gt;
  * &lt;/canvas&gt;</programlisting></example>
  * 
  * 
  * @shortdesc The basic input-text element.
  * @lzxname inputtext
  */
dynamic public class LzInputText extends LzText {

  function LzInputText ( parent:LzNode? = null , attrs:Object? = null , children:Array? = null, instcall:Boolean  = false) {
    super(parent,attrs,children,instcall);
  }

/** If true, the inputtext contents will be obscured
  * @lzxtype booleanLiteral
  * @type Boolean
  * @modifiers read-only
  */
    var password;

/** @access private
  * @modifiers override 
  */
static var tagname = 'inputtext';
/** @access private */
  static var attributes = new LzInheritedHash(LzText.attributes);
  LzNode.mergeAttributes({selectable: true, enabled: true}, LzInputText.attributes);


/** Sent whenever the text field is enabled.
  * @lzxtype event
  */
var onenabled = LzDeclaredEvent;


/** @access private
  * @lzxtype event
  */
var onselect = LzDeclaredEvent;

/** 
  * Width to use for text field if none is specified
  * @access private
  */
override function getDefaultWidth () {
    return 100;
}


/** @access private */
var _onfocusDel = null;
/** @access private */
var _onblurDel = null;
/** @access private */
var _modemanagerDel = null;

/**
  * @access private
  */
override function construct ( parent , args ){
    this.password = ('password' in args && args.password)  ? true : false;
    this.focusable = true;
    super.construct.apply(this, arguments);
    this._onfocusDel = new LzDelegate( this , "_gotFocusEvent" , this,
                                            "onfocus" );
    this._onblurDel = new LzDelegate( this , "_gotBlurEvent" , this,
                                            "onblur" );
    this._modemanagerDel = new LzDelegate( this, "_modechanged", lz.ModeManager,
                                            "onmode" );
}

/**
  * @access private
  */
override function destroy(){
    if (this._onfocusDel) {
        this._onfocusDel.unregisterAll();
        this._onfocusDel = null;
    }
    
    if (this._onblurDel) {
        this._onblurDel.unregisterAll();
        this._onblurDel = null;
    }
    
    if (this._modemanagerDel) {
        this._modemanagerDel.unregisterAll();
        this._modemanagerDel = null;
    }
    
    super.destroy();
}

/**
  * Called to create the sprite object.  May be overridden to use a specific 
  * version, e.g. LzTextSprite();
  * @access private
  */
override function __makeSprite(args) {
    this.sprite = new LzInputTextSprite(this, args);
}

/** @access private */
var _focused = false;

/** @access private */
function _gotFocusEvent(e=null){
    this._focused = true;
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    isprite.gotFocus();
}

/** @access private */
function _gotBlurEvent(e=null){
    this._focused = false;
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    isprite.gotBlur();
}


/** @access private 
 * Receive input text events from sprite
 */
function inputtextevent (eventname, value = null) {
    //Debug.warn('inputtextevent', eventname, value);
    if (eventname == 'onfocus' && this._focused) return;
    if (eventname == 'onblur' && ! this._focused) return;
    if (eventname == 'onfocus' || eventname == 'onmousedown') {
        this._focused = true;
        if (lz.Focus.getFocus() != this) {
            var tabdown = lz.Keys.isKeyDown('tab');
            lz.Focus.setFocus(this, tabdown);
            return;
        }
    } else if (eventname == 'onchange') {
        //multiline resizable fields adjust their height
        var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
        if ( this.multiline && 
             this.sizeToHeight && 
             this.height != isprite.getTextHeight() ) {
            this.setHeight(isprite.getTextfieldHeight());
        }
        if (this.ontext.ready) this.ontext.sendEvent(value);
        return;
    } else if (eventname == 'onblur') {
        this._focused = false;
    }
    if (this[eventname].ready) this[eventname].sendEvent(value);
}

/**
  * Retrieves the contents of the text field for use by a datapath. See
  * <code>LzDatapath.updateData</code> for more on this.
  * @access protected
  */
override function updateData () {
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    return isprite.getText();
}


/** If true, the inputtext will be enabled
  * @lzxtype booleanLiteral
  * @type Boolean
  */
    public var enabled = true;


/**
  * Sets whether user can modify input text field
  * @param Boolean enabled: true if the text field can be edited
  */
function setEnabled (enabled){
    this.setAttribute('focusable', enabled);
    this.enabled = enabled;
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    isprite.setEnabled(enabled);
    if (this.onenabled.ready) this.onenabled.sendEvent(enabled);
}

/**
  * @access private
  */
function $lzc$set_enabled(v) { this.setEnabled(v); }

/**
  * Set the html flag on this text view
  * @param Boolean htmlp: If true, the text content is treated as HTML when displayed.
  */
function setHTML (htmlp) {
    if (this.capabilities['htmlinputtext']) {
        var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
        isprite.setHTML(htmlp);
    } else if ($debug) {
        this.__warnCapability('inputtext.setHTML()'); 
    }
}

/**
  * setText sets the text of the field to display
  * @param String t: the string to which to set the text
  */
override function setText ( t, force = null){
    // force to a string
    t += '';
    if (this.maxlength != null && t.length > this.maxlength){
        t = t.substring(0, this.maxlength);
    }
    (this.sprite cast LzInputTextSprite).setText(t);
    this.text =  t;
    // [todo 2006-06 hqm] when should we send onwidth and onheight events?

    // recalculate height
    if (this.height < 9 || this.sizeToHeight) {
        this.height = (this.sprite cast LzInputTextSprite).getTextfieldHeight();
        if (this.onheight.ready) this.onheight.sendEvent();
        if (this.height > 0) {
            this.setHeight(this.height);
        }
    }

    if (this.ontext.ready) this.ontext.sendEvent(t);
}

override function getText ( ){
    return (this.sprite cast LzInputTextSprite).getText();    
}

/** 
  * this attribute control the LzText::selectable attribute trough its setter
  * @access private
  */
var _allowselectable=true;

/** 
  * cache true value of selectable
  * @access private
  */
var _selectable;

/** 
  * Catch all lz.ModeManager events
  * @access private
  */
function _modechanged(modalview) {
    // !modalview = "lz.ModeManager release a view" => so allowselectable
    if ( !modalview ) {
        this._setallowselectable(true);
    } else {
        // lz.ModeManager make modalview as modal
        // (modalview.nodeLevel > this.nodeLevel) = "This cannot be a child of the setted modal view"
        // so not allowselectable
        if ( modalview.nodeLevel > this.nodeLevel ) {
            this._setallowselectable( false );
        } else {
            // is this a child of the setted modal view
            var parentSeeking = this;

            do {
                parentSeeking = parentSeeking.parent;
            } while ( parentSeeking != canvas && parentSeeking != modalview );

            this._setallowselectable(parentSeeking != canvas);
        }
    }
}

/** 
  * update the selectable status based on cached value
  * @access private
  */
function _setallowselectable(value) {
    this._allowselectable = value;
    this.setSelectable( this._selectable );
}

/** 
  * @access private
  */
override function setSelectable(value) {
    this._selectable = value;
    // depending on allowselectable : the setted value or false !
    super.setSelectable( this._allowselectable ? value : false );
}

} // End of LzInputText

ConstructorMap[LzInputText.tagname] = LzInputText;


