/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @affects lztext
  * @topic LFC
  * @subtopic Text
  */

/**
  * <p>This tag creates an area of the canvas that the user can use to
  * edit text.  It is equivalent to the HTML <code>&lt;input
  * type="text"&gt;</code>, <code>&lt;input type="password"&gt;</code>,
  * and <code>textarea</code> tags.</p>
  * <p>See the documentation for the <tagname link="true">text</tagname>
  * tag for a description of the <attribute>width</attribute> and <attribute>height</attribute> attributes,
  * and of scrolling.</p>
  * <h2>Single-line input text</h2>
  * 
  * <p>With the <attribute>multiline</attribute> and
  * <attribute>password</attribute> attributes set to <code>false</code>
  * (the default), this tag is similar to the HTML <code>&lt;input
  * type="text"&gt;</code> tag.  In this use, long lines of text are
  * clipped according to the <attribute>width</attribute> attribute.</p>
  * 
  * <example title="Simple inputtext"><programlisting>&lt;canvas height="50"&gt;
  *   &lt;inputtext width="150"&gt;This text is editable.&lt;/inputtext&gt;
  * &lt;/canvas&gt;</programlisting></example>
  * 
  * <h2>Multi-line input text</h2>
  * 
  * <p>With the <attribute>multiline</attribute> attribute set to
  * <code>true</code>, this tag is similar to the HTML
  * <code>&lt;textarea&gt;</code> tag.  In this use, text is wrapped to
  * the length of the <attribute>width</attribute> attribute, and the user
  * can press Enter to create multiple lines of input.</p>
  * 
  * <example title="Simple inputtext"><programlisting>&lt;canvas height="20"&gt;
  *   &lt;inputtext width="150" multiline="true"&gt;This text is editable.&lt;/inputtext&gt;
  * &lt;/canvas&gt;</programlisting></example>
  * 
  * <h2>Passwords</h2>
  * 
  * <p>With <attribute>password</attribute> set to <code>true</code>, this
  * tag is similar to the HTML <code>&lt;input type="password"&gt;</code>
  * tag.  Input characters are displayed as the asterisk
  * ('<code>*</code>') character.</p>
  * 
  * <example title="Password inputtext"><programlisting>&lt;canvas height="20"&gt;
  *   &lt;inputtext width="100" password="true"&gt;password.&lt;/inputtext&gt;
  * &lt;/canvas&gt;</programlisting></example>
  * 
  * 
  * <h2 id="fixedsize-optimization">Optimizing <code>inputtext</code></h2>
  * 
  * <p>A large <tagname>inputtext</tagname> view will respond to character
  * input slowly.  In many cases, it will not be able to keep up with
  * reasonable typing speed, even on a fast machine.</p>
  * 
  * <p>If an instance of <tagname>inputtext</tagname> will not be resized
  * at runtime, and the compiler can determine its size at compile time,
  * the compiler can substitute a <tagname>inputtext</tagname> view that
  * is optimized to accept text at that size for the generic resizable
  * <tagname>inputtext</tagname> view.  This optimized
  * <tagname>inputtext</tagname> view can keep up with typing speed even
  * at large sizes or on a slow computer.</p>
  * 
  * @shortdesc The basic input-text element.
  * @lzxname inputtext
  */
dynamic public class LzInputText extends LzText {

  function LzInputText ( parent:* , attrs:* , children:* = null, instcall:*  = null) {
    super(parent,attrs,children,instcall);
  }


/** @access private
  * @modifiers override 
  */
static var tagname = 'inputtext';
/** @access private */
  static var attributes = new LzInheritedHash(LzText.attributes);
  LzNode.mergeAttributes({selectable: true, enabled: true}, LzInputText.attributes);


/** @lzxtype event */
var onenabled = LzDeclaredEvent;

/** @lzxtype event */
var onselect = LzDeclaredEvent;

/** 
  * Width to use for text field if none is specified
  * @access private
  */
override function getDefaultWidth () {
    return 100;
}


/** @access private */
var _onfocusDel = null;
/** @access private */
var _onblurDel = null;
/** @access private */
var _modemanagerDel = null;

/**
  * @access private
  */
override function construct ( parent , args ){
    this.focusable = true;
    super.construct.apply(this, arguments);
    this._onfocusDel = new LzDelegate( this , "_gotFocusEvent" , this,
                                            "onfocus" );
    this._onblurDel = new LzDelegate( this , "_gotBlurEvent" , this,
                                            "onblur" );
    this._modemanagerDel = new LzDelegate( this, "_modechanged", LzModeManager,
                                            "onmode" );
}

/**
  * @access private
  */
override function destroy(){
    if (this._onfocusDel) {
        this._onfocusDel.unregisterAll();
        this._onfocusDel = null;
    }
    
    if (this._onblurDel) {
        this._onblurDel.unregisterAll();
        this._onblurDel = null;
    }
    
    if (this._modemanagerDel) {
        this._modemanagerDel.unregisterAll();
        this._modemanagerDel = null;
    }
    
    super.destroy();
}

/**
  * Called to create the sprite object.  May be overridden to use a specific 
  * version, e.g. LzTextSprite();
  * @access private
  */
override function __makeSprite(args) {
    this.sprite = new LzInputTextSprite(this, args);
}

var _focused = false;

/** @access private */
function _gotFocusEvent(){
    this._focused = true;
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    isprite.gotFocus();
}

/** @access private */
function _gotBlurEvent(){
    this._focused = false;
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    isprite.gotBlur();
}

// Receive input text events from sprite
function inputtextevent (eventname, value = null) {
    //Debug.warn('inputtextevent', eventname, value);
    if (eventname == 'onfocus' && this._focused) return;
    if (eventname == 'onblur' && ! this._focused) return;
    if (eventname == 'onfocus' || eventname == 'onmousedown') {
        this._focused = true;
        if (LzFocus.getFocus() != this) {
            var tabdown = LzKeys.isKeyDown('tab');
            LzFocus.setFocus(this, tabdown);
            return;
        }
    } else if (eventname == 'onchange') {
        //multiline resizable fields adjust their height
        var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
        if ( this.multiline && 
             this.sizeToHeight && 
             this.height != isprite.getTextHeight() ) {
            this.setHeight(isprite.getTextfieldHeight());
        }
        if (this.ontext.ready) this.ontext.sendEvent(value);
        return;
    } else if (eventname == 'onblur') {
        this._focused = false;
    }
    if (this[eventname].ready) this[eventname].sendEvent(value);
}

/**
  * Retrieves the contents of the text field for use by a datapath. See
  * <code>LzDatapath.updateData</code> for more on this.
  * @access protected
  */
function updateData (){
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    return isprite.getText();
}

    public var enabled = true;


/**
  * Sets whether user can modify input text field
  * @param Boolean enabled: true if the text field can be edited
  */
function setEnabled (enabled){
    this.setAttribute('focusable', enabled);
    this.enabled = enabled;
    var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
    isprite.setEnabled(enabled);
    if (this.onenabled.ready) this.onenabled.sendEvent(enabled);
}

/**
  * @access private
  */
function $lzc$set_enabled(v) { this.setEnabled(v); }

/**
  * Set the html flag on this text view
  */
function setHTML (htmlp) {
    if (this.capabilities['htmlinputtext']) {
        var isprite:LzInputTextSprite = (this.sprite cast LzInputTextSprite);    
        isprite.setHTML(htmlp);
    } else if ($debug) {
        this.__warnCapability('inputtext.setHTML()'); 
    }
}

/**
  * setText sets the text of the field to display
  * @param String t: the string to which to set the text
  */
override function setText ( t, force = null){
    // force to a string
    t += '';
    if (this.maxlength != null && t.length > this.maxlength){
        t = t.substring(0, this.maxlength);
    }
    this.sprite.setText(t);
    this.text =  t;
    // [todo 2006-06 hqm] when should we send onwidth and onheight events?

    // recalculate height
    if (this.height < 9 || this.sizeToHeight) {
        this.height = this.sprite.getTextfieldHeight();
        if (this.onheight.ready) this.onheight.sendEvent();
        if (this.height > 0) {
            this.setHeight(this.height);
        }
    }

    if (this.ontext.ready) this.ontext.sendEvent(t);
}

override function getText ( ){
    return this.sprite.getText();    
}

/** 
  * this attribute control the LzText::selectable attribute trough its setter
  * @access private
  */
var _allowselectable=true;

/** 
  * cache true value of selectable
  * @access private
  */
var _selectable;

/** 
  * Catch all LzModeManager events
  * @access private
  */
function _modechanged(modalview) {
    // !modalview = "LzModeManager release a view" => so allowselectable
    if ( !modalview ) {
        this._setallowselectable(true);
    } else {
        // LzModeManager make modalview as modal
        // (modalview.nodeLevel > this.nodeLevel) = "This cannot be a child of the setted modal view"
        // so not allowselectable
        if ( modalview.nodeLevel > this.nodeLevel ) {
            this._setallowselectable( false );
        } else {
            // is this a child of the setted modal view
            var parentSeeking = this;

            do {
                parentSeeking = parentSeeking.parent;
            } while ( parentSeeking != canvas && parentSeeking != modalview );

            this._setallowselectable(parentSeeking != canvas);
        }
    }
}

/** 
  * update the selectable status based on cached value
  * @access private
  */
function _setallowselectable(value) {
    this._allowselectable = value;
    this.setSelectable( this._selectable );
}

/** 
  * @access private
  */
override function setSelectable(value) {
    this._selectable = value;
    // depending on allowselectable : the setted value or false !
    super.setSelectable( this._allowselectable ? value : false );
}

} // End of LzInputText

ConstructorMap[LzInputText.tagname] = LzInputText;


