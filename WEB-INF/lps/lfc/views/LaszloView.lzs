/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @affects lzview
  * @access public
  *
  * @topic LFC
  * @subtopic Views
  */

/**
  * <p>The <tagname>view</tagname> is the most basic viewable element in an
  * OpenLaszlo application. Anything that is displayed on the canvas is a view
  * or extends the view class. A view is a rectangle, which can be visible or invisible, and which can contain other views or display "resources" such as images,
  * .swf files, or other supported media. One view controls one
  * displayable resource. The view system is strictly hierarchical; that is, each <code>view </code> has
  *  a single parent but can have multiple children.
  * 
  * </p>
  * <p>
  * The following code shows one view nested inside another:</p>
  *   
  * <example class="code">
  * &lt;canvas height="50" width="500"&gt;
  *   &lt;view width="50" height="50" bgcolor="red"&gt;
  *     &lt;view width="30" height="30" bgcolor="blue"/&gt;
  *   &lt;/view&gt; 
  * &lt;/canvas&gt;</example>
  * 
  * <p><classname>LzView</classname> extends <classname>LzNode</classname>,
  * which is the fundamental abstract class of LZX.</p>
  * 
  * <p>For an introduction to views see the <a
  * href="${tutorials}">Laszlo tutorials</a>, particularly <a
  * href="${tutorials}laszlo_basics.html">OpenLaszlo Basics</a> and <a
  * href="${tutorials}views-tutorial.html">Introduction to Views</a>. For a more
  * rigorous explanation of views see the <a href="${dguide}">Application Developer's Guide</a>, particularly the <a
  * href="${dguide}views.html">Views</a> chapter.</p>
  * 
  * @shortdesc The most basic viewable element.
  * @lzxname view
  *
  * @initarg public Boolean clip: A boolean indicating that the view is masked
  * if true, the view applies setClip(true) to itself
  * @initarg public String stretches: A string specifying whether or not the view
  * should stretch its contents.  Values are <code>"width"</code>, <code>"height"</code> or <code>"both"</code>.
  * When stretching, the coordinate system of the contents is modified
  * so that the whole view will fit in the given dimensions.
  * If <code>stretches</code> is applied, <code>clip</code> would not be necessary.
  * @initarg public String resource: A string denoting the library resource to use for
  * this view. The default is usually 'theEmptyResource'
  *

  */
dynamic class LzView extends LzNode {

    /** @access private
      * @modifiers override 
      */
    function LzView ( parent:LzNode? = null , attrs:Object? = null , children:Array? = null, instcall:Boolean  = false) {
        super(parent,attrs,children,instcall);
    }

//static var tabindexcounter = 1000;

/** @access private
  * @modifiers override 
  */
static var tagname = 'view';
/** @access private */
  static var attributes = new LzInheritedHash(LzNode.attributes);
  // We add some more kludges to those in LzNode.  See #construct
  // where we override the LzNode setting
/** @access private */
  static var __LZdelayedSetters = new LzInheritedHash(LzNode.__LZdelayedSetters);
/** @access private */
  static var earlySetters = new LzInheritedHash(LzNode.earlySetters);


/** @access private
 * Just used to effect a type cast of immediateparent to LzView 
 */
    /** @access private */
    var _height:Number;
    /** @access private */
    var _width:Number;
    /** @access private */
    var _y:Number;
    /** @access private */
    var _x:Number;
    /** @access private */
    var __LZhaser;
    /** @access private */
    var __LZlayout

    /** @access private */
    var fontname;
    /** @access private */
    var _visible;
    /** @access private */
    var __LZstoredbounds;

    /** @access private */
    var __movecounter;
    /** @access private */
    var __mousecache;

    /** @access private */
    var __lzcheckframe;

    var playing = false;
    


/** Event called when this view adds a subview   
  * @access public
  * @lzxtype event
  */
var onaddsubview = LzDeclaredEvent;
/** @access private */
var onbgcolor = LzDeclaredEvent;
/** The onblur script is executed when an element loses focus either
  * by the pointing device or by tabbing navigation.
  * @lzxtype event
  * @access public
  */
var onblur = LzDeclaredEvent;
/** The onclick script is executed when the pointing device button is
  * clicked over an element.
  * @lzxtype event  
  * @access public
  */
var onclick = LzDeclaredEvent;
/** @access private */
var onclickable = LzDeclaredEvent;
/** The onfocus script is executed when an element receives focus
  * either by the pointing device or by tabbing navigation.
  * @lzxtype event  
  * @access public
  */
var onfocus = LzDeclaredEvent;   // From LzFocus
/** Sent onidle while view is playing its resource
  * @lzxtype event
  * @access public
  */   
var onframe = LzDeclaredEvent;

/** Event for changes to view's <attribute>height</attribute> property 
  * @lzxtype event
  * @access public
  */
var onheight = LzDeclaredEvent;
/** @lzxtype event
  * @access private
  */   
var onimload = LzDeclaredEvent;

/** The onkeyup script is executed when this view has the focus and a
  * key is released. This event is sent with the keycode for the key that 
  * went up.
  * @access public
  * @lzxtype event
  */
var onkeyup = LzDeclaredEvent;   // From LzFocus

/** The onkeydown script is executed when this view has the focus and
  * a key is pressed down.  Multiple key down events are sent for a
  * key that is held down.  If you want the script executed only
  * once, use onkeyup. This event is sent with the keycode for the key that is
  * down.
  * @access public
  * @lzxtype event
  */
var onkeydown = LzDeclaredEvent; // From LzFocus
/** Sent when the view sets its frame (resource number) to the last
  * frame. This can be used to find out when a streaming media clip is
  * done playing.
  * @lzxtype event
  * @access public
  */
var onlastframe = LzDeclaredEvent;
/** Send when the view finishes loading media.
  * @lzxtype event
  * @access public
  */
var onload = LzDeclaredEvent;

/** Sends a percentage (0-1) reflecting the amount of a media file that's been downloaded.
* @lzxtype event
  * @access public
  */
var onloadperc = LzDeclaredEvent;

/** Sent when there is an error loading the view's resource.
  * The argument sent with the event is the error string sent by the server.
  * @access public
  * @lzxtype event
  */
var onerror = LzDeclaredEvent;

/** Sent when the request to load media for the view times
  * out
  * @lzxtype event
  * @access public
  */
var ontimeout = LzDeclaredEvent;
/** The onmousedown script is executed when the pointing device button is
  * pressed over an element.
  * @access public
  * @lzxtype event
  */
var onmousedown = LzDeclaredEvent;

/** The onmouseout script is executed when the point device is moved
  * so that is is no longer over an element.
  * @lzxtype event
  * @access public
  */
var onmouseout = LzDeclaredEvent;

/** The onmouseover script is executed when the pointing device is
  * moved onto an element.
  * @lzxtype event  
  * @access public
  */
var onmouseover = LzDeclaredEvent;

/** @access private 
  * @lzxtype event 
  */
var onmousetrackover = LzDeclaredEvent;

/** @access private 
  * @lzxtype event 
  */
var onmousetrackup = LzDeclaredEvent;

/** The onmouseup script is executed when the pointing device button is
  * released over an element.
  * @lzxtype event
  * @access public
  */
var onmouseup = LzDeclaredEvent;

/** 
  * Sent when a view changes its opacity 
  * @lzxtype event
  * @access public
  */
var onopacity = LzDeclaredEvent;

/**
 * Sent when a view begins playing its resource
  * @lzxtype event 
  * @access public
  */
var onplay = LzDeclaredEvent;

/** 
  * Event called when this view removes a subview 
  * @lzxtype event
  * @access public
  */ 
var onremovesubview = LzDeclaredEvent;

/** @access private 
  * @lzxtype event 
  */
var onresource = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var onresourceheight = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var onresourcewidth = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var onrotation = LzDeclaredEvent;
/**
  * Sent when a view's resource that is capable of playing is
  * stopped. This is only called if stop is called directly; when a resource
  * hits its last frame, the LzView event onlastframe is called.
  * @access public
  * @lzxtype event 
  */
var onstop = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var ontotalframes = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var onunstretchedheight = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var onunstretchedwidth = LzDeclaredEvent;

/** Sent when the view changes visibility (true/false)
  * @lzxtype event
  * @access public
  */
var onvisible = LzDeclaredEvent;

/** @access private 
  * @lzxtype event 
  */
var onvisibility = LzDeclaredEvent;

/** event for changes to view's <attribute>width</attribute> property 
 * @lzxtype event 
 * @access public
 */
var onwidth = LzDeclaredEvent;

/** event for changes to view's <attribute>x</attribute> property 
 * @lzxtype event
  * @access public
 */
var onx = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var onxoffset = LzDeclaredEvent;

/** event for changes to view's <attribute>y</attribute> property 
  * @lzxtype event
  * @access public
  */
var ony = LzDeclaredEvent;
/** @access private 
  * @lzxtype event 
  */
var onyoffset = LzDeclaredEvent;

/**
  * The ondblclick script is executed when the pointing device button
  * is double clicked over an element.
  *
  * @devnote Sent when the mouse is doubleclicked over the view,
  * but only if anyone is listening for the event. A view which is clicked
  * twice in rapid succession, but has no delegates registered for its
  * ondblclick event, will simply send two click events.
  * The view's doubleclick time can be adjusted by setting its
  * DOUBLE_CLICK_TIME attribute
  * @access public
  * @lzxtype event
  */
var ondblclick = LzDeclaredEvent;
/** @access private */
var DOUBLE_CLICK_TIME = 500;

// TODO [hqm 2008-03] Will asking for LzSprite.prototype.xxx  work in SWF9?
if ($swf9) {
    /** @access private */
    var capabilities = LzSprite.capabilities;
} else {
    /** @access private */
    var capabilities = LzSprite.prototype.capabilities;
}

/**
  * Base level constructor for views. See LzNode.<method
  * classname="LzNode">construct</method> for more on this.
  * @param LzView parent: Parent view to attach to
  * @param Object args: Initialization args
  * @access private
  */
override function construct ( parent , args) {
    //this.callInherited( "construct" , arguments.callee , parent ,args );
    super.construct( (parent ? parent : canvas), args );

    // Set applyArgs ordering kludges.  Overriding those of LzNode
    this.__LZdelayedSetters = LzView.__LZdelayedSetters;
    this.earlySetters = LzView.earlySetters;

  
    var ip = this.immediateparent;

    var vip:LzView = (this.immediateparent cast LzView);

    // TODO [hqm 2008-03] this was not needed in dhtml/swf8, in what
    // case is immediateparent coming up null in swf9?
    if (ip) {
        this.mask = ip.mask;
    }    

    this.__makeSprite(args);

    //this.__LZdepth = ip.__LZsvdepth++;
    //this.__LZsvdepth = 0;

    if ( 'width' in args ){
        this.hassetwidth = true;
        this.__LZcheckwidth = false;
    }
    if ( 'height' in args ){
        this.hassetheight = true;
        this.__LZcheckheight = false;
    }

    if ('clip' in args && args['clip'] && (! (args.clip instanceof LzInitExpr)) ){
        this.clip = args.clip;
        this.makeMasked();
    }
    if ('stretches' in args && args['stretches'] != null && (! (args.stretches instanceof LzInitExpr)) ){
        this.$lzc$set_stretches(args.stretches);
        args.stretches = LzNode._ignoreAttribute;
    }
    if (args['resource'] != null && (! (args.resource instanceof LzInitExpr)) ){
        this.$lzc$set_resource( args.resource );
        args.resource = LzNode._ignoreAttribute;
    }
    if($debug){
        if(args['valign'] && args['y']){
            Debug.warn("y attribute ignored; superseded by valign constraint.");
        }
        if(args['align'] && args['x']){
            Debug.warn("x attribute ignored; superseded by align constraint.");
        }
    }
}

/** Receive attribute/event change from sprites
  * @param String attrname: Attribute name
  * @param value: Value to set to
  * @access private
  */
function __spriteAttribute(attrname:String, value){
    if (this[attrname]) this.setAttribute(attrname, value);
}

/**
  * Called to create the sprite object.  May be overridden to use a specific 
  * version, e.g. LzTextSprite();
  * @access private
  */
function __makeSprite(args) {
    //trace('LzView.__makeSprite', args);
    this.sprite = new LzSprite(this, false, args);
}

/**
  * Called right before the view is shown. See <method
  * classname="LzNode">init</method> for more.
  * 
  * @access public
  */
override function init( ) {
    if (this.sprite) {
        this.sprite.init(this.visible);
    } else {
        // TODO [hqm 2008-03] I put this in for a bug I was seeing
        // swf9, need to see if it is still happening
        Debug.warn("LzView init method called and this.sprite is null", this);
    }
}


/**
  * Called when a subview is added to the view.
  * @access private
  * @param LzView s: The new subview
  */
function addSubview ( s ){
      if (this.sprite) {
          this.sprite.addChildSprite(s.sprite);
      } else {
          // TODO [hqm 2008-03] I put this in for a bug I was seeing
          // swf9, need to see if it is still happening
          Debug.warn("LzView.addSubview called when this.sprite is null", this);
      }

    if ( s.addedToParent ) return;

    // Don't use the prototype's default subviews array, it is a
    // sentinel which lives on the prototype and is shared by all
    // instances, make a new one if you want to push a view.
    if (this.subviews.length == 0) {
        // Make our own subviews array instance.
        this.subviews = [];
    }
    this.subviews.push( s );

    s.addedToParent = true;

    if (this.__LZcheckwidth)
        this.__LZcheckwidthFunction( s );
    if (this.__LZcheckheight)
        this.__LZcheckheightFunction( s );
    
    if (this.onaddsubview.ready) this.onaddsubview.sendEvent( s );
}

/**
  * Called when the view itself and all its children have finished
  * instantiating.
  * @access private
  */
override function __LZinstantiationDone (){
    var vip:LzView = (this.immediateparent cast LzView);
    if (vip) {
        (vip).addSubview( this );
    } else {
        // TODO [hqm 2008-03] This is to trace a bug of null immediateparent seen in swf9 initialize
        Debug.warn("LaszloView.__LZinstantiationDone immediateparent = null", this);
    }

    //this.callInherited( '__LZinstantiationDone' , arguments.callee );
    super.__LZinstantiationDone.apply(this, arguments);
}

/** Reference to closest masked view in the hierarchy at or above
  * this one
  * @type LzView
  * @keywords readonly
  */
var mask;

/** If true, this view will receive focus events.
  * See focus manager (LzFocus) for more details.
  * @type Boolean
  * @lzxtype boolean
  * @keywords readonly
  */
var focusable = false;

/** If true, this view "traps" the focus, for example in a window or dialog.
  * See focus manager (LzFocus) for more details.
  * @lzxtype boolean
  */
var focustrap;

/** Clip the view's contents to its size.
  * @lzxtype boolean
  * @lzxdefault "false"
  * @keywords final
  */
var clip = false;
/** @access private */
var $lzc$set_clip =  -1;
/** @access private */
function $lzc$set_x(v) { this.setX(v) }
/** @access private */
function $lzc$set_y(v) { this.setY(v) }


/** @access private */
function $lzc$set_rotation(v) { this.setRotation(v); }
/** @access private */
function $lzc$set_opacity(v) { this.setOpacity(v); }
/** @access private */
function $lzc$set_alpha(v) { this.setOpacity(v); }
/** @access private */
function $lzc$set_visibility(v) { this.setVisibility(v) }

/**
  * @lzxtype "left" | "center" | "right" | constraint
  * @lzxdefault "left"
  * @keywords final
  */
var align = "left";
/** @access private */
function $lzc$set_align(v) { this.setAlign(v) }

/**
  * Creates a constraint on the view's y position which is a function
  * of its height and its parent's height. The default for this is
  * "top".
  * @lzxtype "top" | "middle" | "bottom" | constraint
  * @lzxdefault "top"
  */
var valign = "top";
/** @access private */
function $lzc$set_valign(v) { this.setValign(v) }

/** The URL from which to load the resource for this
  * view.  If this attribute is set, the media for the view is loaded
  * at runtime.
  * @type String
  * @lzxtype expression
  * @access public
  */
var source;
/** 
  * As a setter, this is private. It's not really a setter, because
  * it talks to a private attribute, "source". 
  * The method setSource, defined below, is public, but it's not
  * a setter. [bshine 2007.11.07]
  * @access private 
  */ 
function $lzc$set_source(v) { this.setSource(v); }
/** The background color of the canvas. 
  * @lzxtype token
  */
function $lzc$set_bgcolor(v) { this.setBGColor(v) }

/** If true, this view intercepts click events; otherwise they are passed
  * to its container.  This defaults to true if the view defines a mouse
  * event handler or a cursor.
  * @lzxtype boolean
  * @access private
  */
function $lzc$set_clickable(v) { this.setClickable(v); }
/** Setting clickRegion to a vector-based SWF turns the SWF shape into a clickable hotspot.
  * @access public
  * @lzxtype string
  */
var clickregion;   
/** @access private */
function $lzc$set_clickregion(v) { this.__LZsetClickRegion(v); }
/** The cursor to display when the mouse is over this view. Any
  * resource can be used as a cursor. This attribute can be set for
  * any view with clickable=true, or any view whose class defaults
  * clickable to true.
  * @lzxtype token
  */
var cursor;  
/** @access private */
function $lzc$set_cursor(v) { this.setCursor(v); }
/** A color to use to render object that appears inside this view,
  * which includes any vector or bitmap art in the view's resource
  * and any contained views.
  * @lzxtype color
  */
var fgcolor;   
/** @access private */
function $lzc$set_fgcolor(v) { this.setColor(v); }
/** The font to use for any @c{&lt;text>} or @c{&lt;inputtext>} elements that
  * appear inside this view. Like all the font properties
  * (<code>fontstyle</code> and <code>fontsize</code> too) these
  * properties cascade down the view hierarchy until a new value is
  * specified. When the font attributes are modified at runtime,
  * using JavaScript, the font is changed for the view itself, not
  * for any of its subviews.
  * @lzxtype string
  */
var font;  
/** @access private */
function $lzc$set_font(v) { this.setFontName(v) ; }

/** The style to use to render text fields that appear inside of
  * this view. One of "plain", "bold" , "italic" or "bolditalic".
  * @lzxtype string
  */
var fontstyle;

/** Pixel size to use to render text which appears inside this
  * view. The default is 8.
  * @lzxtype size
  */
var fontsize;

/**
  * Setting <code>stretches</code> causes a view to change its
  * coordinate space so that everything it contains (resources and
  * other views) fit exactly into the view's width and/or height. The
  * default for this property is "none". This is used to resize a
  * view's contents by setting its width and/or height.
  * @lzxtype "width" | "height" | "both"
  * @lzxdefault "none"
  */
var stretches = "none"; 
/** @access private */
function $lzc$set_play(v) { this.setPlay(v); }
/** Show or hide the handcursor for this view, if clickable 
  * @access private */
function $lzc$set_showhandcursor(v) { this.setShowHandCursor(v); }

/** A CSS property when declared in the tag: value sequence of layout
  * parameters, which are used to create a layout that is attached to
  * this view. If there is a class property, it names the class of the
  * layout; otherwise <tagname>simplelayout</tagname> is used.
  * Examples: 
  * <code>axis: x</code>, <code>class: constantlayout</code>; 
  * <code>axis: y</code>; <code>axis: x; spacing: 5</code>.
  * @type Object
  * @lzxtype css
  * @access public
  */
var layout; 
/** @access private */
function $lzc$set_layout(v) { this.setLayout(v); }

/** Activate/inactivate children for accessibility
  * @type Boolean
  * @lzxtype boolean
  */
var aaactive; 
/** @access private */
function $lzc$set_aaactive(v) { this.setAAActive(v); }
/** Set accessibility name
  * @type String
  * @lzxtype string
  */
var aaname;
/** @access private */
function $lzc$set_aaname(v) { this.setAAName(v); }
/** Set accessibility description
  * @type String
  * @lzxtype string
  */
var aadescription; 
/** @access private */
function $lzc$set_aadescription(v) { this.setAADescription(v); }
/** Set accessibility tab order
  * @type Number
  * @lzxtype number
  */
var aatabindex;   
/** @access private */
function $lzc$set_aatabindex(v) { this.setAATabIndex(v); }
/** Set accessibility silencing/unsilencing
  * @type Boolean
  * @lzxtype boolean
  */
var aasilent; 
/** @access private */
function $lzc$set_aasilent(v) { this.setAASilent(v); }

LzView.__LZdelayedSetters.layout = "$lzc$set_layout";
LzView.earlySetters.clickregion = 7;
LzView.earlySetters.stretches = 8;

/** 
  * @type Number
  * @access private 
  */
function $lzc$set_xoffset(v) { this.setXOffset(v); }
/**
  * @access private 
  * @type Number
  */
function $lzc$set_yoffset(v) { this.setYOffset(v); }

/** @access private */
var sprite:LzSprite = null;

/** A value of true means that this view is shown. A
  * value of false means that this view is hidden.
  * Note that an otherwise clickable view that is not visible will have no click
  * region and will not be clickable. 
  * @type Boolean
  * @lzxtype boolean
  * @lzxdefault "true"
  */
var visible =   true;

/** A value of "visible" means that this view is shown. A
  * value of "hidden" means that this view is hidden. Setting this attribute to "collapse"
  * means that the runtime will hide this view when: its opacity is zero, it has a
  * datapath that does not match a node, or it is loading its media. In this
  * case, the the value of the 'visible' attribute of the view will reflect the view's
  * current visible state. 
  * @type String
  * @lzxtype string
  * @lzxdefault "collapse"
  */
var visibility = "collapse";

/** @access private */
var __LZvizO = true;

/** @access private */
var __LZvizLoad= true;

/** 
  * The opacity of the view's contents. @c{1.0} is opaque; @c{0.0} is
  * totally transparent (invisible).
  * @lzxtype opacity
  * @lzxdefault "1.0"
  */
var opacity =   1;
/** The color of background of this view. Null if there is
  * no bgcolor. A number from 0 - 0xFFFFFF.
  * @lzxtype color
  */
var bgcolor =   null;
/** The horizontal offset of this view's upper left corner from the
  * upper left corner of its container.
  * @type Number
  * @lzxtype numberExpression
  * @lzxdefault "0"
  */
var x =   0;
/** The vertical offset of this view's upper left corner from the
  * upper left corner of its container
  * @type Number
  * @lzxtype numberExpression
  * @lzxdefault "0"
  */
var y =   0;
/** The rotation value for the view (in degrees).
  * Value may be less than zero or greater than 360.
  * @type Number
  * @lzxtype numberExpression
  * @lzxdefault "0"
  */
var rotation =   0;

/**
  * The width of the view
  * @access public
  * @type Number
  * @lzxtype sizeExpression
  */
var width =   0;
/** @access private */
function $lzc$set_width(v) { this.setWidth(v); }

/**
  * The height of the view
  * @access public
  * @type Number
  * @lzxtype sizeExpression
  */
var height =   0;
/** @access private */
function $lzc$set_height(v) { this.setHeight(v); }

/** If stretches is not set to none, the width
  * that this view would be if it weren't stretched. This attribute can be used
  * to scale a view by a percentage of its original size, or to determine the
  * aspect ratio for a view.
  * @type Number
  * @keywords readonly
  */
var unstretchedwidth =   0;
/** If stretches is not set to none, the height
  * that this view would be if it weren't stretched. This attribute can be used
  * to scale a view by a percentage of its original size, or to determine the
  * aspect ratio for a view.
  * @type Number
  * @keywords readonly
  */
var unstretchedheight =   0;
/** An array of the subviews that are children of this
  * view. This is initialized to an empty array for views that have no subviews.
  * @keywords readonly
  */
var subviews =   [];
/** @access private */
var __LZclickregion =  "LzMouseEvents";

/**
  * Specifies a translation point for drawing of this view. If the xoffset
  * is set, then rotation and x position will be calculated by first adding
  * the xoffset.
  * @lzxtype numberExpression
  * @lzxdefault "0"
  */
var xoffset =   0;
/**
  * Specifies a translation point for drawing of this view. If the yoffset
  * is set, then rotation and y position will be calculated by first adding
  * the yoffset.
  * @lzxtype numberExpression
  * @lzxdefault "0"
  */
var yoffset =   0;
/** @access private */
var __LZrsin = 0;
/** @access private */
var __LZrcos = 1;
/** @access private */
var __LZcaloffset = false;

/** @access private */
var _xscale =   1;
/** @access private */
var _yscale =   1;

/** The total number of frames for this view's resource.
  * @type Number
  * @keywords readonly
  */
var totalframes =   0;
/** If this view has a multi-frame resource, this allows setting which
  * resource frame is displayed.  Defaults to the first frame (1).
  * @lzxtype numberExpression
  * @lzxdefault "0"
  * @devnote See also the <attribute>resource</attribute>
  * attribute.  Setting this attribute will change the frame that is
  * being displayed by the resource associated with this view. The
  * first frame of the resource is frame 0.  Setting a view's
  * 'donttrackplay' option to true will allow the view's resource to
  * play without updating the value of the view's frame property. This
  * can save CPU usage in cases where the application doesn't need to
  * know what frame the resource is showing while it is playing.
  */
var frame =   0;
/** @access private */
function $lzc$set_frame(v) { this.setResourceNumber(v); }

/** @keywords deprecated 
  * @access private 
  */
var loadperc =   0;
/** For views whose resource is loaded at runtime,
  * the ratio of the loaded frames to the total frames. This is a number between
  * zero and 1.
  * @type Number
  * @keywords readonly
  */
var framesloadratio =   0;
/** For views whose resource is loaded at runtime,
  * ratio of the loaded bytes to the total bytes. This is a number between 
  * zero and 1.
  * @type Number
  * @keywords readonly
  */
var loadratio =   0;

/** If true, then setWidth() has been called on this
  * view, and the view will not be sized to its contents. 
  * @type Boolean
  * @keywords readonly  
  */
var hassetheight = false;
/** If true, then setHeight() has been called on this
  * view, and the view will not be sized to its contents. 
  * @type Boolean
  * @keywords readonly  
  */
var hassetwidth = false;

/** need quick check for viewness
  * @access private 
  */
var __LZisView = true;

//
// field selected: Setting this attribute calls the abstract method
// <method>setSelected</method>.  See
// <classname>LzSelectionManager</classname>.
// @access private
//
//============================================================================
/** @access private */
var addedToParent = null;
/** @access private */
var checkPlayStatusDel = null;
/** @access private */
var masked = false;

/**
  * The view system supports sub-pixel positioning to enable smooth
  * animation. This may be turned off to make the view snap to a
  * pixel boundary by setting pixellock to true.
  * @lzxtype booleanLiteral
  * @modifiers final
  */
var pixellock = null;
/** @access private */
var setButtonSize = null;

/** If true, this view intercepts click events; otherwise they are passed
  * to its container.  This defaults to true if the view defines a mouse
  * event handler or a cursor.
  * @lzxtype boolean
  */ 
var clickable = false;

/** Show or hide the hand cursor for this view, if clickable
  * @lzxtype boolean
  */
var showhandcursor = null;
/** @access private */
var updatePlayDel = null;
/**
  * A resource that is presented in the background of this view.  The
  * value can be either the name of a resource defined with the
  * <tag>resource</tag> tag, a URL, or a pathname.  If the value is a URL,
  * the resource is requested when the view is displayed.  If it's a
  * pathname, the file named by the pathname is compiled into the
  * application, and attached to this view.
  * @lzxtype string
  */
var resource:String = null;

/**
  * The width of the resource that this view attached
  * @keywords readonly
  * @lzxtype number
  */
var resourcewidth = null;
/**
  * The height of the resource that this view attached
  * @keywords readonly
  * @lzxtype number
  */
var resourceheight = null;

/** @access private */ var __LZbgColorO = null;
/** @access private */ var __LZbgRef = null;
/** @access private */ var __LZbuttonRef = null;
/** @access private */ var __LZcheckwidth = true;
/** @access private */ var __LZcheckheight = true;
/** @access private */ var __LZhasoffset = null;
/** @access private */ var __LZisBackgrounded = null;
/** @access private */ var __LZmaskClip = null;
/** @access private */ var __LZmovieClipRef = null;
/** @access private */ var __LZoutlieheight = null;
/** @access private */ var __LZoutliewidth = null;
/** @access private */ var __LZsubUniqueNum = null;

/**
  * this creates a specific child layout for this view. When called a second time
  * the first layout will be replaced by the second.
  * @param Object layoutobj: A dictionary of attributes that describe the
  * layout, where the class key specifies the class of the layout and the
  * rest are passed as attributes for the layout.  By default the class will
  * be <api>simplelayout</api> if not given.
  * For example: <code>{'class': 'wrappinglayout', axis: 'x', spacing: 20}</code>
  * To remove the previously set layout, use <code>{'class': 'none'}</code>
  * (Note that you must use <code>'class'</code> as the key, because
  * <code>class</code> is a keyword reserved for future use.)
  */
function setLayout ( layoutobj ){

    if (!this.isinited) {
        this.__LZstoreAttr( layoutobj , "layout" );
        return;
    }


    var classname = layoutobj['class'];
    
    if ( classname == null) {
        classname = 'simplelayout';
    }
    
    if ( this.__LZlayout ){
        this.__LZlayout.destroy();
    }
    if (classname != 'none') {
        var o = {};
        for (var i in layoutobj) {
           if (i != 'class')  {
               o[i] = layoutobj[i];
           }
        }

        if (classname == 'null') {
            // FIXME [2006.09.25 bshine] (LPP-2759) This bogus check can be 
            // removed when the underlying bug is fixed
            // FIXME [2006.09.25 max] (LPP-2759) Actually, 
            // laszlo-explorer/explore-nav.lzx counts on this failing 
            // silently in the swf runtime - return here instead.
            this.__LZlayout = null;
            return;
        }    
        this.__LZlayout = new ConstructorMap[ classname ] (this, o);
   }
 }

/**
  * Sets the font name for this view. The font information (font, fontsize, and
  * fontstyle) will cascade down the runtime view hierarchy.
  * @access private
  * @param String val: The value for the new font name
  */
function setFontName ( val ,prop = null){
    this.fontname = val ;
    // Canvas has no sprite
    if (! this.sprite) {
      return;
    }
    this.sprite.setFontName(val, prop);
}

/** If true, the view does not set its
  * resource to the width given in a call to
  * <method>setAttribute</method>. By default, views do not scale their
  * resource
  * @type Boolean
  * @access private
  */
var _setrescwidth = false;
/** If true, the view does not set its
  * resource to the height given in a call to
  * <method>setAttribute</method>. By default, views do not scale their
  * resource
  * @type Boolean
  * @access private
  */
var _setrescheight = false;

/**
  * Search all subviews for a named property. For now, returns when it finds the
  * first one. This is a width first search.
  * 
  * @param String prop: named property
  * @param val: value for that property
  * @return LzView: the first subview whose property <param>prop</param> is set to val 'val' or null
  * if none is found
  */
function searchSubviews ( prop , val) {
    var nextS = this.subviews.concat();

    while ( nextS.length > 0  ){
        var s = nextS;
        nextS = new Array;
        for (var i = s.length-1; i >=0; i-- ){
            var si = s[ i ];
            if (si[ prop ] == val ){
                return si;
            }
            var sis = si.subviews;
            for (var j = sis.length - 1; j>=0; j-- ){
                nextS.push( sis[j] );
            }
        }
    }
    return null;
}

/** @access private */
function searchimmediateparents ( prop ){
    if ( $debug ){
      Debug.deprecated(this, arguments.callee, this.searchParents);
    }

    return this.searchParents( prop );
}

/** A CSS sequence of layout parameters in 'property: value' form.
  * These values are used to create a layout that is attached to this view.
  * If there
  * is a class property, it names the class of the layout; otherwise
  * <tagname>simplelayout</tagname> is used.  If the value of this attribute is a single
  * id, it is used as the axis attribute of a simplelayout.
  * Examples: <code>axis: x</code>, <code>class: constantlayout</code>; 
  * <code>axis: y</code>; <code>axis: x; spacing: 5</code>.
  * @type Object
  * @lzxtype css
  * @access public
  */
var layouts = null;


/**
  * Releases all the layouts applied to this view.
  * @deprecated
  */
function releaseLayouts( ) {
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    if (this.layouts) {
        for ( var i = this.layouts.length - 1; i >= 0; i-- ){
            this.layouts[ i ].releaseLayout();
        }
    }
}

/**
  * @access private
  * Can be nulled by unload() to allow the same resource to be loaded again with setResource()
  */
var _resource = null;

/**
  * This method associates a view with a named library element. If the
  * view's <attribute>isVisible</attribute> property is true, the
  * resource will be displayed when it is attached
  * 
  * @deprecated Use setAttribute('resource', ...) instead.
  * @param String resourceName: a string naming the id of the resource to attach
  */
function setResource(v) {
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    this.$lzc$set_resource(v);    
}

/** @access private */
function $lzc$set_resource( resourceName ) {
    if (resourceName == null || resourceName == this._resource) return;
    this.resource = this._resource = resourceName;

    if (resourceName != 'empty') this.sprite.setResource(resourceName);
    
    this.__LZhaser = resourceName == "empty";

    if (this.onresource.ready) this.onresource.sendEvent( resourceName );
}

/**
  * @access private
  * Called by sprites when the resource has been loaded to send the
  * appropriate events
  */
function resourceload(i) {
    if ('resource' in i) {
        this.resource = i.resource;
        if (this.onresource.ready) this.onresource.sendEvent(i.resource);
    }

    if (this.resourcewidth != i.width) {
        if ('width' in i) {
            this.resourcewidth = i.width;
            if (this.onresourcewidth.ready) this.onresourcewidth.sendEvent(i.width);
        }

        //if no setwidth, then the view is sized to the resource
        if ( (!this.hassetwidth && this.resourcewidth != this.width ) ||
            (this._setrescwidth && this.unstretchedwidth !=
                                                    this.resourcewidth)){
            this.updateWidth( this.resourcewidth  );
        }
    }

    if (this.resourceheight != i.height) {
        if ('height' in i) {
            this.resourceheight = i.height;
            if (this.onresourceheight.ready) this.onresourceheight.sendEvent(i.height);
        }

        if ( (!this.hassetheight && this.resourceheight != this.height ) ||
             (this._setrescheight && this.unstretchedheight != this.resourceheight)){
            this.updateHeight( this.resourceheight  );
        }
    }

    if (i.skiponload != true) {
        if (this.onload.ready) this.onload.sendEvent(this);
    }
}

/**
  * @access private
  * Called by the sprite when the resource load error occurs 
  */
function resourceloaderror() {
    this.resourcewidth = 0;
    this.resourceheight = 0;
    if (this.onresourcewidth.ready) this.onresourcewidth.sendEvent(0);
    if (this.onresourceheight.ready) this.onresourceheight.sendEvent(0);
    this.reevaluateSize();
    if (this.onerror.ready) this.onerror.sendEvent();
}

/**
  * @access private
  * Called by the sprite when the resource load timeout occurs 
  */
function resourceloadtimeout() {
    this.resourcewidth = 0;
    this.resourceheight = 0;
    if (this.onresourcewidth.ready) this.onresourcewidth.sendEvent(0);
    if (this.onresourceheight.ready) this.onresourceheight.sendEvent(0);
    this.reevaluateSize();
    if (this.ontimeout.ready) this.ontimeout.sendEvent();
}

/**
  * @access private
  * Called by the sprite when the resource playback events occur
  */
function resourceevent(name, value, eventonly) {
    if (eventonly != true) this[name] = value;
    var ev = this['on'+ name];
    if (ev.ready) ev.sendEvent(value);
}

/**
  * This method is called to set the number of total frames in the resource.
  * The ontotalframes event is generated
  * 
  * @param Number n: The total number of frames in the resource
  * @access private
  */
function setTotalFrames (n) {
    if ((n != null) && (this.totalframes != n)) {
        this.totalframes = n;
        if (this.ontotalframes.ready) this.ontotalframes.sendEvent( this.totalframes );
    }
}

/**
  * This method should remove a view, its media, and any of its subviews.
  * @access private
  * 
  */
override function destroy( ){
    if ( this.__LZdeleted ) return;
    
    if (this.sprite) this.sprite.predestroy();

    var vip:LzView = (this.immediateparent cast LzView);
    if ( this.addedToParent ){
        var svs =  vip.subviews;
        if (svs != null) {
            for( var i = svs.length - 1; i >= 0; i-- ){
                if ( svs[ i ] == this ){
                    svs.splice( i , 1 );
                    break;
                }
            }
        }
    }

    super.destroy.apply(this);

    if (this.sprite) { this.sprite.destroy() }

    //this.__LZFinishDestroyOnIdle();

    this.$lzc$set_visible ( false );

    var vip:LzView = (this.immediateparent cast LzView);
    if ( this.addedToParent ) {
        if ( vip['__LZoutliewidth'] == this) {
            vip.__LZoutliewidth = null;
        }

        if ( vip['__LZoutlieheight'] == this) {
            vip.__LZoutlieheight=null;
        }

        if ('onremovesubview' in vip) {
            if (vip.onremovesubview.ready) {
                vip.onremovesubview.sendEvent( this );
            }
        }
    }
}

/*
// @access private
function __LZFinishDestroyOnIdle (){
    if ( this.__LZmovieClipRef != null ){
        //Debug.write( "remove movieclip" );
        removeMovieClip( this.__LZmovieClipRef );
        delete this.__LZmovieClipRef;
    }

  if ( this.__LZbgRef != null ){
    removeMovieClip( this.__LZbgRef );
    delete this.__LZbgRef;
  }
}
*/

/**
  * This method sets the <attribute>visible</attribute> attribute of the view
  * and also disables or re-enables any click region associated with the view.
  * 
  * @param Boolean|Null v: Controls the visibility of a view.
  * `true` makes the view visible, `false` makes the view hidden,
  * `null` will make the view visible only if it has a data binding.
  * @deprecated Use setAttribute('visible', ...) instead.
  */
function setVisible(v) { 
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    this.$lzc$set_visible(v)
}

/** @access private */
function $lzc$set_visible( amVisible ) {
    if (this._visible == amVisible) return;
    this._visible = amVisible;

    // make us compatible with the new 'visibility' attribute
    if (amVisible) {
        var v = "visible";
    } else if (amVisible == null) {
        if ($debug) {
          Debug.info("%w.%s(%w) is deprecated.  Perhaps you meant %w.%s(%s)?  If not, use %w.%s('collapse').",
                     this, arguments.callee, amVisible, this, arguments.callee, false, this, this.setVisibility);
        }
        var v = "collapse";
    } else {
        var v = "hidden";
    }
    this.visibility = v;

    if (this.onvisibility.ready) this.onvisibility.sendEvent( this.visibility );
    this.__LZupdateShown();
}

/**
  * This method sets the <attribute>visibility</attribute> attribute of the view
  * and also disables or re-enables any click region associated with the view.
  * 
  * The argument is a string which can be "visible", "hidden", or "collapse". This
  * corresponds somewhat with the 
  *
  * Setting the value to "collapse" will cause the view to become hidden when it has
  * a datapath and there are no matching data nodes in its dataset.
  *
  * @param String amVisible: visibility of view
  * @access private
  */
function setVisibility( amVisible ) {
    if (this.visibility == amVisible) return;
    this.visibility = amVisible;
    if ($debug) {
        if (! (amVisible == "visible" || amVisible == "hidden" || amVisible == "collapse")) {
          Debug.error("%w.%s called with unknown arg '%s' use 'visible', 'hidden', or 'collapse'.",
                      this, arguments.callee, amVisible);
        }
    }
    if (this.onvisibility.ready) this.onvisibility.sendEvent( amVisible );
    this.__LZupdateShown();
}
    
/**
  * TODO: max : should be made private, api call from replication should be cleaner
  * @access private
  */
override function __LZupdateShown( ) {
    if ( this.visibility == "collapse" ){
        var shown = this.__LZvizO && this.__LZvizDat && this.__LZvizLoad;
    } else {
        var shown = (this.visibility == "visible");
    }

    if ( shown != this.visible ){
        this.visible = shown;

        // FIXME: [hqm 2006-09] How do we end up with a null sprite? Some destroy ordering thing?
        if (this.sprite ) {
            this.sprite.setVisible(shown);
        }

        var vip:LzView = (this.immediateparent cast LzView);
        if (vip && vip.__LZcheckwidth)
            vip.__LZcheckwidthFunction( this );
        if (vip && vip.__LZcheckheight)
            vip.__LZcheckheightFunction( this );

        if (this.onvisible.ready) this.onvisible.sendEvent( shown );
    }
}

/**
  * Sets the width of the view. If the view is set to stretch its resource, the
  * resource will be resized to the new value. If the value 'null' is given for
  * the new width, then the width is unset, and the width of the view will be
  * the size of its contents.
  * @param Number v: The new value for the width
  */
function setWidth ( v ){
    if (this._width != v) {
        this._width = v;
        this.sprite.setWidth(v);

        if ( v == null ){
            this.hassetwidth = false;
            // expose proto method
            this.__LZcheckwidth = true;
            if ( this._setrescwidth ){
                // will be updated by reevaluateSize
                this.unstretchedwidth = null;
                // defaults
                this._xscale = 1;
                //this.__LZmovieClipRef._xscale =  100;
            }
            this.reevaluateSize( 'width' );
            return;
        }
        this.width = v;
        if ( this.pixellock ) v = Math.floor( v );
        if ( this._setrescwidth ){
        var xscale = this.unstretchedwidth == 0 ? 100 : v/this.unstretchedwidth;
        this._xscale = xscale;
        //this.__LZmovieClipRef._xscale = xscale * 100;
        } else {
            this.__LZcheckwidth = false;
        }
        
        this.hassetwidth = true;
        
        //this.__LZbgRef._xscale = v;

        var vip:LzView = (this.immediateparent cast LzView);
        if (vip && vip.__LZcheckwidth)
            vip.__LZcheckwidthFunction( this );


        if (this.onwidth.ready) this.onwidth.sendEvent( v );
    }
}

    /**
    * Sets the height of the view the given value. If the view is set to stretch
    * its resource, the resource will be resized to the new value. If the value
    * 'null' is given for the new height, then the height is unset, and the height
    * of the view will be the size measured of its contents.
  * @param Number v: The new value for the height
  */
function setHeight ( v ){
    if (this._height != v) {
        this._height = v;
        this.sprite.setHeight(v);

        if ( v == null ){
            this.hassetheight = false;
            // expose proto method
            this.__LZcheckheight = true;

            if ( this._setrescheight ){
                // will be updated by reevaluateSize
                this.unstretchedheight = null;
                // defaults
                this._yscale = 1;
                //this.__LZmovieClipRef._yscale =  100;
            }
            this.reevaluateSize( 'height' );
            return;
        }
        this.height = v;
        if ( this.pixellock ) v = Math.floor( v );
        if ( this._setrescheight ){
            var yscale = this.unstretchedheight == 0 ? 100 : v/this.unstretchedheight;
            this._yscale = yscale;
            //this.__LZmovieClipRef._yscale = yscale * 100;
        } else {
            this.__LZcheckheight = false;
        }
        this.hassetheight = true;
        
        var vip:LzView = (this.immediateparent cast LzView);
        if (vip && vip.__LZcheckheight)
            vip.__LZcheckheightFunction( this );


        if (this.onheight.ready) this.onheight.sendEvent( v );
    }
}


/**
  * Sets the opacity for the view.  The opacity is a number between 0.0
  * (transparent) and 1.0 (opaque).
  * @param Number v: The new value for the opacity
  */
function setOpacity ( v ){
    if (this.capabilities.opacity) {
        this.sprite.setOpacity(v);
    } else if ($debug) {
        this.__warnCapability('view.setOpacity()'); 
    }
    this.opacity = v;
    if (this.onopacity.ready) this.onopacity.sendEvent( v );
    var coviz = this.__LZvizO;
    var newoviz = v != 0;
    if ( coviz != newoviz ){
        this.__LZvizO = newoviz;
        this.__LZupdateShown();
    }
}



/**
  * Sets the <attribute>x</attribute> position of the view to the given value.
  * @param Number v: The new value for <attribute>x</attribute>.
  */
function setX ( v, force = null){
    if (force || this._x != v) {
        this._x = v;
        this.x = v;
        if ( this.__LZhasoffset ){
            if (this.capabilities.rotation) {
                v -= ( this.xoffset * this.__LZrcos  -
                    this.yoffset * this.__LZrsin );
            } else {
                v -= this.xoffset;
            }
        }
        
        if ( this.pixellock ) v = Math.floor( v );
        this.sprite.setX(v)
        
        var vip:LzView = (this.immediateparent cast LzView);
        if (vip.__LZcheckwidth)
            vip.__LZcheckwidthFunction( this );
        if (this.onx.ready) this.onx.sendEvent( this.x );
    }
}


/**
  * Sets the <attribute>y</attribute> position for the view to the given value.
  * @param Number v: The new value for <attribute>y</attribute>.
  */
function setY ( v, force = null){
    if (force || this._y != v) {
        this._y = v;
        this.y = v;
        if ( this.__LZhasoffset ){
            if (this.capabilities.rotation) {
                v -= ( this.xoffset * this.__LZrsin  +
                    this.yoffset * this.__LZrcos );
            } else {
                v -= this.yoffset;
            }
        }
        
        if ( this.pixellock ) v = Math.floor( v );
        this.sprite.setY(v)
        var vip:LzView = (this.immediateparent cast LzView);
        if (vip.__LZcheckheight)
            vip.__LZcheckheightFunction( this );
        if (this.ony.ready) this.ony.sendEvent( this.y );
    }
}


/**
  * Sets the <attribute>rotation</attribute> for the view to the given value.
  * @param Number v: The new value for <attribute>rotation</attribute>.
  */
function setRotation ( v ){
    if (this.capabilities.rotation) {
        this.sprite.setRotation(v)
    } else if ($debug) {
        this.__warnCapability('view.setRotation()'); 
    }
    this.rotation = v;
    var rrad = Math.PI /180 * this.rotation;
    this.__LZrsin = Math.sin( rrad )
    this.__LZrcos = Math.cos( rrad )
    if (this.onrotation.ready) this.onrotation.sendEvent( v );

    if ( this.__LZhasoffset ){
        this.setX( this.x, true );
        this.setY( this.y, true );
    }

    var vip:LzView = (this.immediateparent cast LzView);
    if (vip.__LZcheckwidth)
        vip.__LZcheckwidthFunction( this );
    if (vip.__LZcheckheight)
        vip.__LZcheckheightFunction( this );
}

/**
  * Sets the <attribute>alignment</attribute> for the view to the
  * given value. The alignment is based on the size of this view as
  * compared to the size of the view's immediate parenbgRef.
  *
  * @param String align: The <attribute>alignment</attribute> for the
  * view. This is one of "left", "center", and "right"
  *
  * @devnote TODO: [2008-02-07 ptw] Apparently we never supported
  * 'onalign', should we?
  */
function setAlign ( align ){
  if (this.align == align) return;
  function map (align) {
    switch (align) {
      case "center": return "__LZalignCenter";
      case "right": return "__LZalignRight";
      case "left": return null;
      default:
        if ($debug) {
          Debug.error("%w.%s(%w): Invalid argument.  Valid choices are: 'left', 'center', or 'right'.",
                      this, arguments.callee, align);
        }
    }
  }
  var from = map(this.align);
  var to = map(align);
  if (from != null) {
    this.releaseConstraintMethod(from);
  }
  if (to != null) {
    this.applyConstraintMethod(to, [this.immediateparent, "width", this, "width"]);
  } else {
    this.setAttribute('x', 0);
  }
  this.align = align;
}

/** @access private */
function __LZalignCenter () {
  var vip:LzView = (this.immediateparent cast LzView);
  this.setAttribute( "x" , vip.width /2
                     - this.width /2);
}

/** @access private */
function __LZalignRight () {
  var vip:LzView = (this.immediateparent cast LzView);
  this.setAttribute( "x" , vip.width
                     - this.width);
}


/**
  * Sets the x offset  
  * @param Integer o: The x offset
  */
function setXOffset ( o ){
    this.__LZhasoffset = o != 0;
    this.xoffset = o;
    this.setX( this.x, true );
    this.setY( this.y, true );
    if (this.onxoffset.ready) this.onxoffset.sendEvent( o );
}

/**
  * Sets the Y offset  
  * @param Integer o: The y offset
  */
function setYOffset ( o ){
    this.__LZhasoffset = o != 0;
    this.yoffset = o;
    this.setX( this.x, true );
    this.setY( this.y, true );
    if (this.onyoffset.ready) this.onyoffset.sendEvent( o );
}


/** @access private
  * @devnote Initial value required to make interpreter happy
  */
static var __LZlastmtrix = [ 0,0,0,0,0,0,0,0,0,0,0 ];


/**
  * Returns an Object with x, y, width, and height properties that are the
  * coordinates of the view's bounding box in its immediateparent's coordinate
  * system. The Laszlo view object uses a relatively simple notion for its
  * coordinate system. Note that this function doesn't necessarily return the
  * true bounding box of the view, but a box surrounding the view, since this
  * method respects a set width and/or height and ignores subviews that appear
  * left or above of the view's 0,0 point.
  * The xoffset and yoffset properties of the bounds object are the distance
  * between the view's x or y property and the top or left of the bounding
  * box.
  * @return Object: An object with x, y, width, height, xoffset and yoffset
  * properties that describes the bounding box of the view.
  */
function getBounds (  ){
    var mtrix = [ -this.xoffset, -this.yoffset,
                   this.width-this.xoffset , -this.yoffset ,
                  -this.xoffset, this.height - this.yoffset ,
                   this.width - this.xoffset, this.height - this.yoffset ,
                   this.rotation , this.x , this.y] ;
                   //last three entries are just to track staleness

    var i = mtrix.length - 1;
    while ( mtrix[ i ] == LzView.__LZlastmtrix[ i ] ){
        if ( i-- == 0 ) {
            return this.__LZstoredbounds;
        }
    };


    var o = {};

    for ( var i = 0; i < 8; i +=2 ){
        var x = mtrix[ i ];
        var y = mtrix[ i+1 ];
        var cx = x * this.__LZrcos  - y * this.__LZrsin;
        var cy = x * this.__LZrsin  + y * this.__LZrcos;
        //Debug.write( i +":" + cx , cy );

        if ( o.xoffset == null || o.xoffset > cx ){
            o.xoffset = cx;
        }
        if ( o.yoffset == null || o.yoffset > cy ){
            o.yoffset = cy;
        }
        if ( o.width == null || o.width < cx ){
            o.width = cx;
        }
        if ( o.height == null || o.height < cy ){
            o.height = cy;
        }
    }
    o.width -= o.xoffset;
    o.height -= o.yoffset;

    o.x = this.x + o.xoffset;
    o.y = this.y + o.yoffset;

    this.__LZstoredbounds = o;
    LzView.__LZlastmtrix = mtrix;

    return o;
}
/** @access private */
function $lzc$getBounds_dependencies ( who , self ){
    return [ self, 'rotation' , self, 'x' , self , 'y' , self , 'width' ,
             self , 'height' ];
}
/**
  * Sets the vertical alignment for the view to the given value. The
  * alignment is based on the height of this view as compared to the
  * height of the view's <attribute>immediateparent</attribute>.
  *
  * @param String valign: The vertical alignment for the view. This is
  * one of "top", "middle", and "bottom"
  *
  * @devnote TODO: [2008-02-07 ptw] Apparently we never supported
  * 'onvalign', should we?
  */
function setValign ( valign ){
  if (this.valign == valign) return;
  function map (align) {
    switch (align) {
      case "middle": return "__LZvalignMiddle";
      case "bottom": return "__LZvalignBottom";
      case "top": return null;
      default:
        if ($debug) {
          Debug.error("%w.%s(%w): Invalid argument.  Valid choices are: 'top', 'middle', or 'bottom'.",
                      this, arguments.callee, valign);
        }
    }
  }
  var from = map(this.valign);
  var to = map(valign);
  if (from != null) {
    this.releaseConstraintMethod(from);
  }
  if (to != null) {
    this.applyConstraintMethod(to, [this.immediateparent, "height", this, "height"]);
  } else {
    this.setAttribute('y', 0);
  }
  this.valign = valign;
}

/** @access private */
function __LZvalignMiddle (e=null) {
  var vip:LzView = (this.immediateparent cast LzView);
  this.setAttribute( "y" , vip.height /2
                     - this.height /2);
}

/** @access private */
function __LZvalignBottom (e=null) {
  var vip:LzView = (this.immediateparent cast LzView);
  this.setAttribute( "y" , vip.height
                     - this.height);
}

/**
  * Sets the color of the view (the view's resource and any subviews) to the
  * the color given. This will completely override any color information in the
  * view or subview resources. Use the view method
  * <method>setColorTransform</method> to tint a view.
  * @param Integer c: A color in rgb format; for example, 0xff0000 is red.
  */
function setColor ( c ){
    this.sprite.setColor(c);
    this.fgcolor = c;
}


/**
  * Gets the color of the view (the view's resource and any subviews) view as
  * as set with setColor().
  * Returns A color in rgb format; for example, 0xff0000 is red.
  */
function getColor (){
    return this.sprite.getColor();
}


/**
  * color transforms everything contained in the view (except the
  * background) by the transformation dictionary given in <param>o</param>.  The dictionary has
  * the following possible keys:
  * 
  * o.ra: percentage alpha for red component (-100 to 100);
  * o.rb: offset for red component (-255 to 255);
  * o.ga: percentage alpha for green component (-100 to 100);
  * o.gb: offset for green component (-255 to 255);
  * o.ba: percentage alpha for blue component (-100 to 100);
  * o.bb: offset for blue component (-255 to 255);
  * o.aa: percentage overall alpha (-100 to 100);
  * o.ab: overall offset (-255 to 255);
  *
  * @runtimes as2
  * @param Object o: A color transformation dictionary
  */
function setColorTransform ( o ){
    if (this.capabilities.colortransform) {
        this.sprite.setColorTransform(o);
    } else if ($debug) {
        this.__warnCapability('view.setColorTransform()'); 
    }
}


/**
  * Returns an object that represents the color transformation currently applied
  * to the view. The color transform object has the following possible keys
  * 
  * o.ra: percentage alpha for red component (-100 to 100);
  * o.rb: offset for red component (-255 to 255);
  * o.ga: percentage alpha for green component (-100 to 100);
  * o.gb: offset for green component (-255 to 255);
  * o.ba: percentage alpha for blue component (-100 to 100);
  * o.bb: offset for blue component (-255 to 255);
  * o.aa: percentage overall alpha (-100 to 100);
  * o.ab: overall offset (-255 to 255);
  *
  * @runtimes as2
  */
function getColorTransform (){
    if (this.capabilities.colortransform) {
        return this.sprite.getColorTransform();
    } else if ($debug) {
        this.__warnCapability('view.getColorTransform()'); 
    }
}


/**
  * Returns the width of the view.
  * @keywords private
  * @deprecated use the width attribute directly
  */
function getWidth (){
    if ($debug) Debug.deprecated(this, arguments.callee, 'width');
    return this.width;
}

/**
  * Returns the height of the view.
  * @keywords private
  * @deprecated use the height attribute directly
  */
function getHeight (){
    if ($debug) Debug.deprecated(this, arguments.callee, 'height');
    return this.height;
}

//__LZcheckwidth = true;
//__LZcheckheight = true;

/** @access private */
function __LZcheckSize ( sview, axis , xory ){

        if ( sview.addedToParent ) {
            if ( sview.__LZhasoffset || sview.rotation != 0 ){
                var bobj = sview.getBounds();
            } else {
                var bobj = sview;
            }
            var ss = bobj[ xory ] + bobj[ axis ];

            //calculating unstretchedsize (for stretches) or just size?
            var ts = this[ "_setresc" + axis ] ?
                     this[ "unstretched" + axis ] : this[axis];

            if ( ss > ts && sview.visible ){
                this[ "__LZoutlie" + axis ] = sview;
                if (axis == "width")
                    this.updateWidth(ss);
                else
                    this.updateHeight(ss);
            } else if ( this[ "__LZoutlie" + axis ] == sview
                        && ( ss < ts || ! sview.visible ) ){
                //uhoh -- we need to recheck everything
                this.reevaluateSize( axis );
            }
        }
}

/** The <function>checkWidth</function> and <function>checkHeight</function> functions handle changes in this view's
  * subviews. The children call these functions on their immediateparents when
  * they change x, y, width, height, or visibility. A view which doesn't care
  * about changes in the size of its contents (because it has a set size and it's
  * not stretching) puts null in this slot, so that it doesn't process calls from
  * its subviews.
  *  
  *  N.B.: these internal methods do not obey the traditional camel-casing
  *  because their names are often constructed on the fly.  Cf.,
  *  updateSize

  *  @devnote [2006-07-28 pbr] This adds another level of indirection. The original
  *                   version built a function that got deleted. ptw suggests
  *                   supporting inline. 
  * @access private
  */
function __LZcheckwidthFunction ( sview )
{
    this.__LZcheckSize (sview, "width", "x");
}
  
/** @access private */
function __LZcheckheightFunction ( sview )
{
    this.__LZcheckSize (sview, "height", "y");
}


/**
  * to do: add dependencies so this can be used as a constraint
  * @access private
  */
function measureSize ( axis )
{
        var w = this[ "resource" + axis ];

        for ( var i= this.subviews.length-1; i >= 0; i-- ){
            var sv = this.subviews[ i ];
            var svs = sv[ axis == "width" ? "x" : "y" ] + sv[ axis ];
            if ( sv.visible && svs > w ){
                w = svs;
            }
        }
        return w;
}

/**
  * reports the width of the contents of the view
  * (not supported in a constraint expression)
  */
function measureWidth ()
{
    return this.measureSize ("width");
}

/**
  * reports the height of the contents of the view
  * (not supported in a constraint expression)
  */
function measureHeight ()
{
    return this.measureSize ("height");
}

/** @access private */
function updateSize ( axis , newsize ){
    if (axis == "width")
        this.updateWidth(newsize);
    else
        this.updateHeight(newsize);
}

/** @access private */
function updateWidth ( newsize ){
    if ( this._setrescwidth ){
        this.unstretchedwidth = newsize;

        if ( this.hassetwidth ){
            var scale = this.width / newsize;
            this._xscale = scale;
        }

        if (this.onunstretchedwidth.ready) this.onunstretchedwidth.sendEvent( newsize );
    }

    if ( !this.hassetwidth ){
        this.width = newsize;
        this.sprite.setWidth(newsize);
        if (this.onwidth.ready) this.onwidth.sendEvent( newsize );

        var vip:LzView = (this.immediateparent cast LzView);
        if (vip.__LZcheckwidth)
            vip.__LZcheckwidthFunction( this );
    }

}

/** @access private */
function updateHeight ( newsize ){
    if ( this._setrescheight ){
        this.unstretchedheight = newsize;

        if ( this.hassetheight ){
            var scale = this.height / newsize;
            this._yscale = scale;
        }

        if (this.onunstretchedheight) 
            if (this.onunstretchedheight.ready) this.onunstretchedheight.sendEvent( newsize );
    }

    if ( !this.hassetheight ){
        this.height = newsize;
        this.sprite.setHeight(newsize);
        if (this.onheight.ready) this.onheight.sendEvent( newsize );

        var vip:LzView = (this.immediateparent cast LzView);
        if (vip.__LZcheckheight) 
            vip.__LZcheckheightFunction( this );

    }
}

/** @access private */
function reevaluateSize ( ia = null){
    //if called with no args, check both
    if ( ia == null ){
        var axis = "height";
        this.reevaluateSize( "width" );
    } else {
        var axis = ia;
    }

    if ( this[ "hasset" + axis ] && ! this[ '_setresc' + axis ] ) return;

    //use 'unstretchedwidth' for stretches
    var o = this[ "_setresc" + axis ] ? this[ "unstretched" + axis ] :
                                        this[ axis ];

    var w =  this[ "resource" + axis ] || 0;
    //var w =  this[ "resource" + axis ] ;
    this[ "__LZoutlie" + axis ] = this;

    for ( var i= this.subviews.length-1; i >= 0; i-- ){
        var sv = this.subviews[ i ];

        if ( sv.__LZhasoffset || sv.rotation != 0 ){
            var b = sv.getBounds();
            var svs = b[ axis == "width" ? "x" : "y" ] + b[ axis ];
        } else {
            var svs = sv[ axis == "width" ? "x" : "y" ] + sv[ axis ];
        }
        if ( sv.visible && svs > w ){
            w = svs;
            this[ "__LZoutlie" + axis ] = sv;
        }
    }

    if ( o != w ){
        if (axis == "width")
            this.updateWidth(w);
        else
            this.updateHeight(w);
    }
}

/**
  * Since a view does not re-measure the size of its resource once that resource
  * has loaded, this method is provided to force the view to update its size, 
  * taking into account the current size of its resource. 
  */
function updateResourceSize ( ){
    //Debug.write('updateResourceSize');
    this.sprite.updateResourceSize();
    this.reevaluateSize();
}


/**
  * This method is used to set a view's property to match that of
  * another view -- potentially one in another coordinate system.
  * 
  * @param String prop: a string specifying the property to set.
  * known properties are: x, y, width, and height
  * @param LzView refView: the reference view for the transformation
  */
function setAttributeRelative(prop, refView) {
    var tLink = this.getLinkage( refView );
    var val = refView[ prop ];
    if (prop == "x" || prop =="y" ){
        //these properties need to account for both offset and scale
        tLink.update ( prop );
        this.setAttribute (prop ,  (  val - tLink.offset[prop] )
                                / tLink.scale[prop] );
    }else if ( prop == "width" || prop == "height" ){
        //these properties account only for scale
        var axis = prop == "width" ? "x" : "y"
        tLink.update ( axis )
        this.setAttribute ( prop, val / tLink.scale[ axis ] );

    }else{
        //not yet implemented: rotation, alpha...
    }
}


/** @access private
 * @devnote This routine is unused.
 * getAttributeRelative is the routine that is used in dependencies.
 * "who" below should refer to "self"
 */
function $lzc$setAttributeRelative_dependencies ( who,self, prop ,
                                                         refView ){
    // Debug.write("here i am, about to call getLinkage");
    var tLink = who.getLinkage( refView );
    var pass = 2;
    var d = [] ;

    if ( prop == "width" ){
        var ax = "x";
    } else if ( prop == "height" ){
        var ax = "y";
    } else {
        var ax = prop;
    }

    var sax = ax == "x" ? "width" : "height";

    while ( pass ){
        if ( pass == 2 ){
            var carr = tLink.uplinkArray;
        } else {
            var carr = tLink.downlinkArray;
        }
        pass--;
        for ( var i = carr.length-1; i >= 0; i-- ){
            d.push ( carr[ i ] , ax);
            if ( d[ "_setresc" + sax ] ){
                //view stretches; affects relative props
                d.push( [ carr[ i ] , sax ] );
            }
        }
    }
    return d;
}



/**
  * Transform the specified attribute (width/height/x/y) from the existing
  * coordinate space to the reference view's coordinate space. This 
  * transformation takes into account any nested views between the views and
  * the common ancestor view.
  * 
  * This method answers the question: what should this view set its
  * width/height/x/y to in order to appear to have the same value for that
  * attribute as the reference view?
  * 
  * @param String prop: a string specifying the property to return.
  *              known properties are: x, y, width, and height
  * @param LzView refView: the reference view for the transformation
  */
function getAttributeRelative(prop, refView ) {
    var tLink = this.getLinkage( refView );

    if (prop == "x" || prop =="y" ){
        tLink.update ( prop );
        return tLink.offset[prop] + tLink.scale[prop] * this[ prop ];
    }else if ( prop == "width" || prop == "height" ){
        var axis = prop == "width" ? "x" : "y"
        tLink.update ( axis )
        return tLink.scale[axis] * this[ prop ];
    }else{
        //not yet implemented: rotation, alpha...
    }
}

/** @access private */
function $lzc$getAttributeRelative_dependencies( who,self, prop ,
                                                        refView ){
    var tLink = self.getLinkage( refView );
    var pass = 2;
    var d = [ self , prop ] ;

    if ( prop == "width" ){
        var ax = "x";
    } else if ( prop == "height" ){
        var ax = "y";
    } else {
        var ax = prop;
    }

    var sax = ax == "x" ? "width" : "height";

    while ( pass ){
        if ( pass == 2 ){
            var carr = tLink.uplinkArray;
        } else {
            var carr = tLink.downlinkArray;
        }
        pass--;
        for ( var i = carr.length-1; i >= 0; i-- ){
            var ci = carr[ i ];
            d.push ( ci , ax);
            if ( ci[ "_setresc" + sax ] ){
                //view stretches; affects relative props
                d.push( ci , sax );
            }
        }
    }

    return d;
}


/** @access private */
var __LZviewLinks = null;

/**
  * This method creates a linkage that can provide transformations
  * between views.  Once created, linkages are stored for reuse as a
  * hash, with a pointer to the reference view serving as the key.
  * @deprecated See note regarding <method>getAttributeRelative</method>.
  * 
  * @access private
  * 
  * @param refView: the view to which to create a linkage.
  */
function getLinkage( refView ) {
    if ( this.__LZviewLinks == null ){
        this.__LZviewLinks = new Object;
    }

    var uid = refView.getUID();
    if (this.__LZviewLinks[ uid ] == null ){
        //cache links for quick access
        this.__LZviewLinks[ uid ] = new LzViewLinkage(this, refView );
    }

    return this.__LZviewLinks[ uid ];
}

/**
  * @access private
  * Receives mouse events from sprites/mode manager and sends the appropriate 
  * events
  */
function mouseevent(eventname) {
    if (this[eventname] && this[eventname].ready) this[eventname].sendEvent(this);
}    

/**
  * This method returns the position of the mouse relative to this view.
  * @param xory: a string ("x" | "y") specifying which axis to return
  * @return Number: The position of the mouse relative to this view.
  */
function getMouse( xory ) {
    if (this.__movecounter != LzGlobalMouse.__movecounter) {
        this.__movecounter = LzGlobalMouse.__movecounter;
        this.__mousecache = this.sprite.getMouse(xory);
    }
    if (xory == null) return this.__mousecache;
    return this.__mousecache[xory];
}

/** @access private */
function $lzc$getMouse_dependencies( ) {
    return [ LzIdle, "idle" ];
}


/**
  * returns true if the point is contained within the view.
  * @param Number x: an x value relative to the this view's coordinates
  * @param Number y: an y value relative to the this view's coordinates
  * @return Boolean: boolean indicating whether or not the point lies within the view
  */
function containsPt( x,y ) {
   return (((this.height >= y) && (y >= 0)) &&
                ((this.width >= x) && (x >= 0)));
}

/**
  * This method makes this view the frontmost subview of this view's parent.
  * */
function bringToFront ( ){
    //this is really a function of the parent view
    //this.immediateparent.changeOrder ( this , 1);

    // FIXME: [hqm 2006-09] in some cases I have seen this.sprite unbound, is that ever OK?
    if (!this.sprite) {
        if ($debug) {
            Debug.write("no sprite on ",this);
        }
        return;
    }
    this.sprite.bringToFront();
}

/*
  * Returns an array of subviews in depth order
  * @return [LzView]: An array of this view's subviews in depth order
  */
function getDepthList (){
    var o = [];

    var s = this.subviews;
    for (var i = 0; i < s.length; i++) {
        o[i] = s[i];
    }

    o.sort(this.__zCompare);

    return o;
}


/**
  * Sort comparator for sprite z order
  * @access private
  */
function __zCompare(a, b) {
   var az = a.sprite.getZ();
   var bz = b.sprite.getZ();
   if (az < bz)
      return -1
   if (az > bz)
      return 1
   return 0
}

/**
  * Puts this view behind one of its siblings.
  * @param LzView v: The view this view should go in front of. If the passed 
  * view is null or not a sibling, the method has no effect.
  * @return Boolean: Method returns true if the operation is successful.
  */
function sendBehind ( v ){
    //return this.immediateparent.changeOrder( this, -1, v , false );
    return (v ? this.sprite.sendBehind(v.sprite) : false);
}

/**
  * Puts this view in front of one of its siblings.
  * @param LzView v: The view this view should go in front of. If the passed 
  * view is null or not a sibling, the method has no effect.
  * @return Boolean: Method returns true if the operation is successful.
  */
function sendInFrontOf ( v ){
    //return this.immediateparent.changeOrder( this, 1, v , true );
    return (v ? this.sprite.sendInFrontOf(v.sprite) : false);
}

/**
  * This method makes this view the hindmost subview of this view's parent.
  */
function sendToBack ( ){
    //this is really a function of the parent view
    //this.immediateparent.changeOrder ( this , -1);
    this.sprite.sendToBack();
}

/**
  * For resources which have more than one frame, this function sets
  * the view
  * to display the numbered resource. For Flash assets, resource numbers
  * correspond to
  * movieclip frames.
  * 
  * @param Integer n: the number of the resource to show
  */
function setResourceNumber( n ) {
    //Debug.write('setResourceNumber', n, this, this.playing)

    // prevent play status tracking from running if the frame was set oninit, like in windowframe class
    this.__lzcheckframe = n;
    this.frame = n;
    this.stop( n );
    if (this.onframe.ready) this.onframe.sendEvent(n);
}

/**
  * Sets the view so that it stretches its resource in the given axis so that
  * the resource is the same size as the view. The has the effect of distorting
  * the coordinate system for all children of this view, so use this method
  * with care.
  * 
  * @deprecated Use setAttribute('stretches', ...) instead.
  * @param String stretch: Set the resource to stretch only in the given axis ("width" or
  * "height") or in both axes ("both"). 
  */
function stretchResource(v) { 
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    this.$lzc$set_stretches(v); 
}

/** @access private */
function $lzc$set_stretches( stretch ){
    if (!(stretch == "none" || stretch == "both" || stretch == "width" || stretch == "height")) {
        //TODO: Remove null, x, y options from here when components are moved
        var newstretch = (stretch == null ? "both" : stretch == "x" ? "width" : stretch == "y" ? "height" : "none");
        if ($debug && newstretch != "none") {
            Debug.info("%w.%s(%w) is deprecated.  Use %w.%s(%w) instead.",
                this, arguments.callee, stretch, this, arguments.callee, newstretch);
        }
        stretch = newstretch;
    } else if (this.stretches == stretch) {
        return;
    }
    
    this.stretches = stretch;
    this.sprite.stretchResource(stretch);
    
    if (stretch == "width" || stretch == "both") {
        this._setrescwidth = true;
        this.__LZcheckwidth = true;
        this.reevaluateSize( "width" );
    }

    if (stretch == "height" || stretch == "both") {
        this._setrescheight = true;
        this.__LZcheckheight = true;
        this.reevaluateSize( "height" );
    }
}

/**
  * Gives the view a bgcolor that is the same size as the view.
  * @param Integer bgc: The 0-FFFFFF number to be used for the new background color.
  */
function setBGColor ( bgc ) {
    //trace('setting bgcolor ',bgc, this, this.sprite);
    this.sprite.setBGColor(bgc);
    if (bgc != null) this.bgcolor = Number(bgc);
    if (this.onbgcolor.ready) this.onbgcolor.sendEvent( bgc );
}

/**
  * This function allows the view to load its media from an URL at runtime.
  * Resources loaded with <method>setSource</method> will replace compiled
  * resources when the request is made.
  * 
  * @param String source: The URL from which to load the resource for this view.
  * @param String cache: If set, controls caching behavior. Choices are
  * <code>none</code> , <code>clientonly</code> , <code>serveronly</code> , <code>both</code> (the default).
  * @param String headers: Headers to send with the request, if any.
  */
function setSource ( source , cache = null, headers = null){
    this.sprite.setSource(source, cache, headers);
}

/**
  * Unloads media loaded with setSource or the source= attribute.
  * */
function unload ( ){
    this._resource = null;
    //this function formerly lived on the LzMakeLoad transformer
    this.sprite.unload();
}


/**
  * This function applies the MakeMasked view transformer.
  * @access private
  */
function makeMasked ( ){
    this.sprite.setClip(true);
    this.masked = true;
    this.mask = this;
}

/** @access private */
function removeMask () {
    this.sprite.setClip(false);
    this.masked = false;
    this.mask = null;
}


/**
  * Setting clickRegion to a vector-based SWF turns the SWF shape into a clickable hotspot.
  * @access private
  */
function __LZsetClickRegion ( cr ){
    this.sprite.__LZsetClickRegion(cr);
}

/**
  * Makes a view clickable or not clickable.
  * @param Boolean amclickable: Boolean indicating the view's clickability
  */
function setClickable ( amclickable ){
    this.sprite.setClickable(amclickable);
    this.clickable = amclickable;
    if (this.onclickable.ready) this.onclickable.sendEvent( amclickable );

}


/**
  * Sets the cursor to the given resource when the mouse is over this view
  * @param String cursor: The name of the resource to use as a cursor when it is over
  * this view. Or '' for default cursor.
  */
function setCursor ( cursor ){
    this.sprite.setCursor(cursor);
}


/**
  * Start or stop playing the attached resource.
  * @param Boolean b: If true, starts playing, otherwise stops
  */
function setPlay (b){
    if ( b ) {
        this.play();
    } else {
        this.stop();
    }
}

/**
  * Get a reference to the control mc - may be overridden by loader
  * @access private
  */
function getMCRef () {
    return this.sprite.getMCRef();
    //return this.__LZmovieClipRef;
}

/**
  * Start playing the attached resource. Note that a compiled resource that
  * begins playing when it is attached (i.e. does not contain a 'stop'
  * instruction in the first frame) will not send events and generally behave
  * correctly unless it is told to play. Resources which are loaded via
  * setSource don't have this issue.
  * 
  * @param Integer f: If defined, begin playing at the given frame. Otherwise,
  * begin playing at the current frame.
  * @param Boolean rel: If true, f is relative to the current frame.  Otherwise f is relative to the beginning of the resource.
  */
function play (f = null, rel = null){
    this.sprite.play(f, rel);
}

/**
  * Stop playing the attached resource
  * @param Integer f: If defined, stop playing at the given frame. Otherwise,
  * stop at the current frame.
  * @param Boolean rel: If true, f is relative to the current frame.  Otherwise it is relative to the start position of the resource.
  */
function stop (f = null, rel = null){
    this.sprite.stop(f, rel);
}

/**
  * Set the volume of the attached resource
  * @param Integer v: A number from 0 to 100 representing a volume level
  */
function setVolume (v) {
    if (this.capabilities.audio) {
        this.sprite.setVolume(v);
    } else if ($debug) {
        this.__warnCapability('view.setVolume()'); 
    }
}

/**
  * Get the volume of the attached resource
  * @return Integer: A number from 0 to 100 representing a volume level
  */
function getVolume () {
    if (this.capabilities.audio) {
        return this.sprite.getVolume();
    } else if ($debug) {
        this.__warnCapability('view.getVolume()'); 
    }
}

/**
  * Set the pan of the attached resource
  * @param Integer p: A number from -100 to 100 representing a pan level
  */
function setPan (p) {
    if (this.capabilities.audio) {
        this.sprite.setPan(p);
    } else if ($debug) {
        this.__warnCapability('view.setPan()'); 
    }
}

/**
  * Get the pan of the attached resource
  * @return Integer: A number from -100 to 100 representing a pan level
  */
function getPan () {
    if (this.capabilities.audio) {
        return this.sprite.getPan();
    } else if ($debug) {
        this.__warnCapability('view.getPan()'); 
    }
}

/**
  * Get the Z order of the view
  * @return Integer: A number representing z level relative to other siblings
  * @access private
  */
function getZ () {
    return this.sprite.getZ();
}

/**
  * Skips forward or backward n seconds (depending on the sign of the argument).
  * If playing, continue to play. If stopped, stay
  * stopped
  * 
  * @param Integer secs: Number of seconds to skip forward or backward (if negative)
  */
function seek ( secs ){
    var m = this.getMCRef();
    if (m.isaudio == true) {
        m.seek(secs, this.playing)
    } else {
        var f = secs*canvas.framerate;
        if ( this.playing ) {
            this.play( f , true);
        } else {
            this.stop( f , true);
        }
    }
}

/**
  * Return the elapsed play time within the view's resource.
  * @return Number: The number of seconds of media between the current frame and the
  * first frame
  */
function getCurrentTime ( ){
    var m = this.getMCRef();
    if (m.isaudio == true) {
        return m.getCurrentTime();
    } else {
        return this.frame / canvas.framerate;
    }
}

/** @access private */
function $lzc$getCurrentTime_dependencies ( who, self ){
    return [ self , "frame" ];
}


/**
  * Returns the total amount of time the resource would take to play.
  * @return Number: Seconds of media controlled by this view.
  */
function getTotalTime ( ){
    var m = this.getMCRef();
    if (m.isaudio == true) {
        return m.getTotalTime();
    } else {
        return this.totalframes / canvas.framerate;
    }
}
/** @access private */
function $lzc$getTotalTime_dependencies ( who, self ){
    return [ self , "load" ];
}

/**
  * Returns an object containing the media's id3 tag, assuming it's mp3 loaded 
  * with proxy == false;
  * @return Object: Object containind id3 tag data, if available.
  */
function getID3 ( ){
    var m = this.getMCRef();
    if (m.isaudio == true) {
        return m.getID3();
    }
}


/** @access private */
var __LZdidPPwarn = false;

/** @access private */
function getPlayPerc ( ){
    if ( $debug ){
        if ( !this.__LZdidPPwarn ){
          Debug.info("%w.%s is deprecated.  Use frame/totalframes attributes instead.",
                     this, arguments.callee);
        }
        this.__LZdidPPwarn = true;
    }
    return this.frame/this.totalframes;
}

/** @access private */
function $lzc$getPlayPerc_dependencies ( who , self ){
    return [ self, "frame" ];
}

/**
  * Shows or hides the hand cursor for this view.
  * @param Boolean s: true shows the hand cursor for this view, false hides 
  * it
  */
function setShowHandCursor ( s ){
    this.sprite.setShowHandCursor(s);
}

/**
  * @param Boolean accessible
  */
function setAccessible (accessible) {
    if (this.capabilities.accessibility) {
        this.sprite.setAccessible(accessible);
    } else if ($debug) {
        this.__warnCapability('view.setAccessible()'); 
    }
}

/**
  * Activate/inactivate children for accessibility
  * @param Boolean s: If true, activate the current view and all of its children
  */
function setAAActive ( s, mc = null){
    if (this.capabilities.accessibility) {
        this.sprite.setAAActive(s, mc);
    } else if ($debug) {
        this.__warnCapability('view.setAAActive()'); 
    }
}


/**
  * Set accessibility name
  * @param string s: Sets the accessibility name for this view
  */
function setAAName ( s, mc = null){
    if (this.capabilities.accessibility) {
        this.sprite.setAAName(s, mc);
    } else if ($debug) {
        this.__warnCapability('view.setAAName()'); 
    }
}

/**
  * Set accessibility description
  * @param string s: Sets the accessibility name for this view
  */
function setAADescription ( s, mc = null){
    if (this.capabilities.accessibility) {
        this.sprite.setAADescription(s, mc);
    } else if ($debug) {
        this.__warnCapability('view.setAADescription()'); 
    }
}

/**
  * Set accessibility tab order
  * @param number s: The tab order index for this view.  Must be a unique number.
  */
function setAATabIndex ( s, mc = null){
    if (this.capabilities.accessibility) {
        this.sprite.setAATabIndex(s, mc);
    } else if ($debug) {
        this.__warnCapability('view.setAATabIndex()'); 
    }
}

/**
  * Set accessibility silencing/unsilencing
  * @param string s: If true, this view is made silent to the screen reader.  
  * If false, it is active to the screen reader.
  */
function setAASilent ( s, mc = null){
    if (this.capabilities.accessibility) {
        this.sprite.setAASilent(s, mc);
    } else if ($debug) {
        this.__warnCapability('view.setAASilent()'); 
    }
}

/**
  * Determine whether a view should give up focus. Override this method to
  * specify your own policy.
  */
function shouldYieldFocus ( ){
    return true;
}


/** blurring is true if the view is in the process of losing focus.
  * @type Boolean
  * @access private 
  */
var blurring = false;



/** @access private */
static var __LZproxypolicies = [];

/** @access private */
static function __LZcheckProxyPolicy ( url ){
    var pol = LzView.__LZproxypolicies;

    for ( var i = pol.length-1; i >=0; i-- ){
        var resp = pol[ i ] ( url );
        if ( resp != null ) return resp;
    }

    return canvas.proxied;
}

/**
  * Adds a function which can decide how the media at a given URL should be
  * loaded
  * 
  * @param Function f: A function that takes a URL as a string and returns one
  * of true, false, or null meaning respectively that the request should be
  * proxied by the LPS server; made directly to the URL; or should be passed to
  * the next policy function in the list. The default policy function returns
  * the value of canvas.proxied
  * @access private
  */
static function addProxyPolicy ( f ){
   LzView.__LZproxypolicies.push ( f );
}

/**
  * Removes a proxy policy function that has been added using
  * LzView.addProxyPolicy
  * 
  * @param Function f: The function to remove from the policy list
  * @return Boolean: Returns true if the function was found and removed, false
  * if not
  * @access private
  */
static function removeProxyPolicy ( f ){
    var pol = LzView.__LZproxypolicies;
    for ( var i = 0; i < pol.length; i++ ) {
        if ( pol[ i ] == f ){
            LzView.__LZproxypolicies = pol.splice( i, 1 );
            return true;
        }
    }

    return false;
}


/**
  * LzView.setContextMenu
  * Install menu items for the right-mouse-button 
  * @param LzContextMenu cmenu: LzContextMenu to install on this view
  */
function setContextMenu ( cmenu ){
    this.sprite.setContextMenu( cmenu );
}


/**
  * LzView.getContextMenu
  * Returns the current context menu object
  * @access public
  */
function getContextMenu ( ){
    return this.sprite.getContextMenu();
}

/** @access private */ 
function __warnCapability(msg) {
    Debug.warn('The %s runtime does not support %s', canvas['runtime'], msg); 
}

/**
  * Override to specify the next view to be focused
  * @access public
  */
function getNextSelection() {
}
/**
  * Override to specify the previous view to be focused
  * @access public
  */
function getPrevSelection() {
}
} // End of LzView

ConstructorMap[LzView.tagname] = LzView;
