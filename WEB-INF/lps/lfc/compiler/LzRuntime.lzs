/* -*- mode: JavaScript; c-basic-offset: 2; -*- */

/**
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access private
  * @topic LZX
  * @subtopic Runtime
  */

/**
  * DHTML/SWF compatibility
  *
  * @todo 2006-04-07 ptw Remove when _root is eradicated from .lzs
  */
window._root = window;

/**
 * Modules
 * TODO [2006-03-12 ptw] if the LFC is shared this needs to be multiplexed
 */
var $modules = {};

/**
 * Define runtime module
 */
if ($swf9) {
$modules.runtime = global;
} else {
$modules.runtime = this;
}

/**
 * Define LZ module
 * TODO: [2006-03-21 ptw] Make this an object that inherits from
 * runtime so that we do not pollute the runtime module
 */
$modules.lz = $modules.runtime;

/**
 * Define USER module
 * TODO: [2006-03-21 ptw] Make this an object that inherits from
 * LZ so that we do not pollute the LZ module
 */
$modules.user = $modules.lz;

/**
 * Define global
 * TODO [2006-03-12 ptw] if the LFC is shared this needs to be multiplexed
 */
if ($swf9) {
} else {
var global = $modules.user;
}

if ($debug) {
  /**
    * Expose this to the DHTML debugger
    * The application and debugger share their parent.
    */
  window.parent.$modules = $modules;
}

if ($as2) {
var encodeURIComponent = escape;
}

/**
 * Compiler support for debugger warnings.  These presently pollute
 * the global environment, because you need a toe-hold somewhere.
 */
if ($debug) {

  /** Set by the server to tell Debug.__write to log back to the server
    * @access private
    */
  var _dbg_log_all_writes;

  // Automatically enable logging if there is a javascript console log
  // function
  if ($js1) {
    _dbg_log_all_writes = ('console' in global) && (typeof console.log == 'function');
  }

  // Silence global warning
  var Debug;

  /**
   * <p>There are three ways to enable the debugger, as described in
   * the <a
   * href="${dguide}debugging.html#enabling-the-debugger">Debugging</a>
   * chapter of the Developer's Guide.</p>
   *
   * <p>The debugger can be useful in debugging your own code, but you
   * should also use debugging to report bugs.  The debugger method
   * <xref linkend="Debug+debug.bugReport"/> will output information
   * that can be cut and pasted into a bug report to aid in
   * diagnosing the bug.</p>
   *
   * <p>The debugger has a range of methods for formatting output to the
   * debugger console:
   * <xref linkend="Debug+debug.debug"/>,
   * <xref linkend="Debug+debug.info"/>,
   * <xref linkend="Debug+debug.warn"/>, and
   * <xref linkend="Debug+debug.error"/>.
   * Each of these is based upon the basic formatted output method
   * <xref linkend="Debug+debug.format"/>.  The variants prefix their
   * message with a label (DEBUG, INFO, WARNING, or ERROR) and will
   * print in a distinct color.  When backtraces are enabled, these
   * debug messages will also give a source location.</p>
   *
   * <p>The debug messages can be silenced by setting
   * <xref linkend="Debug+debug.messageLevel"/>.</p>
   *
   * <p>Debugger messages are <em>inspectable</em>, as the example below
   * demonstrates.  Clicking on the printed representation of the
   * object (in blue) will show the details of the object.  The
   * message itself can also be inspected.  When backtraces are
   * enabled, one component of the message will be a backtrace that
   * can be inspected to see the call chain and function arguments
   * that resulted in the message.</p>
   *
   * <example title="Debug output methods"><programlisting><![CDATA[
   * <canvas debug="true" height="150">
   *   <debug width="350" height="90%" x="5" y="5" fontsize="8"/>
   *   <script>
   *     Debug.format("Hello %s!", 'world');
   *     Debug.debug("Click there -> %w to inspect the object", {a: 1, b: 2});
   *   </script>
   * </canvas>]]>
   * </programlisting></example>
   *
   * <p>The debugger can be used to trace method calls using
   * <xref linkend="Debug+debug.trace"/>
   * and it can be used to monitor instance variables using
   * <xref linkend="Debug+debug.monitor"/></p>
   *
   * <example title="Debug tracing and monitoring"><programlisting><![CDATA[
   * <canvas debug="true" height="150">
   *   <debug width="350" height="90%" x="5" y="5" fontsize="8"/>
   *   <script>
   *     var o = {a: 7, f: function (x) { return x * x;}};
   *     Debug.monitor(o, 'a');
   *     o.a = 42;
   *     Debug.trace(o, 'f');
   *     o.f(4);
   *   </script>
   * </canvas>]]>
   * </programlisting></example>
   *
   * <p>The optional <code>debug</code> tag controls the
   * appearance of the debugger when debugging is on. It does not
   * cause the application to be compiled with debugging mode enabled.
   * By default, the debug window will be sized to fit the lower 1/2
   * of the canvas, and can be resized as necessary.</p>
   *
   * @shortdesc The Laszlo debugger
   * @keywords private_constructor
   * @access public
   * @topic LZX
   * @subtopic Debugging
   *
   * @devnote This is defined here rather than in debug/LzDebug so that a few
   * bootstrap methods can be hung off it to handle logging of errors
   * and warnings as early as possible.
   */
  var Debug = new Object;

  /** Backtrace stack
    * @access private
    */
  Debug.backtraceStack = new Array();
  /** Max depth allowed
    * @access private
    */
  Debug.backtraceStack.maxDepth = 100;
  /** Backtrace for uncaught errors
   * @access private
   */
  Debug.uncaughtBacktraceStack = null;

  /**
    * Doc'd on real definition
    * Bootstrap version
    * @access private
    */
  Debug.addText = function (msg) {
#pragma "warnUndefinedReferences=false"
    if ($dhtml) {
      try {
        // The application and debugger are sibling iframes in the
        // embedding.
        var dw = window.parent.frames['LaszloDebugger'];
        var dwd = dw.document;
        var span = dwd.createElement('span');
        // IE does not display \n in white-space: pre, so we translate...
        span.innerHTML = '<span class="OUTPUT">' + msg.split('\n').join('<br />') + '</span>';
        dwd.body.appendChild(span);
        // Scroll to end
        span.scrollIntoView(false);
      } catch (e) {
        try {
          // Rhino?
          if (print.length > 0) {
            print(msg);
            return;
          }
        } catch (e) {};
      }
    }
  };

  /**
    * Doc'd on real definition
    * Bootstrap version
    * @access private
    */
// Implementation of Debug.log  does not depend on any of
// the LFC working and hence can be used from startup on.
  Debug.log = function (msg) {
#pragma "warnUndefinedReferences=false"
    if ($as2) {

      // SWF case
      if (_dbg_log_all_writes) {
        // send URL to LzServlet: lzt=eval lz_log=true lz_msg=$MSG
        var url = _root._url; // LzBrowser.getLoadURL();
        var q = url.indexOf("?");
        if (q >= 0) {
          url = url.substring(0, q);
        }
        url += "?lz_log=true&lzt=eval&lz_load=false&lz_script="+encodeURIComponent(String(msg));
        // Flash-specific call -- 5 is magic?!
        _root.loadVariables(url, 5);
      }
    } else {
      // Log to firebug console, if it exists
      if (('console' in global) && (typeof console.log == 'function')) {
        console.log('' + msg);
      }
    }
  };

  /**
    * Doc'd on real definition
    * Bootstrap version
    * @access private
    */
  Debug.__write = function (msg) {
    if (_dbg_log_all_writes) {
      this.log(msg);
    }
    this.addText(msg);
  };

  /**
    * Doc'd on real definition
    * Bootstrap version
    * @access private
    */
  Debug.debug = function () {
    this.__write('DEBUG: ' + Array.prototype.slice.call(arguments, 0).join(' '));
  };
  /**
    * Doc'd on real definition
    * Bootstrap version
    * @access private
    */
  Debug.info = function () {
    this.__write('INFO: ' + Array.prototype.slice.call(arguments, 0).join(' '));
  };
  /**
   * @access private
   * To catch swf 'trace()' calls
   */
  trace = function () { Debug.info.apply(Debug, arguments); }

  /**
    * Doc'd on real definition
    * Bootstrap version
    * @access private
    */
  Debug.warn = function () {
    this.__write('WARNING: ' + Array.prototype.slice.call(arguments, 0).join(' '));
  };
  /**
    * Doc'd on real definition
    * Bootstrap version
    * @access private
    */
  Debug.error = function () {
    this.__write('ERROR: ' + Array.prototype.slice.call(arguments, 0).join(' '));
  };

  /** Bootstrap version of base warning function
    * @access private
    */
  function $reportSourceWarning (filename, lineNumber, msg, fatal) {
#pragma "warnUndefinedReferences=false"
    var warning = (fatal?'ERROR:  ':'WARNING: ') + filename + ':' + lineNumber + ': ' + msg + '\n';
    Debug.__write(warning);
  };

  // Each of the warnings that the compile may call maintains a flag to
  // avoid recursing (e.g., when the debugger has a bug).

  // TODO: [2003-01-08 ptw] Consider a fall-back mechanism for getting
  // debugger bugs reported.

  /** @access private */
  function $reportUndefinedObjectProperty (filename, lineNumber, propertyName) {
#pragma "warnUndefinedReferences=false"
    if (! arguments.callee._dbg_recursive_call) {
      arguments.callee._dbg_recursive_call = true;
      $reportSourceWarning(filename, lineNumber, "undefined object does not have a property '" + propertyName + "'", true);
      arguments.callee._dbg_recursive_call = false;
    }
  };
  $reportUndefinedObjectProperty._dbg_recursive_call = false;

  /** @access private */
  function $reportUndefinedProperty (filename, lineNumber, propertyName) {
#pragma "warnUndefinedReferences=false"
    if (! arguments.callee._dbg_recursive_call) {
      arguments.callee._dbg_recursive_call = true;
      $reportSourceWarning(filename, lineNumber, "reference to undefined property '" + propertyName + "'", false);
      arguments.callee._dbg_recursive_call = false;
    }
  };
  $reportUndefinedProperty._dbg_recursive_call = false;

  /** @access private */
  function $reportUndefinedVariable (filename, lineNumber, variableName) {
#pragma "warnUndefinedReferences=false"
    if (! arguments.callee._dbg_recursive_call) {
      arguments.callee._dbg_recursive_call = true;
      $reportSourceWarning(filename, lineNumber, "reference to undefined variable '" + variableName + "'", true);
      arguments.callee._dbg_recursive_call = false;
    }
  };
  $reportUndefinedVariable._dbg_recursive_call = false;

  /** @access private */
  function $reportNotFunction(filename, lineNumber, name, value) {
#pragma "warnUndefinedReferences=false"
    if (! arguments.callee._dbg_recursive_call) {
      arguments.callee._dbg_recursive_call = true;
      var msg = "call to non-function";
      if (typeof name == "string")
        msg += " '" + name + "'";
      msg += " (type '" + typeof value + "')";
      if (typeof value == "undefined") {
        msg = "call to undefined function";
        if (typeof name == "string")
          msg += " '" + name + "'";
      }
      $reportSourceWarning(filename, lineNumber, msg, true)
        arguments.callee._dbg_recursive_call = false;
    }
  };
  $reportNotFunction._dbg_recursive_call = false;

  /** @access private */
  function $reportUndefinedMethod(filename, lineNumber, name, value) {
#pragma "warnUndefinedReferences=false"
    if (! arguments.callee._dbg_recursive_call) {
      {
        arguments.callee._dbg_recursive_call = true;

        var msg = "call to non-method";
        if (typeof name == "string")
          msg += " '" + name + "'";
        msg += " (type '" + typeof value + "')";
        if (typeof value == "undefined") {
          msg = "call to undefined method";
          if (typeof name == "string")
            msg += " '" + name + "'";
        }
        $reportSourceWarning(filename, lineNumber, msg, true);
      }
      {
        arguments.callee._dbg_recursive_call = false;
      }
    }
  };
  $reportUndefinedMethod._dbg_recursive_call = false;

  if ($js1) {

    /**
      * In the DHTML runtime, the checking is done by subroutines, for
      * compactness.
      * @access private
      */
    Debug.evalCarefully = function (fileName, lineNumber, closure, context) {
#pragma "warnUndefinedReferences=false"
      try {
        return closure.call(context);
      } catch(e) {
        $reportSourceWarning(fileName, lineNumber, e);
      }
    };

    /**
     * We can't use that everywhere, so we also install a default
     * error handler
     */
    if (typeof window.addEventListener == 'function') {
      // The DOM 1 interface is more useful than the DOM 2 interface
      window.onerror = function (errorString, fileName, lineNo) {
        #pragma "warnUndefinedReferences=false"
        if (Debug.uncaughtBacktraceStack) {
          // If backtracing has caught our stack info, use that rather
          // than browser info
          errorString = new String(errorString);
          errorString.$lzsc$b = Debug.uncaughtBacktraceStack;
          Debug.uncaughtBacktraceStack = null;
          fileName = null;
          lineNo = null;
        }
        $reportSourceWarning(fileName, lineNo, errorString, true);
        // pass through to browser debugger
        return false;
      }
    }
  }

  if ($as2) {
    /**
     * Evaluate a closure in context, ignoring any errors
     * @param closure:Function the closure to evaluate
     * @param context:Object the context to evaluate the closure in
     * @param errval:* the value to return if there is an error
     * @access private
     */
    Debug.ignoringErrors = function ignoringErrors (closure, context, errval) {
  #pragma "warnUndefinedReferences=false"
        return closure.call(context);
    }
  } else {
    /**
     * Evaluate a closure in context, ignoring any errors
     * @param closure:Function the closure to evaluate
     * @param context:Object the context to evaluate the closure in
     * @param errval:* the value to return if there is an error
     * @access private
     */
    Debug.ignoringErrors = function ignoringErrors (closure, context, errval) {
  #pragma "warnUndefinedReferences=false"
      try {
        return closure.call(context);
      } catch(e) {
        return errval;
      }
    }
  }
}
