/* -*- mode: JavaScript; c-basic-offset: 2; -*- */

/**
 * Formatted output
 *
 * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
 *            Use is subject to license terms.
 */

/**
 * This will be replaced by a more complete definition if the debugger
 * is included
 *
 * @access private
 */
class LzMessage {
  var message = '';
  var length = 0;

  function LzMessage (message = null) {
    if (message != null) {
      this.appendInternal('' + message, message);
    }
  }

  function appendInternal (str, obj = null) {
    this.message += str;
    this.length = this.message.length;
  }

  function append (str) {
    var len = arguments.length;
    for (var i = 0; i < len; i++) {
      this.appendInternal(String(arguments[i]));
    }
  }

  // TODO: [2005-05-08 ptw] (LPP-5394) When toString is declared
  // public, remove the swf9 special-case
  if ($swf9) {
    prototype.toString = function () { return this.message; }
  } else {
    function toString () {
      return this.message;
    }
  }

  function toHTML () {
    // TODO: [2005-05-08 ptw] (LPP-5394) When toString is declared
    // public, remove the swf9 special-case
    if ($swf9) {
      return this['toString']();
    } else {
      return this.toString();
    }
  }
}


/**
 * Formatted output support
 *
 * <p>See <xref linkend="LzText" />s <xref
 * linkend="LzText.prototype.format" /> and <xref linkend="Debug+debug"
 * />s <xref linkend="Debug+debug.format" /> methods for
 * examples of how to present formatted text to the user
 * interface.</p>
 *
 * @access public
 * @topic LZX
 * @subtopic Formatted Output
 */
mixin LzFormatter {


  /**
   * pad or trim a string to a specified length
   *
   * @param * value: the value to pad, will be coerced to a string if not a number
   * @param Number widthMin: the minimum width, if negative pad on the
   * right, default 0
   * @param Number decMax: for numbers: ensure decimals characters to the right
   * of '.', padding with 0, otherwise maximum width
   * @param String pad: character to pad on left with, default ' '
   * @param String sign: ' ', '-', '+', default '-'
   * @param Number radix: radix to represent numbers in, default 10
   * @param Boolean force: ensure numbers always have a decimal
   */
  function pad (value='',
                widthMin:Number=0,
                // Why can't I say Number?=null
                decMax=null,
                pad:String=' ',
                sign:String='-',
                radix:Number=10,
                force:Boolean=false) {
    var isNumber = typeof(value) == 'number';
    // coerce to be string
    if (isNumber) {
      if (decMax != null) {
        var precision = Math.pow(10, (- decMax));
        value = Math.round(value/precision)*precision;
      }
      value = Number(value).toString(radix);
      if (sign != '-') {
        if (value.indexOf('-') != 0) {
          if (value != 0) {
            value = sign + value;
          } else {
            // ' 0' not '+0'
            value = ' ' + value;
          }
        }
      }
    } else {
      value = '' + value;
    }
    var strlen = value.length;
    // enforce precision
    if (decMax != null) {
      if (isNumber) {
        var decimal = value.lastIndexOf('.');
        if (decimal == -1) {
          var decimals = 0;
          if (force || (decMax > 0)) {
            value += '.';
          }
        } else {
          var decimals = strlen - (decimal + 1);
        }
        if (decimals > decMax) {
          value = value.substring(0, strlen - (decimals - decMax));
        } else {
          for (var i = decimals; i < decMax; i++) value += '0';
        }
      } else {
        value = value.substring(0, decMax);
      }
    }
    // enforce minimum width
    strlen = value.length;
    var leftJustify = false;
    if (widthMin < 0) {
      widthMin = (- widthMin);
      leftJustify = true;
    }
    if (strlen >= widthMin) {
      return value;
    }
    if (leftJustify) {
      for (var i = strlen; i < widthMin; i++) value = value + ' ';
    } else {
      sign = null;
      if (pad != ' ') {
        // Need to move sign to left of padding
        if (" +-".indexOf(value.substring(0, 1)) >= 0) {
          sign = value.substring(0, 1);
          value = value.substring(1);
        }
      }
      for (var i = strlen; i < widthMin; i++) value = pad + value;
      if (sign != null) {
        value = sign + value;
      }
    }
    return value;
  }

  /**
   * Formatted output to string
   *
   * Formats its arguments according to the control string.
   *
   * The standard <code>printf</code> conversions are accepted, with
   * the exception of `a`, `n`, and `p`.  `e`, `f`, and `g`
   * conversions are accepted but equivalent to `f`.  The `h` and `l`
   * length modifiers are accepted but ignored.  No errors are
   * signalled for invalid format controls or insufficient
   * arguments.
   *
   * If the Debugger is present, There is an additional format
   * specifier `w` that formats the argument as if by `Debug.__String`
   * with the 'pretty'.  If alternate format is requested (#), `w` uses the
   * full `Debug.__String` format used by <xref
   * linkend="Debug+debug.write"/>.  `%w` format obeys <xref
   * linkend="Debug+debug.printLength"/>.  If a precision is specified,
   * that is used as printLength.
   *
   * When used to format a Debugger message, any Object that is
   * formatted by `s` or `w` will create a link that can be clicked on
   * to inspect the object.  There is an additional modifier for the
   * `w` format (=) which will take the next argument as the object to
   * be represented (i.e., linked to) by the formatted string; thus
   * permitting custom representations.
   *
   * @param String control: A control string where % indicates a
   * subsequent argument is to be substituted.
   *
   * @param Array * args: arguments to be formatted according to the
   * control string.
   *
   * @return LzMessage: the return value is an LzMessage which can be
   * coreced to a string or HTML (the latter supports the hot-linking
   * feature).
   *
   * @devnote For backwards compatibility with <xref
   * linkend="Debug+debug.write"/>, if control is not a string or
   * control has no formatting directives but there are multiple
   * arguments, all the arguments are emitted separated by spaces.
   */
  function formatToString (control='', ...args) {
    var al = args.length;
    // 'write compatibility mode': control is not a string or # of
    // arguments is incompatible with control directives.
    if ((! (typeof control == 'string' || control instanceof String)) ||
        ((al > 0) != (control.indexOf('%') >= 0))) {
      // Process each value to individually so they can be
      // 'presented' as objects if applicable
      args.unshift(control);
      al++;
      var out = new LzMessage;
      for (var i = 0; i < al; i++) {
        var arg = args[i];
        var sep = ((i == (al-1)) ? '\n' : ' ');
        out.append(arg);
        // separator is always pretty
        out.appendInternal(sep);
      }
      return out;
    }
    // Normal mode
    var ctrl = '' + control;
    // Zero-based
    var argno = 0;
    function getarg(i) {
      if (i >= al) {
        if ($debug) {
          Debug.warn("%#0.48w: insufficient arguments", control);
        }
        return null;
      }
      return args[i];
    }
    var base = 0, limit = ctrl.length;
    var start = 0, end = 0;
    var out = new LzMessage();
    while (start < limit) {
      end = ctrl.indexOf('%');
      if (end == -1) {
        out.append(ctrl.substring(start, limit));
        break;
      }
      out.append(ctrl.substring(start, end));
      // skip %
      base = end;
      start = end + 1;
      end = end + 2;
      var sign = '-';
      var pad = ' ';
      var alternate = false;
      var length = '';
      var precision = null;
      var directive = null;
      // The object that is to be represented
      var object = null;
//       var extra = null;
      while ((start < limit) &&
             // swf7 (! directive)
             (directive == null)) {
        var char = ctrl.substring(start, end);
        start = end++;
        // This is a little sloppy.  It will parse valid options,
        // but also permits invalid ones, whose behaviour is
        // undefined.
        switch (char) {
          case '-':
            length = char;
            break;
          case '+': case ' ':
            sign = char;
            break;
          case '#':
            alternate = true;
            break;
          case '0':
            if (length === '' && precision === null) {
              pad = char;
              break;
            }
          case '1': case '2': case '3': case '4': case '5':
          case '6': case '7': case '8': case '9':
            if (precision !== null) {
              precision += char;
            } else {
              length += char;
            }
            break;
          case '$':
            // $ is 1-based, argno is 0-based
            argno = length-1;
            length = '';
            break;
          case '*':
            if (precision !== null) {
              precision = getarg(argno);
              argno++;
            } else {
              length = getarg(argno);
              argno++;
            }
            break;
          case '.':
            precision = '';
            break;
          case 'h': case 'l':
            break;
          case '=':
            // Take the next argument to be the object represented
            object = getarg(argno);
            argno++;
            break;
//           case '{':
//             // Look for a match
//             var close = ctrl.indexOf('}', start);
//             if (close > start) {
//               extra = ctrl.substring(start, close);
//               start = close + 1;
//               end = start + 1;
//               break;
//             }
//             // Otherwise fall through
          default:
            directive = char;
            break;
        }
      }
      var value = getarg(argno);
      if (object == null) { object = value; }
      // set decimals
      var decimals = null;
      var force = false;
      // NOTE: [2006-11-17 ptw] Number("010") -> 8 in swf, 10 in ECMA,
      // hence use null/'' as flag not ''/'0'
      if (precision !== null) {
        decimals = 1 * precision;
      } else {
        switch (directive) {
          case 'F': case 'E': case 'G':
          case 'f': case 'e': case 'g':
            decimals = 6;
            force = alternate;
            break;
          case 'O': case 'o':
            if (alternate && value != 0) {
              out.append('0');
            }
            break;
          case 'X': case 'x':
            if (alternate && value != 0) {
              out.append('0' + directive);
            }
            break;
        }
      }
      // set radix
      var radix = 10;
      switch (directive) {
        case 'o': case 'O':
          radix = 8;
          break;
        case 'x': case'X':
          radix = 16;
          break;
      }
      //     Debug.write('directive', directive, 'value', value, 'length', length,
      //                 'decimals', decimals, 'pad', pad, 'sign', sign, 'radix', radix);
      // 'unsigned'
      switch (directive) {
        case 'U': case 'O': case 'X':
        case 'u': case 'o': case 'x':
          if (value < 0) {
            value = (- value);
            // NOTE: [2006-11-17 ptw] Number('') -> NaN in swf, 0 in
            // ECMA, hence use parseInt
            var wid = Math.abs(parseInt(length));
            if (isNaN(wid)) {
              wid = Number(value).toString(radix).length;
            }
            var max = Math.pow(radix, wid);
            value = max - value;
          }
          break;
      }
      //     Debug.write('directive', directive, 'value', value, 'length', length,
      //                 'decimals', decimals, 'pad', pad, 'sign', sign, 'radix', radix);
      // do the directive
      // e, f, and, g could be implemented with toExponential or
      // toPrecision if they existed in the runtime.
      switch (directive) {
        case 'D': case 'U': case 'I': case 'O': case 'X': case 'F': case 'E': case 'G':
          value = Number(value);
          out.appendInternal(this.pad(value, length, decimals, pad, sign, radix, force).toUpperCase(), object);
          argno++;                  // consume value
          break;
        case 'c':
          value = String.fromCharCode(value);
        case 'w':
          if ($debug) {
            var width = decimals || Debug.printLength;
            // alternate => Debug.write => pretty but unique (see
            // LzMessage.append)
            // We let __String abbreviate, for best legibility
            out.appendInternal(this.pad(Debug.__String(value, true, width, alternate),
                                        length, null, pad, sign, radix, force),
                               object);
            argno++;                  // consume value
            break;
          }
        case 's':
          // TODO: [2006-06-01 ptw] Generalize this to write 'pretty'
          // values for all
          var str;
          if (value instanceof Function) {
            if ($debug) {
              str = this.functionName(value);
            }
            if (! str) {
              str =  'function () {...}';
            }
          } else if (typeof value == 'number') {
            // Must convert number to string for proper padding
            str = Number(value).toString(radix);
          } else {
            str = '' + value;
          }
          out.appendInternal(this.pad(str, length, decimals, pad, sign, radix, force),
                             object);
          argno++;                  // consume value
          break;
        case 'd': case 'u': case 'i': case 'o': case 'x': case 'f': case 'e': case 'g':
          value = Number(value);
          out.appendInternal(this.pad(value, length, decimals, pad, sign, radix, force), object);
          argno++;                  // consume value
          break;
        case '%':
          out.append('%');
          break;
        default:
          // treat unknown directive as literal
          out.append(ctrl.substring(base, start));
          break;
      }
      ctrl = ctrl.substring(start, limit);
      base = 0, limit = ctrl.length;
      start = 0, end = 0;
    }
    if (argno < al) {
      if ($debug) {
        Debug.warn("%#0.48w: excess arguments", control);
      }
      // Output excess in 'write compatibility' mode
      out.appendInternal(' ');
      for (; argno < al; argno++) {
        var arg = getarg(argno);
        var sep = ((argno == (al-1)) ? '\n' : ' ');
        out.append(arg);
        out.appendInternal(sep);
      }
    }

    return out;
  }

};

