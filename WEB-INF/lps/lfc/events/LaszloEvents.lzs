/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @affects lzevent lzdelegate
  * @topic LFC
  * @subtopic Events
  * @access public
  */

/**
  * <p>A delegate is an object that calls a specific method on a
  * specific object when its execute method is called. It is
  * essentially a method closure.</p>
  *
  * <p>Delegates, along with <xref linkend="LzEvent"/>, comprise
  * Laszlo's point to point event system. A delegate represents a
  * named method of an object. Delegates are mostly registered with
  * events, but they can be used anywhere a function callback would
  * traditionally be called for: for instance, <xref
  * linkend="LzTimerService.prototype.addTimer"/> takes a delegate as
  * its argument.</p>
  *
  * <p>You can create a delegate explicitly using the <classname
  * link="true">LzDelegate</classname> class, or implicitly by
  * specifying an event handler.  There are two syntaxes with which
  * you can specify an event handler: in the open tag used to create
  * that object, or by using the <tagname
  * link="true">handler</tagname> tag in the body of the object.</p>
  *
  * <p>To specify an event handler in an open tag, simply include it
  * like any other attribute.</p>
  *
  * <programlisting class="code" extract="false"><![CDATA[
  * <view onmouseover="doSomething()">
  *   <method name="doSomething">
  *     // code to be executed when mouse is over the view
  *   </method>
  * </view>
  * ]]></programlisting>
  *
  * <p>To specify an event hander using the <tagname
  * link="true">handler</tagname> tag, you include it in the body of
  * the object.</p>
  *
  * <programlisting class="code" extract="false"><![CDATA[
  * <view>
  *  <handler name="onmouseover">
  *    // code to be executed when the mouse is over the view
  *  </name>
  * </view>
  * ]]></programlisting>
  *
  * <p>The above two examples are functionally equivalent.  Using the
  * <tagname>handler</tagname> tag, however, can often lead to more
  * readable code because it removes clutter from the object creation
  * tag.  This is especially true if the handler code is complex.</p>
  *
  * <p><em>Note:</em> When creating a delegate explicitly using
  * <code>new LzDelegate</code>, <code>methodName</code> must be a
  * method of one parameter, because it will be invoked by <xref
  * linkend="LzDelegate.prototype.execute" /> with one argument
  * (typically the argument that is passed to <xref
  * linkend="LzEvent.prototype.sendEvent" /> when that delegate is
  * registered to receive events).  Similarly, when specifying an
  * event handler method using <code>&lt;handler
  * ... method="methodName" /&gt;</code>, the handler method must
  * accept one argument (even if it ignores it).</p>
  *
  * <p>See also the code examples at <xref linkend="LzEvent"/> and the
  * Developer's Guide for more detailed information on using events
  * and delegates.</p>
  *
  * @shortdesc The receiver in Laszlo's point-to-point event system.
  * @lzxname handler
  * @see LzEvent
  *
  * @devnote This class is only dynamic because it uses itself as an
  * array to track the events it is registered to.  It would probably
  * be better to store that array as a property, and only create the
  * array if you are actually registered to more than one event.
  */
public dynamic final class LzDelegate {
    /** @access private */
    var __delegateID:int = 0;

  /**
   * Create an LzDelegate
   *
   * @param LzEventable context: The object whose method will be called by execute.
   * @param String methodName: The name of the method to call (a
   * string). Must be a method of one parameter.
   * @param LzEventable eventSender: (Optional) The sender of the event to register the
   * new delegate for.
   * @param String eventName: (Optional, but required if eventSender is used) The name
   * of the event to register the new delegate for.
   */
  public function LzDelegate (context:LzEventable, methodName:String, eventSender:LzEventable = null, eventName:String = null) {
    super();
    if ($swf9) {
      // This type-check is superfluous in JS2, but we want it as an
      // aid to portability in JS1
    } else if (context is LzEventable) {
      // Ok
    } else if ($debug) {
      // This causes too many warnings right now
//       Debug.error("Invalid context: %w (for method %s)", context, methodName);
      // We proceed anyways below, for back-compatibility
    }
    this.c = context;
    var m = context[methodName];
    if (m is Function) {
      this.m = m;
    } else if ($debug) {
      Debug.error("Invalid delegate: %s.%s => %w (must be a Function)", context, methodName, m);
    }
    if ( eventSender != null ){
      this.register( eventSender , eventName );
    }

    this.__delegateID = LzDelegate.__nextID++;
  }

/** @access private */
    static var __nextID:int = 1;

/** The context in which to call the method
 * @access private
 * @type Object
 */
var c;

/** The method to call (will be applied to context)
 * @access private
 * @type String
 */
var m;

/** @access private */
var lastevent = 0;
/** @access private */
var enabled = true;
/** @access private */
var event_called = false;

/**
  * Executes the named method in the given context with the given data. Returns
  * the result of the call.
  *
  * @param * eventValue: The data with which to call the method.
  * @return *: The value returned by the method call.
  */
public function execute (eventValue){
    // Don't execute if context has been deleted, as that could
    // 'resurrect' the deleted view, causing a memory leak
    // Usually this is because a deleted view has idle or timer events
    // still registered.
    var context = this.c;
    if (this.enabled && context) {
        if (context['__LZdeleted']) {
            return;
        }
        var m = this.m;
        return m && m.call(context, eventValue);
    }
}

/**
  * Registers the delegate for the named event in the given
  * context.
  *
  * @param LzEventable eventSender: The object which publishes the event.
  * @param String eventName: The name of the event to register for.
  *
  * @devnote An event is initially declared to contain the sentinel
  * value LzDeclaredEvent which is of the correct type, but does not
  * actually support registering for and sending events.  When a
  * delegate attempts to register on this sentinel, the sentinel will
  * automatically be replaced with a functional LzEvent.
  */
  public function register ( eventSender:LzEventable , eventName:String) {
    if ($swf9) {
      // This type-check is superfluous in JS2, but we want it as an
      // aid to portability in JS1
    } else if (eventSender is LzEventable) {
      // Ok
    } else if (! eventSender) {
      if ($debug) {
        Debug.error('Invalid event sender: %w (for event %s)', eventSender, eventName);
      }
      return;
    } else if ($debug) {
      // This causes too many warnings right now
//       Debug.error('Invalid event sender: %w (for event %s)', eventSender, eventName);
      // We proceed anyways, for back-compatibility
    }

    var anEvent = eventSender[ eventName ];

    var m = this.m;
    if (m && m.length != 1) {
      if ($debug) {
        Debug.warn("Invalid delegate: %#w (must accept one argument to handle %w.%s)",
                   m, eventSender, eventName);
      }
      if ($swf9) {
        var a = new Array(m.length);
        this.m = function (ignore:*) { return m.apply(this, a); }
      }
    }

    if (! (anEvent is LzEvent)){
      if ($debug) {
        if (anEvent && (! (anEvent is LzDeclaredEventClass))) {
          Debug.error("Invalid event: %w.%s => %w", eventSender, eventName, anEvent);
        }
      }
      anEvent = new LzEvent( eventSender, eventName , this );
    } else {
      anEvent.addDelegate( this );
    }

    this[ this.lastevent++ ] = anEvent;
  }

/**
  * Unregisters the delegate for all of the events it is registered for.
  */
public function unregisterAll ( ){
    for (var i = 0; i< this.lastevent ; i++){
        this[ i ].removeDelegate( this );
        this[ i ] = null;
    }
    this.lastevent = 0;
}

/**
  * Unregisters the delegate for the given event
  * @param LzEvent event: The event to unregister the delegate from.
  *                       (e.g.  myview.onmouseup)
  */
public function unregisterFrom ( event ){
    var keep = [];
    for (var i = 0; i< this.lastevent ; i++){
        var ev = this[ i ];
        if ( ev == event ){
            ev.removeDelegate( this );
        } else {
            keep.push( ev );
        }
        this[ i ] = null;
    }
    //now fix it
    this.lastevent = 0;
    var l = keep.length;
    for ( var i = 0; i < l; i++ ){
        this[ this.lastevent++ ] = keep[ i ];
    }
}

/**
  * Disables the delegate until enable method is called.
  */
public function disable (){
    this.enabled = false;
}

/**
  * Enables a delegate that has been disabled
  */
public function enable (){
    this.enabled = true;
}

  /**
   * Queue for delegates that are deferred during node initialization
   * @access private
   */
  static var __LZdelegatesQueue = [];

  /**
   * Drain the delegates queue back to position POS
   * @access private
   */
  static function  __LZdrainDelegatesQueue (pos) {
    var evq = LzDelegate.__LZdelegatesQueue;
    var n = evq.length;
    var i = pos;
    if (i < n) {
      var calledDelegates = new Array;
      var lockedEvents = new Array;
      while (i < n) {
        var e = evq[i];
        var d = evq[i+1];
        var eventValue = evq[i+2];
        // Mimic sendEvent which prohibits events and delegates from
        // recursing
        e.locked = true;
        lockedEvents.push(e);
        if (! d.event_called) {
          d.event_called = true; //this delegate has been called
          calledDelegates.push( d );
          // d.execute( eventValue ); inlined
          if (d.c && ! d.c.__LZdeleted && d.m) d.m.call(d.c, eventValue);
        }
        i+=3;
      }
      while (d = calledDelegates.pop()) {
        d.event_called = false;
      }
      while (e = lockedEvents.pop()) {
        e.locked = false;
      }
    }
    evq.length = pos;
  }

/** @access private */
function toString (){
    return ("Delegate for " + this.c + " calls " + this.m + " " + this.__delegateID );
}

if ($debug) {
/**
  * If debugging, add an informative name
  * @access private
  */
function _dbg_name (){
    var name = Debug.formatToString("%0.48w.%s()", this.c, this.m);
    if (this[0]) {
      name += Debug.formatToString("/* handles %w%s */", this[0], this[1]?" ...":"");
    }
    return name;
}
}

} // End of LzDelegate


/**
  * <p>Events underly most of the functionality in OpenLaszlo
  * applications.  Unlike events in similar systems, OpenLaszlo's
  * events are point-to-point, meaning that there is no general
  * broadcast mechanism for events, and events do not trickle up or
  * down the instance hierarchy. Instead, objects called <xref
  * linkend="LzDelegate"/>s use <xref
  * linkend="LzDelegate.prototype.register"/> to register to receive
  * events.</p>
  *
  * <p>An event is implicitly declared for every attribute of a class
  * or instance and sent when that attribute is changed.  So, for
  * instance, if a class has an attribute <code>foo</code>, you can
  * receive events when foo changes by registering for the
  * <code>onfoo</code> event.</p>
  *
  * <p>Events are sent with a single argument, which usually conveys
  * information about the property that changed. The default behavior
  * of the <xref linkend="LzEventable.prototype.setAttribute"/> method is
  * to set the named property and send the event called "on" +
  * property. This is general mechanism that updates constraints in a
  * OpenLaszlo programs. For instance, when a view changes its
  * <attribute>x</attribute> position, it sends the event
  * <event>onx</event> with the new value for its
  * <attribute>x</attribute> property.</p>
  *
  * <example class="program"
  *          title="Event sending in response to setting an attribute"><![CDATA[
  * <canvas height="40">
  *   <simplelayout/>
  *   <button name="eventSender"
  *           onmouseover="this.setAttribute('avalue', this.avalue + 10)"
  *           onmouseout="this.setAttribute('avalue', this.avalue + 5)">
  *     <attribute name="avalue" value="0"/>
  *   </button>
  *
  *   <view bgcolor="red" width="20" height="20">
  *     // Handle the implicit `onavalue` event of the `eventSender` button
  *     <handler name="onavalue" reference="eventSender" args="v">
  *       this.setAttribute('x' , v);
  *     </handler>
  *
  *   </view>
  * </canvas>
  *]]> </example>
  *
  * <p>An event can be explicitly declared using the <tagname
  * link="true">event</tagname> tag and the <method>sendEvent</method>
  * method is used to explicitly send an event.</p>
  *
  * <example class="program"
  *          title="A simple example of publishing and listening for a custom event"><![CDATA[
  * <canvas height="140" debug="true">
  *   <simplelayout/>
  *   <button name="eventSender"
  *           onmouseover="this.customevent.sendEvent('over')"
  *           onmouseout="this.customevent.sendEvent('out')">
  *     <event name="customevent"/>
  *   </button>
  *
  *   <view bgcolor="red" width="20" height="20">
  *     <handler name="customevent" reference="eventSender" args="event">
  *       Debug.debug("event: %s", event);
  *       this.setAttribute('x', this.x + 10);
  *     </handler>
  *   </view>
  * </canvas>
  * ]]></example>
  *
  * <p>Sending an event that no delegate is listening for has nearly
  * no cost, thus objects can freely publish events.</p>
  *
  * <p>See the Developer's Guide for more detailed information on
  * using events and delegates.</p>
  *
  * @shortdesc The sender in Laszlo's point-to-point event system.
  * @lzxname event
  * @see LzDelegate
  */
public final class LzEvent extends LzDeclaredEventClass {
    /** @access private */
    var delegateList:Array = null;

  /**
   * @param LzEventable eventSender: The owner of this event
   * @param String eventName: The name of this event.
   * @access private
   */
  function LzEvent ( eventSender:LzEventable , eventName:String , d:* = null) {
    super();
    var _evs = eventSender['_events'];
    if (_evs == null ){
      eventSender._events = [ this ];
    } else {
      _evs.push ( this );
    }
    eventSender[ eventName ] = this;
    if ( d ){
      this.delegateList = [d];
      this.ready = true;
    }else{
      this.delegateList = [];
    }
    // If debugging or profiling, add an informative name
    if ($debug) {
      this._dbg_eventSender = eventSender;
      this._dbg_eventName = eventName;
    }
    if ($profile) {
      this._dbg_profileName = eventName;
    }
  }

/** True when event is being sent.
  * @type Boolean
  * @access private
  */
    var locked:Boolean = false;

/**
  * Adds the given delegate to the event's delegate list. Should
  * rarely be called explicitly -- it is used exclusively by
  * <b><i>LzDelegate</i>.register</b>
  *
  * @param LzDelegate d: The delegate to add to the list of delegates called by the event.
  * @access private
  */
public function addDelegate (d){
    this.ready = true;
    this.delegateList.push(d);
}

/**
 * Sends an event to all the delegates that are registered to receive
 * this event.  Each registered delegate's method will be called with
 * the single argument of sendEvent.
 *
 *  @param * eventValue: (Optional) The value to pass when executing
 *  the delegates registered to receive the event.  If omitted,
 *  <code>null</code> will be sent.
 */
public override function sendEvent ( eventValue = null ){
    if ( this.locked ) { return; } //don't allow for multiple calls

    var dll = this.delegateList.length;
    if (dll == 0) { return; }

    if ($profile) {
        var nm = this._dbg_profileName;

        if (nm) {
            Profiler.event(nm, 'calls');
        }
    }

    this.locked = true;

    var calledDelegates = new Array;

    var d;
    var evq = LzDelegate.__LZdelegatesQueue;
    for (var i = dll; i >= 0; i--){
        d = this.delegateList[ i ];
        //pointer may be bad due to deletions
        if ( d && d.enabled && (! d.event_called)){
            d.event_called = true; //this delegate has been called
            calledDelegates.push( d );
            // We _do_ worry about deleted contexts to make sure that
            // executing a delegate does not resurrect one!
            var c = d.c;
            if (c && (! c.__LZdeleted)) {
                if (c.__LZdeferDelegates) {
                  evq.push(this, d, eventValue);
                } else if (d.m) {
                  // d.execute( eventValue ); inlined
                  d.m.call(c, eventValue);
                }
            }
        }
    }

    while (d = calledDelegates.pop() ){
        d.event_called = false;
    }

    if ($profile) {
        var nm = this._dbg_profileName;
        if (nm) {
            Profiler.event(nm, 'returns');
        }
    }

    this.locked = false;
}

/**
  * Removes the delegate from the delegate list. In practice, this is rarely
  * called explicitly, since it does not update the delegate's list of stored
  * events. Right now, this is called only by <b><i>LzDelegate</i>.
  * unregisterAll</b> Delegates should support a simple unregister command, that
  * unregisters them for a single event, but to date, that has not proven
  * necessary
  *
  * @param LzDelegate d: The delegate to remove from the delegateList.
  * @access private
  */
public override function removeDelegate ( d = null ){
    var dll = this.delegateList.length;
    for (var i = 0; i < dll; i++){
        if (this.delegateList[i] === d){
            this.delegateList.splice(i, 1);
            break;
        }
    }
    if ( this.delegateList.length == 0 ){
        this.ready = false;
    }
}

/**
  * Removes all delegates from this event
  * @access private
  */
public override function clearDelegates (){
    while (this.delegateList.length ){
        this.delegateList[ 0 ].unregisterFrom( this );
    }
    //this.delegateList = [];
    this.ready = false;
}

/**
  * Returns the number of delegates registered for the event
  * @return Number: The number of delegates registered for the event.
  * @access private
  */
override public function getDelegateCount ( ){
    return this.delegateList.length;
}

/** @access private */
public override function toString (){
    return ( "LzEvent");
}

if ($debug) {
/**
  * If debugging, add an informative name
  * @access private
  */
override function _dbg_name (){
    return Debug.formatToString("%0.48w.%s", this._dbg_eventSender, this._dbg_eventName);
}
}

} // End of LzEvent
