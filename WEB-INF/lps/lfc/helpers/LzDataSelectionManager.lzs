/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @affects lzdataselectionmanager
  * @access public
  * @topic LFC
  * @subtopic Helpers
  */

/**
  * <p>If a datapath's <classname>datapath.replication</classname> attribute is set to "lazy", then a match to 
  * multiple nodes will create an <sgmltag class="element" role="LzLazyReplicationManager">LzLazyReplicationManager</sgmltag> 
    instead of an <sgmltag class="element" role="LzReplicationManager">LzReplicationManager</sgmltag>. 
  * The lazy replication manager creates only enough replicated views in order to display the data, 
  * so there is not a view for each data node. This enables the display of very large datasets. 
  * </p>
  * <p>
  * With lazy replication you must use a <classname>LzDataSelectionManager </classname>instead of a <sgmltag class="element" role="LzSelectionManager">LzSelectionManager</sgmltag>. 
  * The <classname>LzDataSelectionManager</classname> will operate on the data itself, instead of on the views (which 
  * may not be present if the data has scrolled out of view). For each dataset you are controlling, 
  * you can have only one <classname>LzDataSelectionManager</classname> operating on it. 
  * </p>
  * <p>As with a LzSelectionManager, ctrl-click will select multiple items and shift-click will 
  * select a range. To modify this behavior, you can extend the <classname>LzDataSelectionManager</classname> and implement 
  * <method>isRangeSelect</method> and <method>isMultiSelect</method>.</p>
  * <example class="program" id="datasenectionmgr">
  * &lt;canvas width="200" height="200"&gt;
  *   &lt;dataset name="mydata"&gt;
  *     &lt;list&gt;
  *       &lt;item&gt;tricycle&lt;/item&gt;
  *       &lt;item&gt;train&lt;/item&gt;
  *       &lt;item&gt;racecar&lt;/item&gt;
  *       &lt;item&gt;scooter&lt;/item&gt;
  *       &lt;item&gt;bicycle&lt;/item&gt;
  *       &lt;item&gt;rollerblades&lt;/item&gt;
  *       &lt;item&gt;iceskates&lt;/item&gt;
  *       &lt;item&gt;minivan&lt;/item&gt;
  *       &lt;item&gt;sailboat&lt;/item&gt;
  *       &lt;item&gt;motorboat&lt;/item&gt;
  *     &lt;/list&gt;
  *   &lt;/dataset&gt;
        
  *   &lt;class name="selectme" onclick="immediateparent.selector.select(this)"
        height="17" width="100" bgcolor="white"&gt;
  *     &lt;text datapath="text()"/&gt;
  *     &lt;method name="setSelected" args="isselected"&gt;
        if (isselected) setAttribute('bgcolor', yellow);
        else setAttribute('bgcolor', white);
  *     &lt;/method&gt;
  *   &lt;/class&gt;
        
  *   &lt;view height="70" clip="true"&gt;
  *     &lt;view&gt;
  *       &lt;dataselectionmanager name="selector"/&gt;
  *       &lt;selectme&gt;
  *         &lt;datapath xpath="mydata:/list/item/" replication="lazy"/&gt;
  *       &lt;/selectme&gt;
  *       &lt;simplelayout/&gt;
  *     &lt;/view&gt;
  *     &lt;scrollbar/&gt;
  *     &lt;/view&gt;
  * &lt;/canvas&gt;
  * </example>
  *
  * @shortdesc A selection manager for views generated by a lazily-replicated datapath
  * @lzxname dataselectionmanager
  *
  */
    
class LzDataSelectionManager extends LzSelectionManager {

function LzDataSelectionManager ( parent:LzNode? = null , attrs:Object? = null , children:Array? = null, instcall:Boolean  = false) {
    super(parent,attrs,children,instcall);
}


/** @access private
  * @modifiers override 
  */
static var tagname = 'dataselectionmanager';
/** @access private */
  static var attributes = new LzInheritedHash(LzSelectionManager.attributes);

/** @access private
  */
var manager;

/** @access private
  */
var singleClone;

/**
  * Makes the given view selected
  * @access private
  * @param LzView o: The view to be selected
  */
override function makeSelected ( o ){
    var so = o.datapath.p;
    if ( this.manager == null ) this.manager = o.cloneManager; 
    if ( so.sel ) return; 
    so.sel = true;
    this.selected.push( so );
    o.datapath[ this.sel ]( true );    
    
    if ( this.manager == null ){
        //just one "clone", mark it!
        this.singleClone = o;
    }
}

/**
  * Unselect the given view
  * @param LzView o: The view to be unselected
  */
override function unselect ( o ){
    if ( this.manager == null ) this.manager = o.cloneManager;//try to get a cloneManager  

    var so = o.datapath.p;
    so.sel = false;
    for ( var i = this.selected.length-1 ; i >= 0; i-- ){
        if ( this.selected[ i ] == so ) {
            this.selected.splice( i , 1 );
            break;
        }
    }      
    o.datapath[ this.sel ]( false );
    
    if ( o == this.singleClone ) this.singleClone = null;//clear "singleClone"
}

/**
  * Selects the range between the datapath that was lastselected and the newly
  * selected view
  * @access private
  * @param LzDataPath s: The datapath that was at top of the selection stack
  * @param LzView e: The newly selected view
  */
override function selectRange ( s , e ){
    if ( this.manager == null ){        
        this.manager = e.cloneManager;
        
        //maybe we've got now clones
        if ( this.manager == null ){
        //still no clones?          
        //so it's nothing to do, just hope so...
        if ( $debug ){
            Debug.write( "selectRange failed, no clones" );
        }
        return;
        }
    }
    
    var nodes = this.manager.nodes;

    var st = -1;
    var en = -1;
    var i  = 0;
    var ennode = e.datapath.p;
    //find the start and end in the sort array of parents

    while ( ( st == -1 || en == -1 ) && i < nodes.length ){
        if ( nodes[ i ] == s ){
            st = i;
        } 
        if ( nodes[ i ] == ennode ){
            en = i;
        } 
        i++;
    }

        
    var dir = st > en ? -1 : 1;
    
    this.clearSelection();

    this.lastRange = s;

    //couldn't find -- wierd
    if ( st == -1 || en == -1 ) return;
    
    for ( var i = st; i != en + dir; i += dir ) {
        var p = nodes[ i ];
        p.sel = true;
        this.selected.push( p );
        this.__LZsetSelected( p, true );
    }
}

/**
  * Returns a list of datapointers, which point to the selected records
  * @return Array: A list of datapointers
  */
override function getSelection (){
    var r = [];
    for ( var i = 0; i < this.selected.length ; i++ ){
        r.push( new LzDatapointer( null , {pointer : this.selected[i] }));
    }
    return r;    
}

/**
  * Unselects everything that is currently selected and clears the selection
  * list
  * 
  */
override function clearSelection ( ){
    while ( this.selected.length ){
        var p  = this.selected.pop();
        p.sel = false;
        this.__LZsetSelected( p , false );
    }
    this.lastRange = null;
}
        
/**
  * Tests whether the given view is selected
  * @param LzView o: The view to test for selectedness
  * @return Boolean: The selectedness of the input object.
  */
override function isSelected ( o){
    if ( this.manager == null ) this.manager = o.cloneManager;//try to get a cloneManager

    return o.datapath.p.sel;
}

/**
  * sets the selected attribute of the data, if there is a clone, it will
  * call <method>setSelected(Boolean)</method> on the clone's datapath
  * @param LzDataElement p: the node we want to set
  * @param Boolean val: new value for selected
  * @access private
  */
function __LZsetSelected ( p, val ){
    if ( this.manager != null ){
        var cl = this.manager.getCloneForNode( p, true );
        if ( cl ){
            cl.datapath[this.sel]( val );
        } else { // no clone on screen
            p.sel = val;
        }
    } else {//no clones
        //if caller is selectRange, then "this.manager" won't be "null"
        //but if caller is clearSelection, "this.manager" could be "null", but then "val" is definitely "false"
        if ( !val ){
            if ( this.singleClone != null && this.singleClone.datapath.p == p ){
                this.singleClone.datapath[this.sel]( false );
                this.singleClone = null;
                return;//job is done...
            }
        }
        p.sel = val;//default action
    }
}

} // End of LzDataselectionmanager
