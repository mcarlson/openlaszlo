/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @affects lzdataselectionmanager
  * @access public
  * @topic LFC
  * @subtopic Helpers
  */

/**
  * <p>If a datapath's <classname>datapath.replication</classname> attribute is set to "lazy", then a match to
  * multiple nodes will create an <sgmltag class="element" role="LzLazyReplicationManager">LzLazyReplicationManager</sgmltag>
    instead of an <sgmltag class="element" role="LzReplicationManager">LzReplicationManager</sgmltag>.
  * The lazy replication manager creates only enough replicated views in order to display the data,
  * so there is not a view for each data node. This enables the display of very large datasets.
  * </p>
  * <p>
  * With lazy replication you must use a <classname>LzDataSelectionManager </classname>instead of a <sgmltag class="element" role="LzSelectionManager">LzSelectionManager</sgmltag>.
  * The <classname>LzDataSelectionManager</classname> will operate on the data itself, instead of on the views (which
  * may not be present if the data has scrolled out of view). For each dataset you are controlling,
  * you can have only one <classname>LzDataSelectionManager</classname> operating on it.
  * </p>
  * <p>As with a LzSelectionManager, ctrl-click will select multiple items and shift-click will
  * select a range. To modify this behavior, you can extend the <classname>LzDataSelectionManager</classname> and implement
  * <method>isRangeSelect</method> and <method>isMultiSelect</method>.</p>
  * <example class="program" id="datasenectionmgr">
  * &lt;canvas width="200" height="200"&gt;
  *   &lt;dataset name="mydata"&gt;
  *     &lt;list&gt;
  *       &lt;item&gt;tricycle&lt;/item&gt;
  *       &lt;item&gt;train&lt;/item&gt;
  *       &lt;item&gt;racecar&lt;/item&gt;
  *       &lt;item&gt;scooter&lt;/item&gt;
  *       &lt;item&gt;bicycle&lt;/item&gt;
  *       &lt;item&gt;rollerblades&lt;/item&gt;
  *       &lt;item&gt;iceskates&lt;/item&gt;
  *       &lt;item&gt;minivan&lt;/item&gt;
  *       &lt;item&gt;sailboat&lt;/item&gt;
  *       &lt;item&gt;motorboat&lt;/item&gt;
  *     &lt;/list&gt;
  *   &lt;/dataset&gt;

  *   &lt;class name="selectme" onclick="immediateparent.selector.select(this)"
        height="17" width="100" bgcolor="white"&gt;
  *     &lt;text datapath="text()"/&gt;
  *     &lt;method name="setSelected" args="isselected"&gt;
        if (isselected) setAttribute('bgcolor', yellow);
        else setAttribute('bgcolor', white);
  *     &lt;/method&gt;
  *   &lt;/class&gt;

  *   &lt;view height="70" clip="true"&gt;
  *     &lt;view&gt;
  *       &lt;dataselectionmanager name="selector"/&gt;
  *       &lt;selectme&gt;
  *         &lt;datapath xpath="mydata:/list/item/" replication="lazy"/&gt;
  *       &lt;/selectme&gt;
  *       &lt;simplelayout/&gt;
  *     &lt;/view&gt;
  *     &lt;scrollbar/&gt;
  *     &lt;/view&gt;
  * &lt;/canvas&gt;
  * </example>
  *
  * @shortdesc A selection manager for views generated by a lazily-replicated datapath
  * @lzxname dataselectionmanager
  * @devnote: TODO: [20080930 anba] (LPP-6080) uncomment typing in method signatures
  */
public class LzDataSelectionManager extends LzSelectionManager {

    /** @access private */
    function LzDataSelectionManager (parent:LzNode? = null, attrs:Object? = null, children:Array? = null, instcall:Boolean = false) {
        super(parent, attrs, children, instcall);
    }

    /** @access private
      * @modifiers override
      */
    static var tagname :String = 'dataselectionmanager';

    /** @access private */
    static var attributes :Object = new LzInheritedHash(LzSelectionManager.attributes);

    /** @access private */
    var manager :LzReplicationManager;

    /** @access private */
    var singleClone :LzView;

    /**
      * Makes the given view selected
      * @access private
      * @param LzView o: The view to be selected
      */
    override function makeSelected (o:LzView) :void {
        if (this.manager == null) this.manager = o.cloneManager;//try to get a cloneManager

        var so /*:LzDataNodeMixin*/ = o.datapath.p;
        if (! so.sel) {
            so.sel = true;
            this.selected.push( so );
            if (this.manager == null) {
                //just one "clone", mark it!
                this.singleClone = o;
            }
            o.datapath.setSelected( true );
        }
    }

    /**
      * Unselect the given view
      * @param LzView o: The view to be unselected
      */
    override function unselect (o /*:LzView*/) :void {
        if (this.manager == null) this.manager = o.cloneManager;//try to get a cloneManager

        var sela:Array = this.selected;
        var so /*:LzDataNodeMixin*/ = o.datapath.p;
        for (var i:int = sela.length - 1; i >= 0; i--) {
            if (sela[ i ] === so) {
                so.sel = false;
                sela.splice( i, 1 );
                if (o == this.singleClone) this.singleClone = null;//clear "singleClone"
                o.datapath.setSelected( false );
                return;
            }
        }
    }

    /**
      * Selects the range between the datapath that was lastselected and the newly
      * selected view
      * @access private
      * @param LzDataNodeMixin s: The datanode that was at top of the selection stack
      * @param LzView e: The newly selected view
      */
    override function selectRange (s:*, e:LzView) :void {
        if (this.manager == null) {
            this.manager = e.cloneManager;

            //maybe we've got now clones
            if (this.manager == null) {
                //still no clones - so it's nothing to do
                return;
            }
        }

        var nodes:Array = this.manager.nodes;
        var st:int = -1;
        var en:int = -1;
        var ennode /*:LzDataNodeMixin*/ = e.datapath.p;
        //find the start and end in the sort array of parents
        for (var i:int = 0; i < nodes.length && (st == -1 || en == -1); i++) {
            if (nodes[ i ] === s) st = i;
            if (nodes[ i ] === ennode) en = i;
        }

        var dir:int = st > en ? -1 : 1;
        this.clearSelection();
        this.lastRangeStart = s;

        if (st != -1 && en != -1) {
            for (var i:int = st; i != en + dir; i += dir) {
                var p /*:LzDataNodeMixin*/ = nodes[ i ];
                p.sel = true;
                this.selected.push( p );
                this.__LZsetSelected( p, true );
            }
        }
    }

    /**
      * Returns a list of datapointers, which point to the selected records
      * @return Array: A list of datapointers
      */
    override function getSelection () :Array {
        var sela:Array = this.selected;
        var r:Array = [];
        for (var i:int = 0; i < sela.length; i++) {
            r.push( new LzDatapointer( null, {pointer : sela[i]} ) );
        }
        return r;
    }

    /**
      * Unselects everything that is currently selected and clears the selection
      * list
      */
    override function clearSelection () :void {
        var sela:Array = this.selected;
        this.selected = [];
        this.lastRangeStart = null;
        var p /*:LzDataNodeMixin*/;
        while (p = sela.pop()) {
            p.sel = false;
            this.__LZsetSelected( p, false );
        }
    }

    /**
      * Tests whether the given view is selected
      * @param LzView o: The view to test for selectedness
      * @return Boolean: The selectedness of the input object.
      */
    override function isSelected (o /*:LzView*/) :Boolean {
        if (this.manager == null) this.manager = o.cloneManager;//try to get a cloneManager

        return o.datapath.p.sel;
    }

    /**
      * sets the selected attribute of the data, if there is a clone, it will
      * call <method>setSelected(Boolean)</method> on the clone's datapath
      * @param LzDataNodeMixin p: the node we want to set
      * @param Boolean val: new value for selected
      * @access private
      */
    function __LZsetSelected (p /*:LzDataNodeMixin*/, val:Boolean) :void {
        if (this.manager != null) {
            var cl:LzNode = this.manager.getCloneForNode( p, true );
            if (cl) {
                cl.datapath.setSelected( val );
            } else {
                // no clone on screen
            }
        } else if (! val) {//no clones
            // the if-condition only yields true for clearSelection(), 
            // in which case we need to check the singleClone property
            var scl:LzView = this.singleClone;
            if (scl != null && scl.datapath.p === p) {
                this.singleClone = null;
                scl.datapath.setSelected( val );
            }
        }
    }

} // End of LzDataselectionmanager
lz[LzDataSelectionManager.tagname] = LzDataSelectionManager;  // publish
