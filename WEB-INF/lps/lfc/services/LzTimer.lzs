/**
 * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
 *            Use is subject to license terms.
 *
 * @affects lztimer
 * @topic LFC
 * @subtopic Services
 * @access public
 */

/**
 * <p>LzTimer is used to invoke functionality after a specific
 * amount of time. By using a <xref linkend="LzDelegate"/> to refer
 * to a particular method, and then by adding a timer to that
 * delegate, the developer can control the timing of the method's
 * start.  Use LzTimer to tweak sequence and timing of visual
 * animations, delay the effects of user events, or implement user
 * experiences with expiration features.</p>
 *
 * <p>It should be noted that the time passed to the LzTimer service
 * describes the time <i>before</i> which the delegate may not run --
 * it is not guaranteed that the delegate will run at that time.
 * Depending on application needs and client performance, the
 * specified delegate may be invoked at any time <i>after</i> the
 * amount of time specified.</p>
 *
 * <p>The following example displays some text when a button is
 * clicked, and uses LzTimer to fade the text away after three
 * seconds.</p>
 *
 * <example class="program" title="Using LzTimer to invoke method" id="lztimer-1"><programlisting><![CDATA[
 * <canvas height="50" >
 *     <button text="Show then Fade" onclick="showText()" />
 *     <text name="myText" opacity="0.0" bgcolor="#CCCCCC">The Invisible Man</text>
 *     <simplelayout axis="y" spacing="10" />
 *
 *     <method name="showText">
 *         myText.setAttribute( "opacity", 1.0 );
 *         LzTimerService.LzTimer.addTimer( new LzDelegate( this, "fadeText" ), 3000 );
 *     </method>
 *
 *     <method name="fadeText">
 *         myText.animate( "opacity", 0.0, 1000 );
 *     </method>
 * </canvas>
 * ]]></programlisting></example>
 *
 * @shortdesc Handles calling of a delegate after a specified number
 * of milliseconds.
 *
 * @devnote The timer calls a given delegate in a specified number of
 * miliseconds.
 *
 * @devnote Unfortunately the original semantics of LzTimer allows
 * one to add more than one timer to a single delegate, but only
 * allows one to remove the oldest timer from a delegate -- there's
 * no way of specifying which one.  The logic below is faithful to
 * the original while still attempting to be efficient. In the common
 * case of one timer per delegate, we simply store the timer id in
 * the delegate's timer list entry. If the program attempts to store
 * more than one timer with a single delegate, we shift to storing an
 * array of them in the timer list entry. This saves an array
 * allocation in the common single-timer case, at the cost of
 * increased code complexity.
 *
 */
class LzTimerService {
  /** @access private */
  var timerList = new Object;

  /**
   * The timer service.  Also available as the global
   * <code>LzTimer</code>.
   *
   * @type LzTimerService
   * @keywords readonly
   * @devnote this should be a public getter to enforce readonly
   */
  static var LzTimer:LzTimerService;

  /** @access private
   * @devnote AS3 does not allow private constructors, so we need the
   * error
   */
  function LzTimerService () {
    //    if (LzTimerService.LzTimer) {
    //      throw new Error("There can be only one LzTimer");
    //    }
  }
  // Create the singleton
  LzTimerService.LzTimer = new LzTimerService();

  /**
   * Adds a timer. Note: The timer guarantees that the delegate will
   * not be called before the number of milliseconds specified here,
   * but cannot guarantee that it will be called at exactly that time.
   *
   * @param LzDelegate d: The delegate to call when the timer expires
   * @param Number millisecs: The number of millisecondss to wait
   * before calling the delegate.
   */
  function addTimer ( d , millisecs ){
    var p = { 'delegate' : d };
    var f = function () {
      // This closure captures 'p', and relies on the fact that p.id will
      // have been set by the time the closure is invoked.

      // User LzTimer explicitly below; "this" is not the outer function's
      // this here.
      LzTimer.removeTimerWithID(p.delegate, p.id);
      var del = p.delegate;
      // Inlining LzDelegate.execute()
      if (del.enabled && del.c) {
        p.delegate.execute( (new Date()).getTime() );
        // TODO: inlining causes problems with DHTML
        //if (! del.c.__LZdeleted && del.c[del.f]) del.c[del.f]( (new Date()).getTime() );
      }
    }
    var id = LzTimeKernel.setInterval(f, millisecs);
    if ($debug) {
      // Debug.format("created timer %w for delegate %w\n", id, d);
      if (id instanceof Array)
        // we rely on the setInterval value being a non-array, otherwise
        // our storage scheme won't work. Error if this happens -- should only
        // occur when bootstrapping a new runtime.
        Debug.error("setInterval result type is unexpected; LzTimer will fail");
    }
    p.id = id;
    var tle = this.timerList[d.__delegateID];
    if (tle == null) {
      this.timerList[d.__delegateID] = id;
    } else if (! (tle instanceof Array)) {
      this.timerList[d.__delegateID] = [tle, id];
    } else {
      tle.push(id);
    }
    return id;
  }

  /**
   * Removes the first timer that calls the given delegate from the
   * timerlist.
   *
   * @param LzDelegate d: The delegate called by the timer to be
   * removed. If there are multiple timerList entries that call
   * delegate d, removes the first in the order received.
   */
  function removeTimer ( d ){
    var tle = this.timerList[d.__delegateID];
    var id = null;
    if (tle != null) {
      if (tle instanceof Array) {
        id = tle.shift();
        LzTimeKernel.clearInterval(id);
        if (tle.length == 0)
          delete this.timerList[d.__delegateID];
      } else {
        id = tle;
        LzTimeKernel.clearInterval(id);
        delete this.timerList[d.__delegateID];
      }
      // Debug.format("cleared timer %w for delegate %w (2)\n", id, d);
    }
    return id;
  }

  /**
   * Removes the timer with the given id that calls the given delegate from the
   * timerlist.
   *
   * @param LzDelegate d: The delegate called by the timer to be removed.
   * @param id: the id of the timer to remove.
   * @access private
   */
  function removeTimerWithID ( d, id ){
    var tle = this.timerList[d.__delegateID];
    if (tle != null) {
      if (tle instanceof Array) {
        var i = 0;
        for (i=0; i<tle.length; i++) {
          var id2 = tle[i];
          if (id2 == id) {
            LzTimeKernel.clearInterval(id);
            tle.splice(i,1);
            break;
          }
        }
        if (tle.length == 0)
          delete this.timerList[d.__delegateID];
      } else if (tle == id) {
        LzTimeKernel.clearInterval(id);
        delete this.timerList[d.__delegateID];
      }
    }
  }

  /**
   * Resets the timer for the given delegate to the new amount of
   * time. If a timer for the delegate is not found, a new timer is
   * created.
   *
   * @param LzDelegate d: The delegate whose timer to reset. If there
   * are multiple timers for this delegate, the first one is reset. If
   * this delegate is not found in the timer list, a new timer event
   * is created for it.
   *
   * @param millisecs: The number of milliseconds to wait before
   * calling the timer.
   */
  function resetTimer ( d  , millisecs ){
    this.removeTimer( d );
    return this.addTimer( d , millisecs );
  }

  if ($debug) {
    /**
     * Returns the number of timers registered for a delegate
     *
     * NOTE: Only available in debug mode.
     *
     * @param LzDelegate d: The delegate called by the timer to be
     * reset.
     */
    function countTimers ( d ){
      var tle = this.timerList[d.__delegateID];
      if (tle == null)
        return 0;
      else if (tle instanceof Array)
        return tle.length;
      else
        return 1;
    }
  }

} // End of LzTimerService

/**
 * @deprecated
 * @shortdesc Alias for <link linkend="LzTimerService">LzTimerService.LzTimer</link>
 */
var LzTimer:LzTimerService = LzTimerService.LzTimer;

