/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @affects lzhistory
  * @access public
  * @topic LFC
  * @subtopic Events
  */

/**
  * <p><code>lz.History</code> is the single instance of the class
  * <code>lz.HistoryService</code>.</p>
  *
  * <p>The lz.History service manages interaction with the browser history and back button.  Save state as often as you like, and advance the
  *  history when a new 'page' of values is required.</p>
  * 
  * <programlisting>
  * &lt;form&gt;
  *     &lt;input type="button" value="0" onclick="lzSetCanvasAttribute('foo', 0)"/&gt; 
  *     &lt;input type="button" value="1" onclick="lzSetCanvasAttribute('foo', 1)"/&gt; 
  * &lt;/form&gt;
  * </programlisting>
  *
  * @shortdesc Manages interaction with the browser history and back button.
  */

public class LzHistoryService extends LzEventable {
/**
  * true if history system is ready to receive events (for 3.x compatibility).  Use the lz.History.onready event instead.
  * @keywords deprecated  
  */
var isReady = false;
/**
  * true if history system is ready to receive events
  */
var ready = false;
/** Sent when history events are ready to be sent and received.
  * @lzxtype event
  * @access public
  */
var onready = LzDeclaredEvent;

/**
  * If true, persistence is on.
  * @type Boolean
  * @keywords readonly
  */
var persist = false;

/**
  * If set, use this persisted object.
  * @type Object
  * @keywords readonly
  */
var _persistso = null;

/**
  * The current offset (zero-based) in the history value stack.  Listen for the onoffset event to find out when lz.History value changes.
  * @type Number
  * @keywords readonly
  */
var offset = 0;
/** @access private */
var __lzdirty = false;
/** @access private */
var __lzhistq = [];
/** @access private */
var __lzcurrstate = {};

/** Sent when the history offset changes.
  * @lzxtype event
  * @access public
  */
var onoffset = LzDeclaredEvent;

/**
  * @access private
  */
function receiveHistory(o){
    if (this.persist && ! this._persistso) {
        this.__initPersist();
    }
    var l = this.__lzhistq.length;
    var offset = o * 1;
    if (! offset) {
        offset = 0;
    } else if (offset > l - 1) {
        offset = l;
    }

    var h = this.__lzhistq[offset];
    for (var u in h) {
        var obj = h[u];
        //Debug.write('restoring state ', global[obj.c], obj.c, obj.n, obj.v);
        global[obj.c].setAttribute(obj.n, obj.v);
    }

    //Debug.write('onhistory ', offset, this.__lzhistq);
    this.setAttribute('offset', offset);
    //LzBrowserKernel.receivedHistory(o);
    return offset * 1;
}

/**
  * @access private
  */
function receiveEvent(n, v){
    //Debug.write('got event', n, v);
    canvas.setAttribute(n, v);
}

/**
  * @access private
  */
function getCanvasAttribute(n){
    return canvas[n];
}    

/**
  * @access private
  */
function setCanvasAttribute(n, v) {
    this.receiveEvent(n,v);
}

/**
  * Invoked by browser JavaScript to call a method
  * @access private
  */
function callMethod(js) { 
    return LzBrowserKernel.callMethod(js);
}

/**
  * Saves a value and attribute name callback in the current offset of the 
  * history stack.  When the browser back button causes the history offset 
  * to change, the attribute will get set to the value saved at that offset,
  * e.g. scope.setAttribute('attribute_name_to_set', value). 
  * @param String who: Global id of the scope to be used
  * @param String prop: Attribute name to be set
  * @param val: Value to set the attribute to
  */
function save(who, prop, val) {
    if (typeof who != 'string') {
        if (who['id']) who = who['id'];
        if ($debug) Debug.warn('Warning: this.save() requires a view ID to be passed in as a string for the first argument.');
        if (! who) return;
    }
    if (val == null) val = global[who][prop];
    this.__lzcurrstate[who] = {c: who, n: prop, v: val};
    this.__lzdirty = true;
    //Debug.write('set state of ',who,' to ', this.__lzcurrstate);
}

/**
  * @access private
  * Commits all registered values to the history stack at the current offset.
  * Must be called to commit registered values.  Called automatically by 
  * next and prev. 
  */
function commit() {
    if (! this.__lzdirty) return;
    this.__lzhistq[this.offset] = this.__lzcurrstate;
    
    //Debug.write('Stored state ', this.__lzcurrstate, out);
    this.__lzhistq.length = this.offset + 1;
    
    if (this.persist) {
        if (! this._persistso) {
            this.__initPersist();
        }
        //Debug.write('_persistso: ', this._persistso);
        this._persistso.data[this.offset] = this.__lzcurrstate;
        //this._persistso.flush();
    }
    
    this.__lzcurrstate = {};
    this.__lzdirty = false;
    //Debug.write('save', this.__lzhistq.length - 1, this.__lzhistq);
}

/**
  * @access private
  */
function move(by) {
    this.commit();
    if (! by) by = 1;
    var o = this.offset + by;
    if (0 >= o) o = 0;
    //Debug.write('Move to: ', o);
    if (this.__lzhistq.length >= o) {
        //Debug.write('move', o, this.__lzhistq.length, this.__lzhistq);
        //this.offset = o;
        LzBrowserKernel.setHistory(o);
    }
}

/**
  * Moves forward one step in the history stack.  Adds an item to the browser history.
  */
function next() {
    this.move(1);
}

/**
  * Moves back one step in the history stack.  Adds an item to the browser history
  */
function prev() {
    this.move(-1);
}

/** @access private */
function __initPersist() {
    if (this.persist) {
        if (! this._persistso) {
            this._persistso = LzBrowserKernel.getPersistedObject('historystate');
        }
        var d = this._persistso.data;
        if (d) {
            this.__lzhistq = [];
            for (var i in d) {
                this.__lzhistq[i] = d[i];
                //Debug.write('restoring', i, d[i]);
            }
        }
    } else {
        if (this._persistso) this._persistso = null;
    }    
}


/**
  * Clears out the history state.
  */
function clear() {
    if (this.persist) {
        if (! this._persistso) {
            this._persistso = LzBrowserKernel.getPersistedObject('historystate');
        }
        this._persistso.clear();
        //this._persistso.flush();
    }
    this.__lzhistq = []
    this.offset = 0;
    if (this.onoffset.ready) this.onoffset.sendEvent(0);
}

/**
  * Turns history persistence across app reloads on or off
  * @param Boolean p: If true, persistence will be turned on
  */
function setPersist(p) {
    if (LzView.prototype.capabilities.persistence) {
        this.persist = p;
        this.__initPersist();
    } else {
        if ($debug) {
            Debug.warn('The %s runtime does not support %s', canvas['runtime'], 'lz.History.setPersist()');
        }
    }
}

/** Called by the canvas sprite after init
  * @access private 
  */
function __start() {
    //Debug.write('setReady', isReady);
    this.isReady = true;
    this.setAttribute('ready', true);
}
}
lz.HistoryService = LzHistoryService;  // publish

/**
  * lz.History is a shortcut for <xref linkend="LzHistoryService" />.
  */
lz.History = new LzHistoryService();
