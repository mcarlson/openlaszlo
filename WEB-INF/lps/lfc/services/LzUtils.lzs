/**
  * LzUtils.lzs
  *
  * @copyright Copyright 2007-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @topic Kernel
  * @subtopic DHTML
  * @author Max Carlson &lt;max@openlaszlo.org&gt;
  */

class ColorUtilsClass {

    function hextoint (value) {
        Debug.info("LzUtils.color.hextoint is deprecated, use lz.Utils.hextoint");
        return lz.Utils.hextoint(value);
    }

    function inttohex (c) {
        Debug.info("LzUtils.color.inttohex is deprecated, use lz.Utils.inttohex");
        return lz.Utils.inttohex(c);
    }

    function torgb (s) {
        Debug.info("LzUtils.color.torgb is deprecated, use lz.Utils.torgb");
        return lz.Utils.torgb(s);
    }
}

class LzUtilsClass {
    // ***** callback *****
    // Provides weak links for global callbacks
     var __scopeid:* = 0;
     var __scopes:* = [];

        /**
        * Returns a callback as a string, suitable for setTimeout
        */
        public  function getcallbackstr(scope:*, name:*) {
            var sc = lz.Utils.__scopeid++;
            if (scope.__callbacks == null) {
                scope.__callbacks = {sc: sc}
            } else {
                scope.__callbacks[sc] = sc;
            }
            lz.Utils.__scopes[sc] = scope;
            return 'if (lz.Utils.__scopes[' + sc + ']) lz.Utils.__scopes[' + sc + '].' + name + '.apply(lz.Utils.__scopes[' + sc + '], [])';
        }

        /**
        * Returns a callback function
        */
        public  function getcallbackfunc(scope, name, args) {
            var sc = lz.Utils.__scopeid++;
            if (scope.__callbacks == null) {
                scope.__callbacks = {sc: sc}
            } else {
                scope.__callbacks[sc] = sc;
            }
            lz.Utils.__scopes[sc] = scope;
            var val = function  () {
                var s = lz.Utils.__scopes[sc];
                if (s) return s[name].apply(s, args);
            };
            return val;
            
        }
        public  function removecallback(scope) {
            if (scope.__callbacks != null) {
                for (var i in scope.__callbacks) {
                    var sc = scope.__callbacks[i]
                    //Debug.write('removing', sc);
                    delete lz.Utils.__scopes[sc];
                }
                delete scope.__callbacks;
            }
        }


    public  function dectohex(c:*, p:*) {
        if (typeof c == 'number') {
            // convert from decimal to hex
            var hex = c.toString(16);
            var pad = (p ? p : 0) - hex.length;
            while (pad > 0) {
                hex = '0' + hex;
                pad--;
            }
            return hex;
        } else {
            return c;
        }
    }

    // For back compatibility
    var color = new ColorUtilsClass();

    // ***** color *****
    public  function hextoint(value:*) {
        if (lz.Utils.colornames[value]) {
            return lz.Utils.colornames[value];
        } else if (typeof value != 'string') {
            return value;
        }
        if (value.charAt(0) == '#') {
            var n = parseInt(value.slice(1), 16);
            switch (!isNaN(n) && value.length-1) {
            case 3:
                return ((n & 0xf00) << 8 | (n & 0xf0) << 4 | (n & 0xf)) * 17;
            case 6:
                return n;
            default:
                if ($debug) {
                    Debug.warn('invalid color: ' + value);
                }
            }
        }
        //TODO pbr Need a workaround for eval
//            if (typeof eval(value) == 'number') {
//                return eval(value);
//            }
        if ($debug) {
            Debug.warn('unknown color format: ' + value);
        }
        return 0;
    }
    public function inttohex(c:*) {
        if (typeof c == 'string') {
            if (lz.Utils.colornames[c]) {
                c = lz.Utils.colornames[c];
            } else {
                c = Number(c);
            }
        }

        if (typeof c == 'number') {
            var hex = lz.Utils.dectohex(c & 0xffffff, 6);
            c = '#' + hex;
        }
        return c;
    }
    public  function torgb(s:*) {
        if (typeof s == 'number') s = lz.Utils.inttohex(s); 
        if (typeof s != 'string') return s; 
        if (s.length < 6) {
            // expand #036 or #0369
            s = '#' + s.charAt(1) + s.charAt(1) + 
                s.charAt(2) + s.charAt(2) + 
                s.charAt(3) + s.charAt(3) + 
                (s.length > 4 ? s.charAt(4) + s.charAt(4) : '');
        } 
        // #003366 or #00336699
        return 'rgb(' + parseInt(s.substring(1, 3), 16) + ',' +
            parseInt(s.substring(3, 5), 16) + ',' +
            parseInt(s.substring(5, 7), 16) + 
            (s.length > 7 ? ',' + parseInt(s.substring(7, 9), 16) : '') +
        ')';
    }

    /**
      * CSS color names from
      * http://www.w3.org/TR/2001/WD-css3-color-20010305.  These match the
      * names in the compiler.
      * @access public
      */
    var colornames = {
        black: 0x000000
        ,green: 0x008000
        ,silver: 0xC0C0C0
        ,lime: 0x00FF00
        ,gray: 0x808080
        ,olive: 0x808000
        ,white: 0xFFFFFF
        ,yellow: 0xFFFF00
        ,maroon: 0x800000
        ,navy: 0x000080
        ,red: 0xFF0000
        ,blue: 0x0000FF
        ,purple: 0x800080
        ,teal: 0x008080
        ,fuchsia: 0xFF00FF
        ,aqua: 0x00FFFF
    }
}

/**
 * @shortdesc Alias for <link linkend="LzUtilsClass">LzUtilsClass</link>
 */
lz.Utils = new LzUtilsClass();

/**
 * @deprecated
 * @shortdesc Alias for <link linkend="LzUtilsClass">LzUtilsClass</link>
 * Use lz.Utils instead.
 */
var LzUtils:LzUtilsClass = lz.Utils;
