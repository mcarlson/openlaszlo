/**
 *
 * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
 *            Use is subject to license terms.
 *
 * @affects lzidle
 * @access public
 * @topic LFC
 * @subtopic Services
 */

/**
 * <p><code>lz.Idle</code> is the single instance of the class
 * <code>LzIdleService</code>.</p>
 *
 * <p>The OpenLaszlo runtime generates idle events at a fixed,
 * unspecified frequency.  Here is a simple example that shows how to
 * receive the <event>onidle</event> event:</p>
 *
 * <example><programlisting><![CDATA[
 * <canvas height="80">
 *   <text name="display" />
 *   <attribute name="counter" value="0" />
 *   <handler name="onidle" reference="LzIdleService.LzIdle">
 *     display.format("Received %d idle events", ++counter);
 *   </handler>
 * </canvas>
 * ]]></programlisting></example>
 *
 * @shortdesc Idle service.
 *
 * @devnote This object sends an 'onidle' event when there is no synchronous script
 * running after each frame update.
 */
class LzIdleService extends LzEventable {
  /** @access private */
  var coi;
  /** @access private */
  var regNext:Boolean = false;
  /** @access private */
  var removeCOI = null;

  /**
   * The idle service.  Also available as the global
   * <code>lz.Idle</code>.
   *
   * @type LzIdleService
   * @keywords readonly
   * @devnote this should be a public getter to enforce readonly
   */
  static var LzIdle:LzIdleService;

  /** @access private
   * @devnote AS3 does not allow private constructors, so we need the
   * error
   */
  function LzIdleService () {
    //    if (LzIdleService.LzIdle) {
    //      throw new Error("There can be only one LzIdle");
    //    }
    // Create array on instance, not prototype
    this.coi = new Array;
    this.removeCOI = new LzDelegate( this , "removeCallIdleDelegates" );
    LzIdleKernel.addCallback( this, '__idleupdate' );
  }
  /* Avoid idle noise in the profiler */
  {
#pragma "profile=false"
    // Create the singleton
    LzIdleService.LzIdle = new LzIdleService();
  }

  /**
   * Calls the given delegate at the next idle event. This can be used
   * for a non-repeating callback.
   *
   * @param LzDelegate d: The delegate to be called on the next idle
   * event.
   */
  function callOnIdle ( d ){
    this.coi.push(d);
    if (!this.regNext) {
      this.regNext = true;
      this.removeCOI.register( this , "onidle" );
    }
  }

  /**
   * @access private
   */
  function removeCallIdleDelegates ( t ){
    var arr = this.coi;
    this.coi = new Array;
    //call in order
    for (var i = 0; i < arr.length; i++ ){
      arr[i].execute( t );
    }

    if (this.coi.length == 0) {
      // Note that the executed items may have added to the (new)
      // coi queue, only unregister if the queue is empty
      this.removeCOI.unregisterFrom(this.onidle);
      this.regNext = false;
    }
  }

  /** This is the idle event for the system, sent by this service
   * @lzxtype event
   */
  var onidle = LzDeclaredEvent;

  /**
   * __idleupdate is a callback function from LzIdleKernel.
   * @access private
   */
  function __idleupdate (t) {
    if (this.onidle.ready) {
      this.onidle.sendEvent(t);
    }
  }
}
lz.IdleService = LzIdleService;  // publish

/**
 * @shortdesc Alias for <link linkend="LzIdleService">LzIdleService.LzIdle</link>
 */
lz.Idle = LzIdleService.LzIdle;
