/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @affects lzbrowser
  * @access public
  * @topic LFC
  * @subtopic Services
  */


/**
 * Interface to the kernel browser
 */

class LzBrowserInterface {

/**
  * Loads a URL in the browser, optionally in a target
  * 
  * @param String url: URL to load
  * @param String target: Optionally specifies a named frame to display the contents of the URL.
  * The document specified by URL is loaded into the current browser frame by default.
  */
function loadURL ( url, target=null, features=null ) {}

/**
  * Runs Javascript in the browser using a javascript: url, optionally in a
  * target
  * 
  * @param String js: Javascrit string to execute
  * @param String target: Optionally specifies a named frame to display the contents of the URL.
  * By default, the javascript specified in 'js' is executed in the current
  * browser frame .
  */
function loadJS ( js, target=null ) {}

/**
  * Runs a Javascript method in the browser, optionally returning the result  
  * 
  * @param String js: Browser javascript method name to execute
  * @param Function callback: Optionall callback function to get the return value of the javascript call
  * @param Optional arguments to call
  */
function callJS ( js, callback=null, args=null ) {}

/**
  * Returns version information about the browser
  */
function getVersion () {}

/**
  * Returns the URL from which the application was loaded.
  * @return String : the URL the swf was loaded from
  * 
  */
function getLoadURL () {}

/**
  * This function returns the value of a key in the request string that 
  * requested the the lzx app. This can be used to communicate server to an lzx
  * app without forcing the app to make a request
  * 
  * @return String: The value for a key that appears in the request to the lps
  * server
  */
function getInitArg (name) {}

/**
  * Turns the flash context menu on or off
  * @keywords flashspecific private
  * @param Boolean truefalse: boolean value - true for on, false for off.
  */
function showMenu (truefalse) {}


/**
  * Sets the system clipboard to the specified string
  * @keywords flashspecific
  * 
  * @param String str: String to set the system clipboard to
  */
function setClipboard (str) {}

/**
  * Determines if the a screen reader is active and the Flash player is focused
  * @keywords flashspecific
  * 
  * @return: True if a screen reader is active and the Flash player is focused
  */
function isAAActive () {}

/**
  * Updates accessibility data
  * @keywords flashspecific
  * @access private
  */
function updateAccessibility () {}


} // End of LzBrowserInterface



class LzBrowserService extends LzBrowserInterface {
  /** The browser service.  Also available as the global
   * <code>LzBrowser</code>.
   *
   * @type LzBrowserService
   * @keywords readonly
   * @devnote this should be a public getter to enforce readonly
   */
  static var LzBrowser:LzBrowserService;

  /** @access private 
   * @devnote AS3 does not allow private constructors, so we need the
   * error
   */
  function LzBrowserService() {
//    if (LzBrowserService.LzBrowser) {
//      throw new Error("There can be only one LzBrowser");
//    }
  }

  LzBrowserService.LzBrowser = new LzBrowserService;

override function loadURL ( url, target=null, features=null )
{ LzBrowserKernel.loadURL (url, target, features);}

override function loadJS ( js, target=null )
{ LzBrowserKernel.loadJS.apply (null, arguments);}

// apply() is used to make sure all optional arguments are passed
override function callJS ( js, callback=null, args=null )
{ LzBrowserKernel.callJS.apply (null, arguments);}

override function getVersion ()
{ return LzBrowserKernel.getVersion ();}

override function getLoadURL ()
{ return LzBrowserKernel.getLoadURL ();}

override function getInitArg (name)
{ return LzBrowserKernel.getInitArg (name);}

override function showMenu (truefalse)
{ LzBrowserKernel.showMenu (truefalse);}

override function setClipboard (str)
{ LzBrowserKernel.setClipboard (str);}

override function isAAActive ()
{ return LzBrowserKernel.isAAActive ();}

override function updateAccessibility ()
{ LzBrowserKernel.updateAccessibility ();}




/** @access private */
var postToLps = true;

/** @access private */
var parsedloadurl = false;



/** @access private */
var defaultPortNums = { http: 80, https: 443 };

/**
  * Returns the base URL the lzx was loaded from
  * @keywords private
  */
function getBaseURL (secure=null, port=null) {
    var url = this.getLoadURLAsLzURL(); 

    if (secure) {
        url.protocol = "https";
    }

    if (port) {
        url.port = port;
    } 

    if (secure && port == null) {
        url.port = this.defaultPortNums[url.protocol]; 
    }
    //Debug.write('port', port);
    //Debug.write('secure', secure);
    //Debug.write('url.port', url.port);

    url.query = null;

    //Debug.write('base url' + url.toString());
    return url;
}

/**
  * Returns the loadUrl as a new LzURL
  * */
function getLoadURLAsLzURL (){
    if ( !this.parsedloadurl ){
        this.parsedloadurl = new LzURL( this.getLoadURL() );
    }
    return this.parsedloadurl.dupe();
}

/**
  * Converts relative URLs to absolute by prepending the load URL
  * @keywords private
  * @param String url: URL to convert
  * @param Boolean secure: true if relative http is really https
  * @return: an absolute URL
  */
function toAbsoluteURL (url, secure) {
    // If it begins with "/@WEBAPP@/", server will handle URL.
    // or If it begins with "file:", server will handle URL.
    // or do we have an absolute url?
    if ( url.indexOf("://") > -1  ||
         url.indexOf("/@WEBAPP@/") == 0 ||
         url.indexOf("file:") == 0 ){

        return url;
    }


    //do we have a protocol?
    var returl = "";
    var u = this.getLoadURLAsLzURL();
    //Debug.write('load url', u.toString());
    //for LzURL: protocol,host, port, path, file, query

    /* Description: LzBrowser.toAbsoluteURL('http:/zot/foo.bar') =>
       http://127.0.0.1:8080/lps-dev-bug/examples//zot/foo.bar
       I would have hoped for:
       http://127.0.0.1:8080/zot/foo.bar
    */

    //no colons unless you specify protocol
    if ( url.indexOf(":") > -1 ){
        /* http:foo.lzx
           http:/foo.lzx
        */
        var colon = url.indexOf(":");
        var loadUrlIsSecure = (u.protocol == 'https');
        u.protocol = url.substring( 0 , colon );
        if (secure || loadUrlIsSecure) {
            if (u.protocol == 'http') {
                u.protocol = 'https'
            }
        } 
        var path = url.substring(colon+1, url.length);
        // is URL of the form http:/zot/foo.bar?
        if (path.charAt(0) == '/') {
            u.path = url.substring( colon + 1 );
            u.file = null;
        } else {
            u.file = url.substring( colon + 1 );
        }
        u.query = null
    } else {
        if ( url.charAt( 0 ) == '/' ){
            //this is the root of the host
            u.path = url;
            //although this is really both the path and the file,
            //it's expedient to handle it this way, since this
            //method just returns a string
            u.file = null;
        } else {
            //no protocol -- totally relative
            u.file = url;
        }
        u.query = null
    }
    //Debug.write( "changed: " + url );
    //Debug.write( " to: " + u.toString() );
    return u.toString();

    /*
    if ( url.indexOf("http") != 0 ) {
        var u = new LzURL( this.getLoadURL() );
        if ( url.indexOf("/") == 0 ) u.path = null;
        u.file = null;
        u.query = null;
        url = u.toString() + url;
        Debug.write("Converting toAbsoluteURL: " + url + " to " + u.toString() + url) 
    }
    return url;
    */
}

/**
  * Escape special characters in message: &amp; and &lt;.
  * @param String str: The string to escape
  */
function xmlEscape (str) {
    return LzDataNode.__LZXMLescape( str );
}

/**
  * Escape a string using URL encoding.
  * @param String str: The string to escape
  * @return: An URL escaped string
  */
function urlEscape (str) {
    return escape( str );
}
/**
  * Escape a string using URL encoding.
  * @param String str: The string to unescape
  * @return: An URL decoded string
  */
function urlUnescape (str) {
    return unescape( str.split('+').join(' ') );
}


/** @access private */
function usePost (){
    return this.postToLps && this.supportsPost();
}

/** @access private */
function supportsPost (){
    return true;
}


} // End of LzBrowserService


var LzBrowser = LzBrowserService.LzBrowser;



if ($as2){
// proxy object for browser Lz
Lz = {
    setCanvasAttribute: function (name, value, hist) {
        LzBrowser.callJS('Lz.setCanvasAttribute', false, name, value, hist); 
    }
}
}



