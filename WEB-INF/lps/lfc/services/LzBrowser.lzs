/**
 * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
 *            Use is subject to license terms.
 *
 * @affects lzbrowser
 * @topic LFC
 * @subtopic Services
 * @access public
 * Interface to the browser via the runtime kernel
 */
class LzBrowserService {
  /** The browser service.  Also available as the global
   * <code>LzBrowser</code>.
   *
   * @type LzBrowserService
   * @keywords readonly
   * @devnote this should be a public getter to enforce readonly
   */
  static var LzBrowser:LzBrowserService;

  /** @access private
   * @devnote AS3 does not allow private constructors, so we need the
   * error
   */
  function LzBrowserService() {
    //    if (LzBrowserService.LzBrowser) {
    //      throw new Error("There can be only one LzBrowser");
    //    }
  }

  // Create the singleton
  LzBrowserService.LzBrowser = new LzBrowserService();

  /**
   * Loads a URL in the browser, optionally in a target
   *
   * @param String url: URL to load
   * @param String target: Optionally specifies a named frame to display the contents of the URL.
   * The document specified by URL is loaded into the current browser frame by default.
   */
  function loadURL ( url, target=null, features=null )
    { LzBrowserKernel.loadURL (url, target, features);}

  /**
   * Runs Javascript in the browser using a javascript: url, optionally in a
   * target window.  Note that Flash limits the javascript string to a maximum of 508 characters.  See callJS() for a higher-performance alternative.
   *
   * @param String js: Javascript string to execute
   * @param String target: Optionally specifies a named frame to display the contents of the URL.
   * By default, the javascript specified in 'js' is executed in the current
   * browser frame .
   */
  function loadJS ( js, target=null )
    { LzBrowserKernel.loadJS.apply (null, arguments);}

  /**
   * Runs a Javascript method in the browser, optionally returning the result.  Note that this feature requires the application to be embedded by the embed-compressed.js library. 
   *
   * @param String methodname: Browser javascript method name to execute
   * @param Function callback: Optional callback function to receive the return value of the javascript call
   * @param * arguments to call the method with
   */
  function callJS ( methodname, callback=null, args=null )
    { LzBrowserKernel.callJS.apply (null, arguments);}

  /**
   * Returns version information about the browser
   */
  function getVersion ()
    { return LzBrowserKernel.getVersion ();}

  /**
   * Returns the URL from which the application was loaded.
   * @return String: the URL the swf was loaded from
   *
   */
  function getLoadURL ()
    { return LzBrowserKernel.getLoadURL ();}

  /**
   * This function returns the value of a key in the request string that
   * requested the the lzx app. This can be used to communicate server to an lzx
   * app without forcing the app to make a request
   *
   * @param String name: The name of the key whose value to return
   *
   * @return String: The value for a key that appears in the request to the lps
   * server
   */
  function getInitArg (name)
    { return LzBrowserKernel.getInitArg (name);}

  /**
   * Turns the flash context menu on or off
   * @keywords flashspecific private
   * @param Boolean truefalse: boolean value - true for on, false for off.
   */
  function showMenu (truefalse)
    { LzBrowserKernel.showMenu (truefalse);}

  /**
   * Sets the system clipboard to the specified string
   * @keywords flashspecific
   *
   * @param String str: String to set the system clipboard to
   */
  function setClipboard (str)
    { LzBrowserKernel.setClipboard (str);}

  /**
   * Determines if the a screen reader is active and the Flash player is focused
   * @keywords flashspecific
   *
   * @return: True if a screen reader is active and the Flash player is focused
   */
  function isAAActive ()
    { return LzBrowserKernel.isAAActive ();}

  /**
   * Updates accessibility data
   * @keywords flashspecific
   * @access private
   */
  function updateAccessibility ()
    { LzBrowserKernel.updateAccessibility ();}

  /** @access private */
  var postToLps = true;
  /** @access private */
  var parsedloadurl = false;
  /** @access private */
  var defaultPortNums = { http: 80, https: 443 };

  /**
   * Returns the base URL the lzx was loaded from
   * @keywords private
   */
  function getBaseURL (secure=null, port=null) {
    var url = this.getLoadURLAsLzURL();

    if (secure) {
      url.protocol = "https";
    }

    if (port) {
      url.port = port;
    }

    if (secure && port == null) {
      url.port = this.defaultPortNums[url.protocol];
    }
    //Debug.write('port', port);
    //Debug.write('secure', secure);
    //Debug.write('url.port', url.port);

    url.query = null;

    //Debug.write('base url' + url.toString());
    return url;
  }

  /**
   * Returns the loadUrl as a new LzURL
   *
   * @return LzURL: the URL the application was loaded from, as an LzURL
   */
  function getLoadURLAsLzURL (){
    if ( !this.parsedloadurl ){
      this.parsedloadurl = new LzURL( this.getLoadURL() );
    }
    return this.parsedloadurl.dupe();
  }

  /**
   * Converts relative URLs to absolute by prepending the load URL
   * @keywords private
   * @param String url: URL to convert
   * @param Boolean secure: true if relative http is really https
   * @return String: an absolute URL
   */
  function toAbsoluteURL (url, secure) {
    // If it begins with "/@WEBAPP@/", server will handle URL.
    // or If it begins with "file:", server will handle URL.
    // or do we have an absolute url?
    if ( url.indexOf("://") > -1  ||
         url.indexOf("/@WEBAPP@/") == 0 ||
         url.indexOf("file:") == 0 ){

      return url;
    }


    //do we have a protocol?
    var returl = "";
    var u = this.getLoadURLAsLzURL();
    //Debug.write('load url', u.toString());
    //for LzURL: protocol,host, port, path, file, query

    /* Description: LzBrowser.toAbsoluteURL('http:/zot/foo.bar') =>
       http://127.0.0.1:8080/lps-dev-bug/examples//zot/foo.bar
       I would have hoped for:
       http://127.0.0.1:8080/zot/foo.bar
    */

    //no colons unless you specify protocol
    if ( url.indexOf(":") > -1 ){
      /* http:foo.lzx
         http:/foo.lzx
      */
      var colon = url.indexOf(":");
      var loadUrlIsSecure = (u.protocol == 'https');
      u.protocol = url.substring( 0 , colon );
      if (secure || loadUrlIsSecure) {
        if (u.protocol == 'http') {
          u.protocol = 'https'
            }
      }
      var path = url.substring(colon+1, url.length);
      // is URL of the form http:/zot/foo.bar?
      if (path.charAt(0) == '/') {
        u.path = url.substring( colon + 1 );
        u.file = null;
      } else {
        u.file = url.substring( colon + 1 );
      }
      u.query = null
        } else {
      if ( url.charAt( 0 ) == '/' ){
        //this is the root of the host
        u.path = url;
        //although this is really both the path and the file,
        //it's expedient to handle it this way, since this
        //method just returns a string
        u.file = null;
      } else {
        //no protocol -- totally relative
        u.file = url;
      }
      u.query = null
        }
    //Debug.write( "changed: " + url );
    //Debug.write( " to: " + u.toString() );
    return u.toString();

    /*
      if ( url.indexOf("http") != 0 ) {
      var u = new LzURL( this.getLoadURL() );
      if ( url.indexOf("/") == 0 ) u.path = null;
      u.file = null;
      u.query = null;
      url = u.toString() + url;
      Debug.write("Converting toAbsoluteURL: " + url + " to " + u.toString() + url)
      }
      return url;
    */
  }

  /**
   * Escape special characters in message: &amp; and &lt;.
   * @param String str: The string to escape
   */
  function xmlEscape (str) {
    return LzDataElement.__LZXMLescape( str );
  }

  /**
   * Escape a string using URL encoding.
   * @param String str: The string to escape
   * @return String: An URL escaped string
   */
  function urlEscape (str) {
    return escape( str );
  }

  /**
   * Escape a string using URL encoding.
   * @param String str: The string to unescape
   * @return String: An URL decoded string
   */
  function urlUnescape (str) {
    return unescape( str.split('+').join(' ') );
  }

  /** @access private */
  function usePost (){
    return this.postToLps && this.supportsPost();
  }

  /** @access private */
  function supportsPost (){
    return true;
  }

    /**   @access public
     *   @param Object params a hash table of key-value pairs
     * The params arg has keys that have the following meaning:
     * <ul>
     * <li>url: url, including query args</li>
     * <li>httpmethod: 'post' or 'get'</li>
     * <li>service: 'xmldata' or 'media'</li>
     * <li>headers: hash table of HTTP request headers</li>
     * <li>postbody: optional, post body data string</li>
     * <li>proxyurl: the url of the proxy server host. Should be just a path, must not contain a query string.</li>
     * <li>nsprefix: boolean, if true preserve namespace prefixes in data response</li>
     * <li>timeout: milliseconds for timeout</li>
     * <li> cacheable: boolean, cache on server</li>
     * <li> ccache: boolean, cache at client</li>
     * <li> sendheaders: boolean, server sends back HTTP headers with data response</li>
     * <li> secure: boolean, will be used when converting relative to absolute url, to make it https</li>
     * <li> trimwhitespace: boolean</li>
     *</ul>
     */
    public function makeProxiedURL (params:Object):String {
        var headers:Object = params.headers;
        var postbody:String = params.postbody;
        var proxyurl:String = params.proxyurl;
        var secure:Boolean = params.secure;
        var qargs = {
            lzt: params.service,
            reqtype: params.httpmethod.toUpperCase(),
            sendheaders: params.sendheaders,
            trimwhitespace: params.trimwhitespace,
            nsprefix: params.trimwhitespace,
            url: this.toAbsoluteURL(params.url, params.secure),
            timeout: params.timeout,
            cache: params.cacheable,
            ccache: params.ccache
        };

        //If a postbody string is supplied, pass it to the proxy server as 'lzpostbody' arg.
        if (postbody != null) {
            qargs.lzpostbody = postbody;
        }
            
        // Set HTTP headers
        var hname;
        var headerString = "";
        if (headers != null) {
            for (hname in headers) {
                headerString += (hname + ": " + headers[hname]+"\n");
            }
        }

        if (headerString != "") {
            qargs['headers'] = headerString;
        }

        // break the browser cache by creating an arg with a unique value
        if (!params.ccache) {
            qargs.__lzbc__ = (new Date()).getTime();
        }

        // append query args onto url
        var sep = "?";
        for (var key in qargs) {
            var val = qargs[key];
            if (typeof(val) == "string") {
                val = encodeURIComponent(val);
                if ($dhtml) {
                    // workaround bug with DHTML runtime's URL encoding
                    val = val.replace(LzDataset.slashPat, "%2F");
                }
            }
            proxyurl += sep + key + "=" + val;
            sep = "&";
        }

        return proxyurl;
    }



} // End of LzBrowserService


/**
 * <p>The <code>lz.Browser</code> service provides methods for
 * communicating with the browser that embeds the application.</p>
 *
 * @access public
 * @type LzBrowserService
 * @shortdesc  LzBrowser is a shortcut for <link linkend="LzBrowserService">LzBrowserService.LzBrowser</link>
 */
lz.Browser = LzBrowserService.LzBrowser;

/**
 * @keywords deprecated
 * @access public
 * @type LzBrowserService
 * @shortdesc  LzBrowser is a shortcut for <link linkend="LzBrowserService">LzBrowserService.LzBrowser</link>
 */
var LzBrowser:LzBrowserService = lz.Browser

if ($as2){
  // proxy object for browser Lz
  lz.embed = {
    setCanvasAttribute: function (name, value, hist) {
      lz.Browser.callJS('lz.embed.setCanvasAttribute', false, name, value, hist);
    }
    ,callMethod: function (js) {
      lz.Browser.callJS('lz.embed.callMethod', false, js);
    }
  }
}
