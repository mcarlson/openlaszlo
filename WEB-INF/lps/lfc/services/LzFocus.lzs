/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @affects lzbrowser
  * @access public
  * @topic LFC
  * @subtopic Services
  */

/**
  * <p>This service manages the keyboard focus.  At any time, at most one view
  * has the keyboard focus.  This is the view that receives key events
  * when a key is pressed.</p>
  * <p>
  * See <a href="${dguide}input-devices.html">The Software Developer's Guide</a> for a discussion of keyboard focus.
  * </p>
  * <p>Note that the view.getNextSelection() and view.getPrevSelection() methods can be overridden to change the tab order</p>
  * 
  * @shortdesc Handles keyboard focus.
  */
dynamic class LzFocusService extends LzEventable {

    /** Sent when the focus changes, with the argument being the view
     * that was just focused. If nothing is focused, this event is sent with null.
     * @access public
     * @lzxtype event 
     */
    var onfocus = LzDeclaredEvent;

    /** A reference to the last view that held the focus
     * @type LzView
     * @keywords readonly
     */
    var lastfocus = null;
    /** @access private */
    var csel = null;
    /** @access private */
    var cseldest = null;

    /** @access private */
    function LzFocusService () {
    }

    /** @access private */
    function initialize () {
        this.upDel = new LzDelegate( LzFocus , "gotKeyUp", LzKeys, "onkeyup");
        this.downDel = new LzDelegate( LzFocus , "gotKeyDown", LzKeys, "onkeydown");
    }


    /** @access private */
    var upDel;
    /** @access private */
    var downDel;

    /** This attribute is set to true when the focus has moved
     * because the user has hit the next or prev focus key (usually 'tab' and
     * 'shift-tab'.) If the focus moves due to mouse-click the value is set to
     * false. If the focus moves through programmatic control, the value is
     * unchanged from its last value.
     * @type Boolean
     * @keywords readonly
     */
    var focuswithkey = false;

    /** @access private */
    var __LZskipblur = false;
    /** @access private */
    var __LZsfnextfocus = -1;
    /** @access private */
    var __LZsfrunning = false;

    /**
     * @access private
     */
    function gotKeyUp( kC ){
        //Debug.write("gotKeyUp "+kC);
        if (this.csel && this.csel.onkeyup.ready) this.csel.onkeyup.sendEvent( kC );
    }

    /**
     * @access private
     */
    function gotKeyDown( kC ){
        //Debug.write("gotKeyDown ", kC, LzKeys.isKeyDown('shift'));
        if (this.csel && this.csel.onkeydown.ready)
            this.csel.onkeydown.sendEvent( kC );
        if ( kC == LzKeys.keyCodes.tab ){
            if ( LzKeys.isKeyDown( 'shift' ) ){
                this.prev();
            } else {
                this.next();
            }
        }
    }

    /**
     * @access private
     */
    function setNextKey( k ){
        if ( $debug ){
            Debug.error( 'Next key can no longer be set.');
        }
    }

    /**
     * @access private
     */
    function setPrevKey( k ){
        if ( $debug ){
            Debug.error( 'Prev key can no longer be set.');
        }
    }

    /**
     * @access private
     */
    function __LZcheckFocusChange ( v ){
        //    if ( 'focusable' in v && v.focusable ){
        if ( v && v.focusable ){
            this.setFocus( v , false );
        }
    }

    /**
     * Set the focus to the given view.  If this is not the currently
     * focused view, an onblur event is sent to the currently focused view,
     * and an onfocus event is sent to the new view. When setFocus is called as the
     * result of an onblur or onfocus event, all the delegates registered for the
     * event run before the next setFocus call is made. While it is not an error
     * for multiple responders to call setFocus as the result of the same onfocus
     * or onblur event, only one of the calls will be executed.
     *
     * The state of the view may be unknown during the blur/focus process. When
     * a view loses focus, it's blurring variable is set to true during the
     * process.
     * 
     * @param LzView newsel: The view to focus or null to clear focus
     */
    function setFocus  ( newsel, fwkey = null ){
        //undocumented attribute focuswithkey. If the second argument to this
        //method is defined, it sets the value of this.focuswithkey to the given
        //value.

        if ( this.__LZsfrunning ){
            this.__LZsfnextfocus = newsel;
            return;
        }

        if ( this.cseldest == newsel ) {
            return;
        }

        if ( this.csel && this.csel.shouldYieldFocus && !this.csel.shouldYieldFocus() ) {
            return;
        }

        var prevsel = this.csel;
        if (prevsel) {
            // Give the view warning that it will be losing focus
            prevsel.blurring = true;
        }

        this.__LZsfnextfocus = -1;
        this.__LZsfrunning = true;

        if ( newsel && !newsel.focusable) {
            newsel = this.getNext(newsel);
        }
        this.cseldest = newsel;

        if ( fwkey != null ){
            this.focuswithkey  = fwkey;
        }

        if ( !this.__LZskipblur ){
            this.__LZskipblur = true;
            if (this.csel && this.csel.onblur.ready)
                this.csel.onblur.sendEvent( newsel );
            if ( this.__LZsfnextfocus != -1 ) {
                //we've been called again
                this.__LZsfrunning = false;
                this.setFocus( this.__LZsfnextfocus );
                return;
            }
        }

        //now focus changes
        this.lastfocus = this.csel;
        this.csel = newsel;
        this.__LZskipblur = false;
    

        if (newsel && newsel.onfocus.ready) {
            newsel.onfocus.sendEvent( newsel );
        }
        if ( this.__LZsfnextfocus != -1 ) {
            //we've been called again
            this.__LZsfrunning = false;
            this.setFocus( this.__LZsfnextfocus );
            return;
        }

        if (this.onfocus.ready) this.onfocus.sendEvent( newsel );
        this.__LZsfrunning = false;
        if ( this.__LZsfnextfocus != -1 ) {
            //we've been called again
            this.setFocus( this.__LZsfnextfocus );
            return;
        }

        if (prevsel) {
            // The focus is changed.
            prevsel.blurring = false;
        }
    }

    /**
     * Remove the focus from the currently focused view (if there is one).
     * An 'onblur' event is first sent to the view.
     */
    function clearFocus ( ){
        this.setFocus( null );
    }

    /**
     * Get the currently focused view.
     * @return LzView: The view that has the focus, or null if none does.
     */
    function getFocus (){
        return this.csel;
    }

    /**
     * Move the focus to the next focusable view.
     */
    function next (){
        this.genMoveSelection( 1 );
    }

    /**
     * Returns the next focusable view.
     * @param LzView focusview: optional starting view. By default focusview 
     * is the current focus.
     * @return LzView: The view that would be the next focus.
     */
    function getNext ( focusview ){
        if ( !focusview ) focusview = this.csel;
        return this.moveSelSubview( focusview , 1 ) ;
    }

    /**
     * Returns the previous focusable view.
     * @param LzView focusview: optional starting view. By default focusview 
     * is the current focus.
     * @return LzView: The view that would be the focus if you shift tabbed 
     */
    function getPrev ( focusview ){
        if ( !focusview ) focusview = this.csel;
        return this.moveSelSubview( focusview , -1 ) ;
    }


    /**
     * Move the focus to the previous focusable view.
     */
    function prev (){
        this.genMoveSelection( -1 );
    }

    /**
     * @access private
     */
    function genMoveSelection ( movedir  ){
        var sel = this.csel;
        var check = sel;

        while ( sel && check != canvas ){
            if (!check.visible ) {
                sel = null;
            }
            check = check.immediateparent;
        }

        if ( sel == null ){
            sel = LzModeManager.getModalView();
        }

        var v = null;
        if (sel && sel[ "get"+(movedir == 1 ? "Next" : "Prev")+"Selection" ]) v = sel[ "get"+(movedir == 1 ? "Next" : "Prev")+"Selection" ]();
        if ( v == null ){
            v = this.moveSelSubview( sel , movedir ) ;
        }

        if ( !LzModeManager.__LZallowFocus( v ) ){
            return;
        }

        this.setFocus( v , true );
    }


    /**
     * Append those of v and its descendants that are focusable, to accum.
     * Always include 'include', and include focus traps but don't descend
     * into them unless this is the outermost call (and top=true).
     * 
     * @access private
     */
    function accumulateSubviews(accum, v, includep, top=false) {
        // Always include the current view, even if it's not focusable,
        // since its index is used to find a focusable neighbor.
        if (v == includep || (v.focusable && v.visible))
            accum.push(v);
        // Don't descend into focus traps, except always consider children
        // of the outermost call.
        if (top || (!v.focustrap && v.visible))
            for (var i = 0; i < v.subviews.length; i++)
                this.accumulateSubviews(accum, v.subviews[i], includep, false);
    }


    /**
     * Return an item in the same focus group as v, either preceding it (mvdir==-1)
     * or following it (mvdir==1) in preorder.
     * 
     * @access private
     */
    function moveSelSubview ( v , mvdir ){
        // Find the closest parent that doesn't cross a focus trap boundary.
        var root = v || canvas;
        // If v is a focus trap, make sure that we at least step up to its
        // parent, in order to tab to its siblings.
        // I don't think this is right, but I'm not 100% sure, so leaving comment
        // when do you have focustrap="true" and focusable="true" ?  -sa
        //  if (root.focustrap && root.immediateparent)
        //     root = root.immediateparent;

        // canvas.immediateparent == canvas.  No other cycles should be
        // present (although this will catch others of length one).
        while (!root.focustrap && root.immediateparent
               && root != root.immediateparent)
            root = root.immediateparent;
        // collect selectable children into focusgroup
        var focusgroup = [];
        this.accumulateSubviews(focusgroup, root, v, true);

        // set index to the index of v within the current focus group.
        var index = -1;
        for (var i in focusgroup)
            if (focusgroup[i] == v) {
                // for..in returns strings
                index = Number(i);
                break;
            }
        // If the current focus group doesn't include v, mvdir==1 should select
        // the first item and mvdir==-1 should select the last item.  index==-1
        // and mvdir==1 will already work for the first case.  Fix the second:
        if (index == -1 && mvdir == -1)
            index = 0;
        index = (index + mvdir + focusgroup.length) % focusgroup.length;
        return focusgroup[index];
    }
}
/**
  * LzFocus is a shortcut for <link linkend="LzFocusService">LzFocusService.LzFocus</link>
  * This service manages the keyboard focus. At any time, at most one view has the keyboard focus. This is the view that receives key events when a key is pressed. 
  *
  * @shortdesc Handles keyboard focus.
  */
var LzFocus = new LzFocusService();
LzFocus.initialize();
