/**
 * @copyright Copyright 2001-2010 Laszlo Systems, Inc.  All Rights Reserved.
 *            Use is subject to license terms.
 *
 * @access public
 * @topic LZX
 */

/**
 * A presentation type is a specification of how to map a Javascript type to
 * and from a String representation.
 *
 * If an inherited class does not implement present(),
 * PresentationType/present() will be used.
 *
 * @access private
 */
class PresentationTypeClass {
  static const nullValue = null;
  var _dbg_typename = 'type';
  var _dbg_name = function () {
    return this.constructor.lzxtype;
  }
  function accept(value) {
    if ($debug) {
      Debug.error("%w.accept must be defined", this);
    }
  }
  function present(value) {
    return String(value);
  }
};

/**
 * String presentation type
 *
 * @access private
 */
class StringPresentationTypeClass extends PresentationTypeClass {
  static const lzxtype = 'string';
  static const nullValue = "";
  override function accept(value) {
    return String(value);
  }
}
/** @access private */
var StringPresentationType = new StringPresentationTypeClass();

/**
 * text presentation type
 *
 * `accept` will escape the 5 XML entities, `present` will unescape them
 *
 * @devnote NOTE [2010-07-20 ptw] To ensure markup is not interpreted,
 * you really only have to escape the two syntactical markers &lt; and
 * &amp;.
 *
 * @access private
 */
class TextPresentationTypeClass extends PresentationTypeClass {
  static const lzxtype = 'text';
  static const nullValue = "";
  /** The five XML entities
   * (See http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML)
   * @access private */
  static const xmlEscapes:Object = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&apos;'};

  override function accept(value) {
    const escChars:Object = TextPresentationTypeClass.xmlEscapes;
    var result:String = "";
    for (var i:int = 0, l:int = value.length; i < l; i++) {
      var c:String = value.charAt(i);
      result += (escChars[c] || c);
    }
    return result;
  }

  override function present(value) {
    var result:String = "";
    for (var i:int = 0, l:int = value.length; i < l; i++) {
      var c:String = value.charAt(i);
      if (c == '&') {
        var e:int = value.indexOf(';', i);
        if (e > i) {
          var p:String = value.substring(i, e);
          switch (p) {
            case 'amp': break;
            case 'lt': c = '<'; break;
            case 'gt': c = '>'; break;
            case 'quot': c = '"'; break;
            case 'apos': c = "'"; break;
            default: c = '&' + p + ';';
          }
          // Tip o' th pin to andre:  loop step will increment to e+1
          i = e;
        }
      }
      result += c;
    }
    return result;
  }
}
/** @access private */
var TextPresentationType = new TextPresentationTypeClass();

/**
 * Boolean presentation type
 *
 * @access private
 */
class BooleanPresentationTypeClass extends PresentationTypeClass {
  static const nullValue = false;
  static const lzxtype = 'boolean';
  override function accept(value) {
    // NOTE: [2009-01-13 ptw] Boolean("false") would not do what we
    // expect (a non-empty string is considered true).
    switch (value.toLowerCase()) {
      case "": case "0": case "false":
        return false;
      default:
        return true;
    }
  }
}
/** @access private */
var BooleanPresentationType = new BooleanPresentationTypeClass();

/**
 * Number presentation type
 *
 * @access private
 */
class NumberPresentationTypeClass extends PresentationTypeClass {
  static const nullValue = 0;
  static const lzxtype='number';
  override function accept(value) {
    // NOTE [2009-03-02 ptw] Only required for swf8 whose Number
    // does not understand Infinity
    if ($swf8) {
      switch (value) {
        case "Infinity": return Infinity;
        case "-Infinity": return (- Infinity);
      }
    }
    return Number(value);
  }
}
/** @access private */
var NumberPresentationType = new NumberPresentationTypeClass();

/**
 * Color presentation type
 *
 * @access private
 */
class ColorPresentationTypeClass extends PresentationTypeClass {
  static const nullValue = 0;
  static const lzxtype = 'color';
  override function accept(value) {
    // handle 'transparent' semaphore from compiler (for canvas)
    if (value == -1) {
        return null;
    }
    return LzColorUtils.hextoint(value);
  }
  override function present(value) {
    // look up color names
    var ctab = lz.colors;
    for (var name in ctab) {
      if (ctab[name] === value) {
        return name;
      }
    }
    return LzColorUtils.inttohex(value);
  }
}
/** @access private */
var ColorPresentationType = new ColorPresentationTypeClass();

/**
 * Expression presentation type
 *
 * Attempts to heuristicate a typed value.  If you want something more
 * accurate, specify a target type, don't rely on this!
 *
 * NOTE: [2009-01-14 ptw] This could should be expanded to use JSON,
 * and so handle Date, Array, and Object (or perhaps a introduce
 * JSONPresentationType)
 *
 * @access private
 */
class ExpressionPresentationTypeClass extends PresentationTypeClass {
  static const nullValue = null;
  static const lzxtype = 'expression';
  override function accept(value) {
    switch (value) {
      case "undefined": return void 0;
      case "null": return null;
      case "false": return false;
      case "true": return true;
      case "NaN": return 0/0;
      // NOTE [2009-03-02 ptw] Only required for swf8 whose Number
      // does not understand Infinity
      case "Infinity": return Infinity;
      case "-Infinity": return (- Infinity);
      case "":
        // Should this return the empty string, or null?  The empty
        // string is more JSON-like, null is what Adam proposed in
        // 'Laszlo XML DOM Data Type Strictness - RFC'
        return "";
    }
    // Adam's RFC calls for us to heuristicate color values, but JSON
    // would simply serialize them as numbers.  If you want to parse
    // color names, you should use the color type.
    if (! isNaN(value)) { return Number(value); }
    return String(value);
  }
  // Presentation is just the default string conversion.  JSON would
  // be better because it would preserve the type (distinguish between
  // literals and strings, e.g., `null` vs. `"null"`)
}
/** @access private */
var ExpressionPresentationType = new ExpressionPresentationTypeClass();

/**
 * Size presentation type
 *
 * @access private
 */
class SizePresentationTypeClass extends PresentationTypeClass {
  static const nullValue = null;
  static const lzxtype = 'size';
  override function accept(value) {
    // sizeExpression can be null
    if (value == "null") { return null; }
    // TODO: handle percentage values?
    return Number(value);
  }
}
/** @access private */
var SizePresentationType = new SizePresentationTypeClass();
