/**
  * LzDefs.lzs
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  * @todo 2006-04-07 hqm This machinery could be removed if all
  * callers to sendEvent can be guaranteed to check if the event slot
  * is null before calling it as a function.
  * @topic LZX
  * @subtopic Runtime
  */

/** Sentinel value for events
  * @access private
  */
public class LzDeclaredEventClass /* implements LzEvent */ {

    public function LzDeclaredEventClass () {
      // Debug.debug("%w.%s(%w)", this, arguments.callee, arguments);
    super();
  }

/** True when event is ready to be sent.
  * @type Boolean
  * @keywords readonly
  * @devnote TODO: [2008-03-20 ptw] This really should just be:
  * function get ready() { return this.delegateList.length > 0; }
  */

public var ready:Boolean = false;


/**
  *  Sends the event, passing its argument as the data to all the called
  *  delegates
  * 
  *  @param sd: The data to send with the event.
  */

public function  sendEvent (sd = null ){};

/**
  * @access private
  */
public function clearDelegates ( ){ };

/**
  * @access private
  */
public function removeDelegate (d = null){ };

/**
  * @access private
  */
public function getDelegateCount ( ){return 0};

/**
  * @access private
  */
public function toString ( ){
    return "LzDeclaredEvent";
}

}

public class LzNullEvent extends LzDeclaredEventClass {
    public function LzNullEvent () {
    }

    public override function sendEvent (sd = null) {
        // TODO [hqm 2008-03] This would be useful debugging info to see
        // when apps call sendEvent on null events.
        /*
          if ($debug) {
          Debug.debug('Inefficient call to %s', arguments.callee);
          }
        */
  }
}


var LzDeclaredEvent:LzNullEvent = new LzNullEvent();


/**
 * Private class used to define a value whose computation must be
 * deferred until runtime, such as a CSS style
 * @access private
 */
class LzValueExpr {
}

/**
 * Private class used to distinguish an init expression from an
 * initial value in node attributes.  All forms of 'constraints' are a
 * subclass of this class
 * @access private
 */
class LzInitExpr extends LzValueExpr {
}

/**
 * Private class used to define a 'once' or 'path' constraint
 * @access private
 */
class LzOnceExpr extends LzInitExpr {
  var methodName:String;
  function LzOnceExpr(initMethod:String) {
    this.methodName = initMethod;
  }
}

/**
 * Private class used to define a 'style' (and as a subclass, an
 * 'always') constraint
 * @access private
 */
class LzConstraintExpr extends LzOnceExpr {
  function LzConstraintExpr(constraintMethod:String) {
    super(constraintMethod);
  }
};

/**
 * Private class used to define an 'always' constraint (which also has
 * a dependency method)
 * @access private
 */
class LzAlwaysExpr extends LzConstraintExpr {
  var dependenciesName:String;
  function LzAlwaysExpr(constraintMethod:String, dependenciesMethod:String) {
    super(constraintMethod);
    this.dependenciesName = dependenciesMethod;
  }
}

/**
 * Private class used to define a constraint in a style value
 * @access private
 */
class LzStyleExpr extends LzValueExpr {
  var sourceAttributeName:String;
  function LzStyleExpr(sourceAttributeName:String) {
    this.sourceAttributeName = sourceAttributeName;
  }
}

/**
 * Private class used to define an 'attr()' constraint
 * @access private
 */
class LzStyleAttr extends LzStyleExpr {
  function LzStyleAttr(sourceAttributeName:String) {
    super(sourceAttributeName);
  }
};

/**
 * Private class used to create the binder for `LzStyleAttr` bindings.
 *
 * @param lz.node target: The target node
 * @param String dest: The destination attribute
 * @param String source: The source attribute
 *
 *@access private
 */
class LzStyleAttrBinder {
  var target:LzNode;
  var dest:String;
  var source:String;

  function LzStyleAttrBinder (target:LzNode, dest:String, source:String) {
    this.target = target;
    this.dest = dest;
    this.source = source;
  }

  function bind() {
    var target = this.target;
    target.setAttribute(this.dest, target[this.source]);
  }
}

/**
 * Private class used to define an identifier constraint
 * @access private
 */
class LzStyleIdent extends LzStyleExpr {
  function LzStyleIdent(sourceAttributeName:String) {
    super(sourceAttributeName);
  }
}

/**
  * Used to efficiently clone hashtables using Object's
  * N.B. these tables incorrectly will appear to have entries for all
  * the properties of Object.prototype.  To avoid this (but pay the
  * overhead of a slower implementation, use LzDictionary).
  * @access private
  */
if ($swf9) {
dynamic class LzInheritedHash extends Dictionary {
    #passthrough (toplevel:true) {
import flash.utils.Dictionary;
}#

    function LzInheritedHash (sup:Object = null) {
        if(sup) {
            for (var k in sup) {
                this[k] = sup[k];
            }
        }
    }
}

} else {

function LzInheritedHash (parent)  {
  if (parent) {
    for (var key in parent) {
      this[key] = parent[key];
    }
  }
}

}
/** A map of element names, to functions that create instances of the
  * appropriate type.
  * Each built-in class that defines the implementation of a tag adds
  * itself to this table
  *
  * @access private
  */
var ConstructorMap = {};

/** The `lz` object is a pseudo-package for all LZX globals. Any declared LZX tag
  * can be accessed from JavaScript using the tag name and the `lz` object.
  *
  * <example executable="false">
  *   var foo = new lz.view(canvas, 
  *                         {name:'foo', visible:true, options: {ignorelayout:true}})
  * </example>
  *
  * @short-desc Pseudo-package for all LZX globals
  * @access public
  */
var lz = ConstructorMap;

