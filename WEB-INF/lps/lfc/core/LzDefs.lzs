/**
  * LzDefs.lzs
  *
  * @copyright Copyright 2001-2010 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  * @topic LZX
  * @subtopic Runtime
  */

/**
 * Private class used to define a value whose computation must be
 * deferred until runtime, such as a CSS style
 * @access private
 */
class LzValueExpr {
};

/**
 * Private class that is used to describe LZX &lt;attribute /&gt; fields
 * @access private
 */
class LzAttributeDescriptor extends LzValueExpr {
  // The attribute being described
  var attribute:String;
  // The LZX type of the attribute
  var type:String;
  // The initial value of the attribute (must be a constant)
  var value;

  // The default initial value is `null` to avoid contaminating
  // numeric constraints with NaN (which would happen if we used (void
  // 0)).
  // TODO: [2010-05-18 ptw] We could be smarter here, since we know
  // the type of the attribute and put in the appropriate null value
  // for the type.
  function LzAttributeDescriptor(attribute:String, type:String, value=null) {
    this.attribute = attribute;
    this.type = type;
    this.value = value;
  }
}

/**
 * Private class used to distinguish an init expression from an
 * initial value in node attributes.  All forms of 'constraints' are a
 * subclass of this class
 * @access private
 */
class LzInitExpr extends LzAttributeDescriptor {
  function LzInitExpr(attribute:String, type:String, value=null) {
    super(attribute, type, value);
  }
}

/**
 * Private class used to define a 'once' or 'path' constraint
 * @access private
 */
class LzOnceExpr extends LzInitExpr {
  var methodName:String;
  if ($debug) {
    var _dbg_name;
  } else if ($profile) {
    var _dbg_name;
  }

  function LzOnceExpr(attribute:String, type: String, initMethod:String, description=null) {
    super(attribute, type);
    this.methodName = initMethod;
    if ($debug) {
      this._dbg_name = description;
    } else if ($profile) {
      this._dbg_name = description;
    }
  }
}

/**
 * Private class used to classify 'style' and 'always' constraints
 * @access private
 */
class LzConstraintExpr extends LzOnceExpr {
  function LzConstraintExpr(attribute:String, type: String, constraintMethod:String, description=null) {
    super(attribute, type, constraintMethod, description);
  }
};

/**
 * Private class used to define default style bindings in the LFC
 * @access private
 */
class LzStyleConstraintExpr extends LzConstraintExpr {
  // The CSS property that styles the attribute
  var property:String;
  // The default value, if there is no applicable CSS.  Note that this
  // is different from `value` in LzAttributeDescriptor, because it
  // need not be a constant, it might be another constraint.
  var fallback:*;
  // Whether or not to warn when there is no CSS _and_ no fallback
  var warn:Boolean;

  function LzStyleConstraintExpr(attribute:String, type:String, property:String, fallback=(void 0), warn=true) {
    super(attribute, type, null);
    this.property = property;
    this.type = type;
    this.fallback = fallback;
    this.warn = warn;
    if ($debug) {
      this._dbg_name = attribute + "\"=$style{'" + property + "'}\"";
    } else if ($profile) {
      this._dbg_name = attribute + "\"=$style{'" + property + "'}\"";
    }
  }
}

/**
 * Private class used to define an 'always' constraint (which also has
 * a dependency method)
 * @access private
 */
class LzAlwaysExpr extends LzConstraintExpr {
  var dependenciesName:String;
  function LzAlwaysExpr(attribute:String, type:String, constraintMethod:String, dependenciesMethod:String, description=null) {
    super(attribute, type, constraintMethod, description);
    this.dependenciesName = dependenciesMethod;
  }
}

/**
 * Private class used to define a constraint in a style value
 * @access private
 */
class LzStyleExpr extends LzValueExpr {
  if ($debug) {
    var _dbg_name;
  } else if ($profile) {
    var _dbg_name;
  }

  function LzStyleExpr() {
  }
}

/**
 * Private class used to define an 'attr()' constraint
 * @access private
 */
class LzStyleAttr extends LzStyleExpr {
  var sourceAttributeName:String
  function LzStyleAttr(sourceAttributeName:String) {
    super();
    this.sourceAttributeName = sourceAttributeName;
    if ($debug) {
      this._dbg_name = "attr(" + this.sourceAttributeName + ")";
    } else if ($profile) {
      this._dbg_name = "attr(" + this.sourceAttributeName + ")";
    }
  }
};

/**
 * Private class used to define an identifier constraint
 * @access private
 */
class LzStyleIdent extends LzStyleExpr {
  var sourceValueID:String
  function LzStyleIdent(sourceValueID:String) {
    super();
    this.sourceValueID = sourceValueID;
    if ($debug) {
      this._dbg_name = sourceValueID;
    } else if ($profile) {
      this._dbg_name = sourceValueID;
    }
  }
};

/**
  * Used to efficiently clone hashtables using Object's
  * N.B. these tables incorrectly will appear to have entries for all
  * the properties of Object.prototype.  To avoid this (but pay the
  * overhead of a slower implementation, use LzDictionary).
  * @access private
  */
if ($as3) {
dynamic class LzInheritedHash extends Dictionary {
    #passthrough (toplevel:true) {
import flash.utils.Dictionary;
}#

    function LzInheritedHash (sup:Object = null) {
        if(sup) {
            for (var k in sup) {
                this[k] = sup[k];
            }
        }
    }
}

} else {

function LzInheritedHash (parent)  {
  if (parent) {
    for (var key in parent) {
      this[key] = parent[key];
    }
  }
}

}

/** The `lz` object is a pseudo-package for all LZX globals. Any declared LZX tag
  * can be accessed from JavaScript using the tag name and the `lz` object.
  *
  * <example executable="false">
  *   var foo = new lz.view(canvas, 
  *                         {name:'foo', visible:true, options: {ignorelayout:true}})
  * </example>
  *
  * @shortdesc Pseudo-package for all LZX globals
  * @access public
  */
var lz;

((function () {
    if (lz is Object) {
      // In some runtimes, lz is already defined by the embedding script
    } else if (!lz) {
      // prevent compiler from reporting global assignment warning for lz
      #pragma "warnGlobalAssignments=false"
      lz = new LzInheritedHash();
    } else if ($debug) {
      Debug.error("Can't create `lz` namespace, already bound to %w", lz);
    }
  })());

lz.Formatter = LzFormatter;  // publish
