/**
  * LzMakeLoadSprite.lzs
  *
  * @copyright Copyright 2001-2007 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @topic Kernel
  * @subtopic AS2
  */

/**
  * @access private
  */

class LzMakeLoadSpriteClass {

var transformerID = 0;


/**
  * Makes the given view able to load a remote resource
  */
function transform ( v , src , cache, headers ){
    //super.transform( v );

    for ( var k in this){
        if (typeof v[k] == 'function' && this[k]) {
            // replace old method with _methodname to support super
            //Debug.write('replacing _' + k + ' with ' + k + ' in ' + v);
            v[ '___' + k ] = v[k];
            v[k] = this[k];
        } else {
            //Debug.write('adding ' + k + ' to ' + v);
            v[k] = this[k];
        }
    }

    v.firstsrc = src;
    v.firstcache = cache;
    v.firstheaders = headers;

    if ( v.__LZmovieClipRef == null ){
        v.makeContainerResource();
    }

    if (v.__LZhaser ){
        v.createLoader();
    } else {
        //the view doesn't have the empty resource. We need to try and replace
        //it
        v.makeContainerResource();
        if (! this.loader) v.createLoader();
    }
}
    
/**
  * @access private
  */
function doReplaceResource (){
    //this gets called when a view applies the load transformer but it
    //already had a resource

    // use shadowed doReplaceResource()
    this.___doReplaceResource( );
    if (this._newrescname.indexOf('http:') == 0 || this._newrescname.indexOf('https:') == 0){
        this.createLoader();
    }
}

/**
  * @access private
  */
function createLoader (){
    this.loader = new LzMediaLoader( this , {} );
    this.updateDel = new LzDelegate( this , "updateAfterLoad" );
    this.updateDel.register( this.loader , "onloaddone" );

    this.errorDel = new LzDelegate( this , "__LZsendError" );
    this.errorDel.register( this.loader , "onerror" );
    
    this.timeoutDel = new LzDelegate( this , "__LZsendTimeout" );
    this.timeoutDel.register( this.loader , "ontimeout" );

    //Debug.write('LzMakeLoadSprite.createLoader', this.firstsrc)
    if ( this.firstsrc != null ){
        this.setSource( this.firstsrc , this.firstcache, this.firstheaders );
    }
}



/**
  * @access private
  * @param String newSrc: The url from which to load the resource for this view.
  * @param String cache: If set, controls caching behavior. Choices are
  * "none" , "clientonly" , "serveronly" , "both" -- where both is the default.
  * @param String headers: Headers to send with the request (if any.)
  */
function setSource ( newSrc , cache , headers ){
    if (this.loader.mc.loading == true) {
        LzLoadQueue.unloadRequest(this.loader.mc);
    }
    //Debug.write('setSource', newSrc);
    if (newSrc == '' || newSrc == ' ' || newSrc == null) {
        Debug.error('setSource called with an empty url');
        return;
    }

    this.stopTrackPlay();
    this.isloaded = false;
    if ( this.queuedplayaction == null ){
        this.queuePlayAction( "checkPlayStatus" );
    }

    this.resource = newSrc;
    //this.owner.resource = newSrc;
    //if (this.owner.onresource) this.owner.onresource.sendEvent( newSrc );

    this.owner.__LZvizLoad = false; 
    this.owner.__LZupdateShown();
    this.loader.request( newSrc , cache , headers );
}

/**
  * This method keeps the behavior of setResource consistent between 
  * load-transformed views and those that aren't
  * @access private
  */
function setResource ( nresc ){
    // unload anything currently loading...
    if (this.loader.mc.loading == true) {
        LzLoadQueue.unloadRequest(this.loader.mc);
    }
    if ( nresc == "empty" ){
        // call shadowed setResource()
        this.___setResource( nresc );
    } else { 
        if ( nresc.indexOf('http:') == 0 || nresc.indexOf('https:') == 0){
            this.setSource( nresc );
            return;
        }
        this.loader.attachLoadMovie( nresc );
        if ( this.queuedplayaction == null ){
            this.queuePlayAction( "checkPlayStatus" );
        }
        //this.updateAfterLoad();
    }
}

//handle error


/**
  * Updates movieclip properties after the resource has loaded
  * @access private
  */
function updateAfterLoad (){

    this.isloaded = true;
    var mc = this.getMCRef();
    this.resourcewidth = mc._width;
    this.resourceheight = mc._height;

    this.currentframe = mc._currentframe;

    var tfchg = this.totalframes != mc._totalframes;
    if ( tfchg ){
        this.totalframes = mc._totalframes;
        this.owner.totalframes = mc._totalframes;
        if (this.owner.ontotalframes && this.owner.ontotalframes.ready) this.owner.ontotalframes.sendEvent( this.totalframes );
    }

    if ( this.totalframes > 1 ){
        this.checkPlayStatus();
    }
    this.updateResourceSize(); 
    if ( this._setrescheight ){
        var yscale = this.height/this.resourceheight;
        this.__LZmovieClipRef._yscale = yscale * 100;
    }
    if ( this._setrescwidth ){
        var xscale =this.width/this.resourcewidth;
        this.__LZmovieClipRef._xscale = xscale * 100;
    }
    if (this.setButtonSize)
        this.setButtonSize( "height" , this.height );
    if (this.setButtonSize)
        this.setButtonSize( "width" , this.width );

    //Debug.write(xscale, yscale, this);

    this.owner.__LZvizLoad = true; 
    this.owner.__LZupdateShown();
    this.owner.resourceload({width: this.resourcewidth, height: this.resourceheight, resource: this.resource, skiponload: false});
    this.owner.reevaluateSize( );   
    //if (this.owner.onload) this.owner.onload.sendEvent( this.loader.mc );

    //Debug.write('Sprite.updateAfterLoad', mc, this.resourcewidth, this.resourceheight, this.resource, this.owner.resource, this.owner, this.x);
    //Debug.warn('Sprite.updateAfterLoad');
}

/**
  * Unloads the media
  * @access private
  */
function unload () {
    this.loader.unload( this.loader.mc );
}

/**
  * Get a reference to the control mc
  * @access private
  */
function getMCRef () {
    //return null if not loaded
    if (this.loader.isaudio) return this.loader.mc;
    return this.isloaded ? this.loader.getLoadMC() : null;
}

/**
  * Get the number of bytes loaded so far
  * @return: A number that is the maximum offset for this resource
  */
function getLoadBytes (){
    return this.getMCRef().getBytesLoaded();
}

/**
  * Get the total number of bytes for the attached resource
  * @return: A number that is the maximum offset for this resource
  */
function getMaxBytes (){
    return this.getMCRef().getBytesTotal();
}

/**
  * @access private
  */
function __LZsendError ( e ){
    this.resourcewidth = 0;
    this.resourceheight = 0;
    if (this.owner) this.owner.resourceloaderror( e )
}

/**
  * @access private
  */
function __LZsendTimeout ( e ){
    this.resourcewidth = 0;
    this.resourceheight = 0;
    if (this.owner) this.owner.resourceloadtimeout( e )
}

/**
  * @access private
  */
function destroy () {
    if ('updateDel' in this)
         this.updateDel.unregisterAll();
    if ('errorDel' in this)
         this.errorDel.unregisterAll();
    if ('timeoutDel' in this)
         this.timeoutDel.unregisterAll();
 
    this.loader.unload( this.loader.mc );

    // call shadowed destroy()
    this.___destroy(); 
}

} // End of LzMakeLoadSpriteClass

var LzMakeLoadSprite  = new LzMakeLoadSpriteClass;
