/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access private
  * @topic LFC
  * @subtopic Data
  */
  
/** @access private */
class LzDataAttrBind extends LzDatapointer {

function LzDataAttrBind ( ndpath:LzDatapath, attr:String, path:String, type:String ){
    super (ndpath);
    this.type = type;
    this.setAttr = attr;
    this.pathparent = ndpath;
    this.node = ndpath.immediateparent;
    this.setXPath( path );

    this.rerunxpath = true; // From LzDatapointer
    if ( ndpath.__LZdepChildren == null ){
        ndpath.__LZdepChildren = [ this ];
    } else {
        ndpath.__LZdepChildren.push( this );
    }
}


// prototype.rerunxpath = true; // Override value defined in LzDatapointer

/** @access private */
var $pathbinding :Boolean = true;
/** @access private */
var setAttr :String;
/** @access private */
var pathparent :LzDatapath;
/** @access private */
var node :LzNode;
/** @access private */
var type :String;

/**
  * @access private
  */
override function __LZsendUpdate (upd:Boolean = false, upp:Boolean = false) :Boolean { 
    if ( super.__LZsendUpdate(upd, upp) ) {
        var data:* = this.data;
        var node:LzNode = this.node;
        var attr:String = this.setAttr;
        if (this.__LZpchanged || node[ attr ] != data || this.parsedPath.operator == "attributes") {
            //this test is necessary or properties get set to undefined
            node.acceptAttribute(attr, this.type, data == null ? null : data);
            // reset visibility a la datapaths for views
            if (node['__LZvizDat'] != null) {
                node.__LZvizDat = node[attr] != null;
                node.__LZupdateShown();
            }
        }
    }
}


/**
  * This matches the LzDelegate method of the same name so that these objects
  * can be stored in a node's __LZdelegates array.
  */
function unregisterAll () :void { 
    var dca:Array = this.pathparent.__LZdepChildren;

    if (dca != null) {
        for (var i:int = 0; i < dca.length; i++) {
            if ( dca [ i ] === this ){
                dca.splice( i , 1 );
                break;
            }
        }
    }

    this.destroy();
}

/**
  * @access private
  */
override function setDataContext (dc, implicit:Boolean = false) :void {
    super.setDataContext(dc || this.pathparent, implicit);
}

/**
  * @access private
  */
override function updateData() {
    this.__LZupdateData();
}

/**
  * @devnote: the function signature must match LzDatapath#__LZupdateData(Boolean)
  * @access private
  */
function __LZupdateData (recursive:Boolean = false) :void {
    //this code is largely copied from LzDatapath, but it's slightly different
    var ppdo = this.parsedPath.operator;
    if (ppdo != null) {
        var dat = this.node.presentAttribute(this.setAttr, this.type)
        //Debug.write('__LZupdateData', this.node, this.setAttr, this.type, dat, this.data);
        if (this.data != dat) {
            if (ppdo == "nodeName") {
                this.setNodeName( dat );
            } else if (ppdo == "__LZgetText") {
                this.setNodeText( dat );
            } else if (ppdo == "attributes") {
                this.p.setAttrs( dat );
            } else {
                //remove the "attributes." from the operator
                this.setNodeAttribute( ppdo.substring( 11 ) , dat );
            }
        }
    }
}

override function toString () :String { 
    return 'binder ' + this.xpath;
}

if ($debug) {
     LzDataAttrBind.prototype._dbg_name = function () {
        return Debug.formatToString("%w.%s=\"$path{%w}\"", this.node, this.setAttr, this.xpath);
    }
}

} // End of LzDataAttrBind
