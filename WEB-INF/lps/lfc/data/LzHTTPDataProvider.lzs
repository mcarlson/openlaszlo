/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @topic LFC
  * @subtopic Data
  */


/**
  * <p>
  * <class>LzHTTPDataProvider</class> implements the DataProvider interface, to support HTTP data requests.
  * </p>  
  * <p>
  * Requests are submitted using the <method>doRequest</method>, passing a  request
  * object of type <class>LzHTTPDataRequest</class>. And instance of <class>LzHTTPDataProvider</class> is the default
  * data provider for the runtime, and is what is used by <class>LzDataset</class> to load data.
  * </p>
  * <p>
  * <event>onstatus</event>: Sent to a datarequest to update the status of the request.</p>
  *
  * @shortdesc DataProvider which implements HTTP request transport
  * @lzxname httpdataprovider
  *
  */




class LzHTTPDataProvider extends LzDataProvider {

    function LzHTTPDataProvider ( parent:* = null, attrs:* = null, children:* = null, instcall:*  = null) {
        super(parent,attrs,children,instcall);
    }  

    /** @access private
     * @param LzHTTPDataRequest dreq: The data request
     */

    function makeLoader ( dreq ) {
        var proxied = dreq.proxied;
        // If there is no loader, or if the loader changed it's proxied
        // flag, make a new loader.
        var tloader = new LzHTTPLoader(this, proxied);
        dreq.loader = tloader;
        tloader.loadSuccess = this.loadSuccess;
        tloader.loadError   = this.loadError;
        tloader.loadTimeout = this.loadTimeout;

        tloader.setProxied(proxied);

        /** TODO [hqm 2007-08] This code below to deal with secureport is likely broken, 
         * I need to undersatnd what is the behavior of "secureport"
         */
        /*************/
        var secure = ('secure' in dreq) ? dreq.secure : null;
        if (secure == null) {
            if (dreq.src.substring(0, 5) == "https") {
                secure = true;
            }
        }
        if (secure) {
            tloader.baserequest = lz.Browser.getBaseURL( secure, dreq.secureport );
            //Debug.write('basereq ' + tloader.baserequest);
        }
        tloader.secure = secure;
        if (secure) {
            tloader.secureport = dreq.secureport;
        }
        /*************/
    
        return tloader;
    }



    /**
     * Interrupts any load in progress for the given dataset.
     * @param LzDataRequest dreq: The data request for which to interrupt the load.
     * @access public
     */
    function abortLoadForRequest( dreq ) {
        dreq.loader.abort();        
    }

    /**
     * @access public
     */
    override function doRequest ( dreq ) {
        // dreq.src can be null if the dataset is loaded from initialdata
        if (!dreq.src)
            return;

        //build request
        var proxied = dreq.proxied;
        // Check for previously created loader, we can reuse it

        // TODO [hqm 2007-08] If multirequests is true, we make a new loader
        // for each request. Is this correct? 
        var tloader = dreq.loader;
        if ( tloader == null || dreq.multirequest == true || dreq.queuerequests == true) {
            tloader = this.makeLoader( dreq );
        }

        tloader.dataRequest = dreq;

        tloader.setQueueing(dreq.queuerequests);
        tloader.setTimeout(dreq.timeout);

        tloader.setOption('cacheable',      dreq.cacheable == true);
        tloader.setOption('timeout',        dreq.timeout);
        tloader.setOption('trimwhitespace', dreq.trimwhitespace == true);
        tloader.setOption('nsprefix',       dreq.nsprefix == true);
        tloader.setOption('sendheaders',    dreq.getresponseheaders == true);

        if ( dreq.clientcacheable != null ){
            tloader.setOption('ccache',     dreq.clientcacheable);
        }


        var headers = {};
        var headerparams = dreq.requestheaders;
        if (headerparams != null) {
            var headernames = headerparams.getNames();
            for (var i = 0; i < headernames.length; i++) {
                var key = headernames[i];
                var val = headerparams.getValue(key);
                if (proxied) {
                    // Pass this to makeProxiedURL
                    headers[key] = val;
                } else {
                    // SOLO request, set these directly using the LzHTTPLoader API
                    tloader.setRequestHeader(key, val);
                }
            }
        }

        var qparams = dreq.queryparams;

        // Convert queryparams table into a URL-encoded query-style string
        var sep = '';
        var q = '';
        
        // If an explicit post body content arg wasn't supplied, make
        // a url-form-encoded string from the queryparams data.

        var cachebreak = "__lzbc__="+(new Date()).getTime();

        // Default assume we are posting query data (key-value pairs)
        var hasquerydata = true;


        var postbody = dreq.postbody;
        if (postbody == null && qparams != null) {
            var names = qparams.getNames();
            for ( var i in names ){
                var name = names[i];
                q += sep + name + '=' + encodeURIComponent(qparams.getValue(name));
                sep = '&';
            }

            postbody = q;
        } else {
            //We are asking the swf8 runtime to treat this as raw data, as best it can
            hasquerydata = false;
        }

        tloader.setOption('hasquerydata', hasquerydata);


        var lzurl = new LzURL(dreq.src);

        // For GET requests, merge in params data with URL query 
        if (dreq.method == "GET") {
            if (lzurl.query == null) {
                lzurl.query = postbody;
            } else {
                if (postbody != null) {
                    lzurl.query += ("&" + postbody);
                }
            }
            postbody = null;
        }

        // [LPP-5368] If this is a SOLO POST request, with an empty
        // POST body, put the 'cache-breaking' arg into this post
        // body. This prevents the case of an empty POST body, which
        // would cause the Flash player to turn it into a GET request.
        //
        // We are going to go ahead and do this for all platforms, not
        // just SWF, in order to make things more consistent for the
        // app developer; they will get this magic arg added across
        // all platforms.
        if (!proxied && (dreq.method == "POST") && (postbody == null || postbody == ''))  {
            postbody = cachebreak;
        }

        // convert url back to string
        var url;
        if (proxied) {
            // TODO [hqm 2007-08-03] make the API for makeProxiedURL take an explicit host arg,
            // so we can set the proxy from user code
            url = tloader.makeProxiedURL(dreq.proxyurl, lzurl.toString(), dreq.method, "xmldata" , headers, postbody);

            // We need to move the proxy string query data to the
            // postbody; can't leave it in the URL string since it
            // could be arbitrarily long.
            var marker = url.indexOf('?');
            var uquery = url.substring(marker+1, url.length);
            var url_noquery = url.substring(0,marker);
            url = url_noquery + '?' + cachebreak;
            postbody = uquery;

        }  else {
            // break the browser cache by adding a unique string to the url
            if (!dreq.clientcacheable) {
                if (dreq.method == "GET") {
                    // GET case: add to url query portion
                    if (lzurl.query == null) {
                        lzurl.query = cachebreak;
                    } else {
                        lzurl.query += ("&" + cachebreak);
                    }
                }
            }

            url = lzurl.toString();
        }
   
        dreq.loadstarttime = (new Date()).getTime();

        dreq.status =  "loading";
        tloader.open ( proxied ? "POST" : dreq.method, url, /* username */ null, /* password */ null);
        tloader.send (/* content */ postbody);
    }

    /**
     * @access private
     */
    function loadSuccess ( loader, data ) { 
        var dreq = loader.dataRequest;
        dreq.status = LzDataRequest.SUCCESS;
        loader.owner.loadResponse( dreq, data );
    }

    /**
     * @access private
     */
    function loadError( loader, data ) { 
        var dreq = loader.dataRequest;
        dreq.status = "error";
        loader.owner.loadResponse( dreq, data );
    }

    /**
     * @access private
     */
    function loadTimeout( loader, data ) { 
        var dreq = loader.dataRequest;
        dreq.loadtime = (new Date()).getTime() - dreq.loadstart;
        dreq.status = LzDataRequest.TIMEOUT;
        dreq.onstatus.sendEvent( dreq );
    }

    /**
     * @access private
     */
    function setRequestError (dreq, msg) {
        dreq.error = msg;
        dreq.status = LzDataRequest.ERROR;
    }

    /**
     * @access private
     * @param dataRequest dreq:
     * @param LzDataElement data:
     */
    function loadResponse( dreq, data ) {
        var headers = new LzParam( );
        // build a hashtable of header values. 
        // If the header is repeated, construct a list to hold
        // all its values.
        var content = null;

        dreq.loadtime = (new Date()).getTime() - dreq.loadstarttime;

        if (data == null) {
            this.setRequestError(dreq, "client could not parse XML from server");
            dreq.onstatus.sendEvent( dreq );
            return;
        }

        var proxied = dreq.proxied;

        if (proxied && data.childNodes[0].nodeName == "error") {
            this.setRequestError(dreq, data.childNodes[0].attributes['msg']);
            dreq.onstatus.sendEvent( dreq );
            return;
        }

        if (proxied) {
            // For proxied requests, we get back an XML wrapper
            // <resulset><body>DATA</body><headers>HEADERS</headers></resultset>
            // extract the headers and body below:
            var hos = ('childNodes' in data.childNodes[1]) ? data.childNodes[1].childNodes : null;
            // get proxy metadata (header, etc) info if any
            if (hos != null) {
                for ( var i = 0; i < hos.length; i++ ){
                    var h = hos[i];
                    if (h.attributes) headers.addValue( h.attributes.name , h.attributes.value );
                }
            }
            if (data.childNodes[0].childNodes) content = data.childNodes[0].childNodes[0];
        } else {
            // SOLO requests are raw XML data
            content = data;
        }

        dreq.xmldata = content;
        dreq.responseheaders = headers;
        dreq.rawdata = dreq.loader.getResponse();
        dreq.onstatus.sendEvent( dreq );

    }
}


/**
  * <p>
  * <class>LzHTTPDataRequest</class> implements the DataProvider interface, to support HTTP data requests.
  * </p>
  *
  * @shortdesc A class to represent HTTP data requests.
  * @lzxname httpdatarequest
  */


class LzHTTPDataRequest extends LzDataRequest {

    function LzHTTPDataRequest (requestor = null) { 
        super(requestor);
    } 

    var method:String = "GET"; //  : String; // GET, POST, PUT, DELETE
    var postbody:String;
    var proxied:Boolean;
    var proxyurl:String;  
    var multirequest:Boolean = false;
    var queuerequests:Boolean = false;

    /** An LzParam object which holds query key-value pairs.
        @type LzParam
    */
    var queryparams = null; // : LzParam object

    /** An LzParam object which holds HTTP request headers as key-value pairs.
        @type LzParam
    */
    var requestheaders = null; // : LzParam object

    /** Flag to say whether proxied server should return with HTTP response metadata added. 
        @type Boolean
    */
    var getresponsheaders = false;
    /** An LzParam object which holds HTTP response headers
        @type LzParam
    */
    var responseheaders = null; 

    var getresponseheaders = null;

    /** Flag to say whether data is cacheable at the server
        @type Boolean
    */
    var  cacheable         = false;
    /** Flag to say whether data is cacheable at the client (browser)
        @type Boolean
    */
    var  clientcacheable   = null;
    /** Flag to say whether whitespace should be trimmed from text element data in returned XML data
        @type Boolean
    */
    var  trimwhitespace    = false;
    /** Flag to say whether namespace prefixes on element and attribute names is preserved in XML data
        @type Boolean
    */
    var  nsprefix          = false;


    /** The LZX DOM element containing the loaded data */
    var xmldata = null;
    /** Time taken by load, in milliseconds
        @type Number
    */
    var loadtime = 0;
    var loadstarttime;

    var secure = false;
    var secureport;


    // private, pointer to our lzhttploader
    /** @access private */
    var loader = null;

}
