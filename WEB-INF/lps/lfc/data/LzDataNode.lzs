/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @topic LFC
  * @subtopic Data
  */
  
// Only static methods and variables remain here

class LzDataNode {

//@problem: how do I document these?
static var ELEMENT_NODE = 1;
static var TEXT_NODE = 3;
static var DOCUMENT_NODE = 9;

/** this is similar to the escape routine in LzText, but that one's shorter
  * since flash it's just for escaping &gt;&lt;
  * @access private
  */
static var __LZescapechars = 
{ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&apos;'};


/**
  * @access private
  */
static function __LZXMLescape ( t ){
    if ( typeof( t ) != "string" ) return t;

    var olen = t.length;
    var r = "";
    for ( var i = 0; i < olen; i++ ){
        //handle newlines
        var code = t.charCodeAt( i );
        if ( code < 32 ){
            r += "&#x" + LzUtils.dectohex(code,0) + ";";
        } else {
            var c = t.charAt( i );
            if ( LzDataNode.__LZescapechars[ c ] != null ){
                r += LzDataNode.__LZescapechars[ c ];
            } else {
                r += c;
            }
        }
    }

    return r;
}


/**
  * Converts string to XML data.
  * @param String str: A valid string of XML. If the string is simple text, or
  * that there isn't a single root element, this function returns null. In cases
  * where the string is an invalid but well formatted snippet of XML, this
  * function will close any tags to make for a valid XML document
  * @param boolean trimwhitespace: if true, text nodes have whitespace trimmed from start and end.
  * @param boolean nsprefix: if true, preserve namespace prefixes on node names and attribute names.
  * @return LzDataElement: An LzDataElement which is the top of the hierarchy
  * generated from the string
  */
static function stringToLzData( str, trimwhitespace, nsprefix ) {
    // [todo hqm 2006-06] if we had try-catch, I'd try to catch errors in parseXML
    // and return null in that case. 
    if (str != null && str != "") {
        //Debug.info("stringToLzData: parsing: ", typeof(str), str);
        var nativexml = LzXMLParser.parseXML(str, trimwhitespace, nsprefix);
        var lfcnode = LzXMLTranslator.copyXML(nativexml, trimwhitespace, nsprefix);
        return lfcnode;
    } else {
        return null;
    }
}

static var whitespaceChars = {' ': true, '\r': true, '\n': true, '\t': true};


/**
  * trim whitespace from start and end of string
  * @access private
  */
static function trim( str ) {
    var whitech = LzDataNode.whitespaceChars;
    var len = str.length;
    var sindex = 0;
    var eindex = str.length -1;
    var ch;
    while (sindex < len) {
        ch = str.charAt(sindex);
        if (whitech[ch] != true) break;
        sindex++;
    }

    while (eindex > sindex) {
        ch = str.charAt(eindex);
        if (whitech[ch] != true) break;
        eindex--;
    }
        
    return str.slice(sindex,eindex+1);
}

} // End of LzDataNode
