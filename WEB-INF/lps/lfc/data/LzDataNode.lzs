/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @topic LFC
  * @subtopic Data
  */
  
/**
  * <p><classname>lz.DataNode</classname> is the base class for the classes
  * that represent OpenLaszlo's hierarchical data format.</p>
  * 
  * <example>
  * &lt;canvas width="300" height="300"&gt;
  *   &lt;simplelayout axis="y"/&gt;
  * 
  *   &lt;text width="300" height="250" bgcolor="silver" 
  *         multiline="true" name="display"/&gt;
  *   &lt;button&gt;Make some data
  *     &lt;attribute name="currentstep" value="0"/&gt;
  * 
  *     &lt;handler name="onclick"&gt;
  *       &lt;![CDATA[ 
  *       switch(currentstep ++){
  *         case 0:
  *           this.n = <em>new LzDataElement('numbers');</em>
  *           setAttribute('text', 'Add some children');
  *           break;
  *         case 1:
  *           for (var i = 1; i &lt; 11 ; i++){
  *             <em>this.n.appendChild(new LzDataElement('number' , 
  *                                                      {value : i}));</em>
  * 
  *           }
  *           setAttribute('text', 'Add linebreaks');
  *           break;
  *         case 2:
  *           var dp = new LzDatapointer();
  *           dp.setPointer(this.n.getFirstChild());
  *           do {
  *             <em>dp.p.parentNode.insertBefore(new LzDataText('\n'), 
  *                                              dp.p);</em>
  *           } while (dp.selectNext())
  *           dp.p.parentNode.appendChild(new LzDataText('\n')); 
  *           setAttribute('visible', false);
  *           break;
  *       }
  *       display.setText(display.escapeText(n.serialize()));
  *       ]]&gt;
  *     &lt;/handler&gt;
  *   &lt;/button&gt;
  * &lt;/canvas&gt;
  * </example>
  * 
  * @shortdesc The base class for a node of hierarchical data.
  * @devnote LzDataNodeMixin is the abstract baseclass for LzDataElement and LzDataText.
  * N.B.: LzDataNodeMixin may or may not be an LzNode, so _if_ it were
  * to have an initialize method, it would have to match
  * LzNode.initialize's signature.
  *
  * @devnote Also N.B.: If this _does_ descend from LzNode and has initial
  * data, childNodes will have already been set by applyArgs, so
  * don't set it here!
  */

mixin LzDataNodeMixin {
/** @lzxtype event */
var onownerDocument :LzDeclaredEventClass = LzDeclaredEvent;
/** @lzxtype event */
var onDocumentChange :LzDeclaredEventClass = LzDeclaredEvent;
/** @lzxtype event */
var onparentNode :LzDeclaredEventClass = LzDeclaredEvent;
/** @lzxtype event */
var onchildNode :LzDeclaredEventClass = LzDeclaredEvent;
/** @lzxtype event */
var onchildNodes :LzDeclaredEventClass = LzDeclaredEvent;
/** @lzxtype event */
var onattributes :LzDeclaredEventClass = LzDeclaredEvent;
/** @lzxtype event */
var onnodeName :LzDeclaredEventClass = LzDeclaredEvent;

/** The type of this node -- ELEMENT_NODE or TEXT_NODE
  * @type int
  * @keywords abstract
  */
var nodeType :int; // This is undefined. Set elsewhere

var parentNode :* = null;

var ownerDocument :LzDataElementMixin;

/** @access private */
var __LZo :int = -1;
/** @access private */
var sel :Boolean = false;

/** An array of children of this node
  * @type LzDataNodeMixin
  */
var childNodes :Array = null;

/** @access private */
var __LZcoDirty :Boolean = true;

/** 
  * @devnote: used to track view-sizes, see LzResizeReplicationManager
  * @access private
  */
var __LZsize :Object;

/**
 * Returns the parent of this node
 * @return LzDataElementMixin: the parent of this node
 */
public function getParent () /*:LzDataElementMixin*/ {
  return this.parentNode;
}

/**
  * gets offset of node in parent's childNodes array
  * @return int
  */
public function getOffset () :int {
    if (!this.parentNode) return 0;
    if (this.parentNode.__LZcoDirty) this.parentNode.__LZupdateCO();

    return this.__LZo;
}

/**
  * Returns the sibling before this one this node's parentNodes List of children
  * @return LzDataNodeMixin: The node preceeding this one in this node's childNodes
  */
public function getPreviousSibling () /*:LzDataNodeMixin*/ {
    if (!this.parentNode) return null;
    if ( this.parentNode.__LZcoDirty ) this.parentNode.__LZupdateCO();
    return this.parentNode.childNodes[ this.__LZo - 1 ];
}

/** @access private */
function $lzc$getPreviousSibling_dependencies( who, self ) :Array {
    return [ this.parentNode , "childNodes" , this , "parentNode" ];
}

/**
  * Returns the sibling after this one this node's parentNodes List of children
  * @return LzDataNodeMixin: The node succeeding this one in this node's childNodes
  */
public function getNextSibling () /*:LzDataNodeMixin*/ {
    if (!this.parentNode) return null;
    if ( this.parentNode.__LZcoDirty ) this.parentNode.__LZupdateCO();
    return this.parentNode.childNodes[ this.__LZo + 1 ];
}

/** @access private */
function $lzc$getNextSibling_dependencies( who, self ) :Array {
    return [ this.parentNode , "childNodes" , this , "parentNode" ];
}



/** @access private
  * Renamed from childOf to avoid conflict with LzNode.childOf.
  * childOf still exists because it is part of the public API.
  */
function childOfNode ( el, allowself:Boolean = false ) :Boolean {
    var p = allowself ? this : this.parentNode
    while ( p ){
        if ( p == el ) return true;
        p = p.parentNode;
    }
    return false;
}

/**
  * Tells whether the given node is above this one in the node hierarchy.
  * @param LzDataElement el: The LzDataElement to test to see if it is above
  * this one
  * @param Boolean allowself: If true, this function returns true if the given
  * node is the same as this node.
  */
override function childOf ( el, allowself=false ) {
  return this.childOfNode(el, allowself);
}

/** @access private */
function $lzc$set_ownerDocument (ownerDoc:LzDataElementMixin) :void {
    this.ownerDocument = ownerDoc;
    if (this.childNodes) {
        for (var i:int = 0; i < this.childNodes.length; i++) {
            this.childNodes[ i ].$lzc$set_ownerDocument( ownerDoc );
        }
    }

    if (this.onownerDocument.ready) {
        this.onownerDocument.sendEvent( ownerDoc );
    }
}

/**
  * Sets the LzDataNodeMixin which is the ownerDocument for this node.
  * @param LzDataNodeMixin ownerDoc: The LzDataNodeMixin to act as the ownerDocument for
  * this node.
  * @deprecated Use setAttribute('ownerDocument', ...) instead.
  */
public final function setOwnerDocument (ownerDoc) :void {
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    this.$lzc$set_ownerDocument(ownerDoc);
}

/**
  * Returns a copy of this node.
  * @param Boolean deep: If true, the children of this node will be part of the
  * new node
  * @return LzDataNodeMixin: A copy of this node.
  */
public function cloneNode ( deep:Boolean = false ) :LzDataNodeMixin {
    /* not implemented here */
    return undefined;
}

/**
  * Returns this node as a string of xml.
  * @return String: The string serialization of this node.
  */
public function serialize (len:Number = Infinity) :String {
    /* not implemented here */
    return undefined;
}

/**
  * @access private
  */
function __LZlockFromUpdate (locker:LzDatapath) :void {
    this.ownerDocument.__LZdoLock( locker );
}

/**
  * @access private
  */
function __LZunlockFromUpdate (locker:LzDatapath) :void {
    this.ownerDocument.__LZdoUnlock( locker );
}

/**
  * @access private
  * @see LzResizeReplicationManager
  */
function __LZgetSize (k:String) :* {
    return this.__LZsize && this.__LZsize[k];
}

/**
  * @access private
  * @see LzResizeReplicationManager
  */
function __LZsetSize (k:String, v:*) :void {
    if (! this.__LZsize) this.__LZsize = {};
    this.__LZsize[k] = v;
}

} // End of LzDataNodeMixin
lz.DataNodeMixin = LzDataNodeMixin;  // publish


/**
 * @topic LFC
 * @subtopic Data
 *
 * @shortdesc The base class for a node of hierarchical data.
 *
 * <p><code>lz.DataNode</code> is deprecated, all methods and constants have been moved to <link linkend="LzDataElement">lz.DataElement</link></p>
 *
 * @access public
 * @deprecated Use <code>LzDataElement.ELEMENT_NODE</code> instead. The methods and constants in this class are deprecated
 *
 */
class LzDataNode extends LzEventable {

/**
  * @access private
  */
    function LzDataNode () {
        super();
    }

/** @deprecated Use <code>LzDataElement.ELEMENT_NODE</code> instead
  * @type int
  * @lzxdefault "1"
  * @keywords read-only
  */
static const ELEMENT_NODE :int = 1;

/** @deprecated Use <code>LzDataElement.TEXT_NODE</code> instead
  * @type int
  * @lzxdefault "3"
  * @keywords read-only
  */
static const TEXT_NODE :int = 3;

/** @deprecated Use <code>LzDataElement.DOCUMENT_NODE</code> instead
  * @type int
  * @lzxdefault "9"
  * @keywords read-only
  */
static const DOCUMENT_NODE :int = 9;


/**
  * Converts string to XML data.
  * @param String str: A valid string of XML. If the string is simple text, or
  * that there isn't a single root element, this function returns null. In cases
  * where the string is an invalid but well formatted snippet of XML, this
  * function will close any tags to make for a valid XML document
  * @param boolean trimwhitespace: if true, text nodes have whitespace trimmed from start and end.
  * @param boolean nsprefix: if true, preserve namespace prefixes on node names and attribute names.
  * @return LzDataElement: An LzDataElement which is the top of the hierarchy
  * generated from the string
  * @deprecated Use <code>LzDataElement.stringToLzData</code> 
  */
static function stringToLzData( str:String, trimwhitespace:Boolean = false, nsprefix:Boolean = false ) :LzDataElement {
    if ( $debug ){
        Debug.info("LzDataNode.stringToLzData is deprecated.  Use `LzDataElement.stringToLzData` instead.");
    }
    return LzDataElement.stringToLzData(str, trimwhitespace, nsprefix);

}

/**
 * Needed because LzDataElementMixin wants to override this, and it is
 * mixed in to both this and LzNode which defines toString, so _we_
 * have to define it too.
 * @access private
 */
function toString () /*:String*/ { 
    return "LzDataNode";
}

} // End of LzDataNode
lz.DataNode = LzDataNode;  // publish
