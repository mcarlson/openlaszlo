/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @topic LFC
  * @subtopic Data
  */

/**
  * <p>
  * When a view's datapath matches more than one data node, one instance
  * of the view is created for each match. The replicated views are
  * referred to as <glossterm>clones</glossterm>' When this happens, a
  * <glossterm>replication manager</glossterm> (or a subclass of
  * <classname>LzReplicationManager</classname>) is created to manage the
  * clones. Replication managers are never directly instantiated &#x2014;
  * 
  * they are created when a datapath makes multiple matches.</p>
  * 
  * <p>If the replicated view was named, the clone manager takes over the
  * named spot in the parent. The example below demonstrates this, and
  * shows how to reference individual clones.</p>
  * 
  * <p>In the example that follows, a view, called
  * <varname>replView</varname> is bound to a dataset
  * <varname>somedata</varname>. For each matching node in the dataset, a
  * new view is created. These views contain the text of the dataset.  In
  * other words, the single line</p>
  * 
  * <pre>
  * &lt;view name="replView" datapath="somedata:/*"&gt;
  * 
  * </pre>
  * 
  * <p>causes the creation of five views (because there were five elements
  * in the dataset that matched the selection criteria). These "cloned"
  * views are numbered successively, starting with zero. The highlited
  * section of the code below shows how to use the
  * <method>getCloneNumber</method> method to access each replicated
  * view.</p>
  * 
  * <example>
  * &lt;canvas height="140"&gt;
  *   &lt;dataset name="somedata"&gt;
  *     &lt;one/&gt; &lt;two/&gt; &lt;three/&gt; &lt;four/&gt; &lt;five/&gt;
  * 
  *   &lt;/dataset&gt;
  *   &lt;simplelayout/&gt;
  *   &lt;button onclick="moveClone()"&gt;
  *     Move clone 
  *     <em>&lt;method name="moveClone"&gt;&lt;![CDATA[
  *       var nextClone = replView.getCloneNumber(this.cnum++);
  *       if (nextClone == null) {
  *         this.cnum = 0;
  *         var nextClone = replView.getCloneNumber(this.cnum++);
  *       }
  *       nextClone.setAttribute('x', nextClone.x + 10);
  *     ]]&gt;&lt;/method&gt;</em>
  *     &lt;attribute name="cnum" value="0"/&gt;
  * 
  *   &lt;/button&gt;
  *   &lt;view name="replView" datapath="somedata:/*"&gt;
  *     &lt;text datapath="name()"/&gt;
  *   &lt;/view&gt;
  * &lt;/canvas&gt;
  * </example>
  * 
  * @shortdesc The controller for views replicated by data.
  *
  * @devnote A replication manager controls the replication of views as a result of 
  * multiple matches to a datapath's xpath. When a datapath matches more than
  * one node, it immediate halts its own processing and creates a replication 
  * manager to take over management of that datapath. If the view that contained
  * the datapath being replicated was named, the replication manager assumes that
  * name, so that it can be referred to the same way the non-replicated view
  * would have been. 
  */
dynamic class LzReplicationManager extends LzDatapath {

/** @access private */
override function $lzc$set_datapath(v) { this.setXPath(v); }

/** @access private */
var asyncnew :Boolean = true;
/** @access private */
var initialnodes :Array;
/** @access private */
var clonePool :Array;
/** @access private */
var cloneClass;
/** @access private */
var cloneParent :LzNode;
/** @access private */
var cloneAttrs :Object;
/** @access private */
var cloneChildren :Array;
/** @access private */
var hasdata :Boolean;
/** @access private */
var orderpath :*;

/** @access private */
var comp_orderf;  // Was this.orderf.comp
/** @access private */
var op_orderf;    // Was this.orderf.op

// var datacontrolsvisibility = false; // Defined in LzDatapath
/** 
  * @modifiers override
  * @access private
  */ 
// var __LZtakeDPSlot = false;

/**
 * Globally controls the visibility of the clones this replication
 * manager creates.
 *
 * @type Boolean
 * @lzxtype boolean
 * @lzxdefault true
 * @keywords final
 */
var visible :Boolean = true;
/** @access private */
var __LZpreventXPathUpdate :Boolean = false;

/**
 * The data that this replication manager will map to views
 * @type [*]
 */
var nodes :Array;

/**
 * The views which this LzReplicationManager has created.
 * @type [LzNode]
 */
var clones :Array;

/** @access private */
var __LZdataoffset :int = 0;
/**
 * Sent when <code>nodes</code> is changed
 * @lzxtype event
 */
var onnodes :LzDeclaredEventClass = LzDeclaredEvent;
/**
 * Sent when <code>clones</code> is changed
 * @lzxtype event
 */
var onclones :LzDeclaredEventClass = LzDeclaredEvent;
/**
 * Sent when <code>visible</code> is changed
 * @lzxtype event
 */
var onvisible :LzDeclaredEventClass = LzDeclaredEvent;

/**
  * @access private
  */
function LzReplicationManager ( odp , args, children:* = null, instcall:* = null ){
    //the real parent for this is datapaths view's (immediateparent) parent
    super(odp, args, children, instcall);
}

/** @access private */
override function construct ( odp , args ){
    this.__LZtakeDPSlot = false; // Defined in LzDatapath
    this.datacontrolsvisibility = false; // Defined in LzDatapath

    if (this.pooling == null)
        this.pooling = false; // Defined in LzDatapath

    //odp: original datapath
    var view:LzNode = odp.immediateparent;
    if (view === canvas) {
        // Initialize vars to reduce dhtml errors
        this.nodes = [];
        this.clones = [];
        this.clonePool = [];
        if ($debug) {
            Debug.error("LzReplicationManager constructed at canvas. A datapath cannot be defined on the canvas");
        }
        return;
    }

    //this is so that when it looks like you're refering to the view in source
    //you can say view.datapath and you'll get what you want (which is this)
    this.datapath = this;

    // replace the view with us,
    // fixing up any name or id
    var name:String =  view.name;
    if (name != null) {
      args.name = name;
      // remove view we replace to avoid warning in LzNode.$lzc$set_name
      view.immediateparent[name] = null;
      view.parent[name] = null;
    }
    // ditto with global binders
    var idbinder:Function =  view.$lzc$bind_id;
    if (idbinder != null) {
      // remove view binding
      idbinder.call(null, view, false);
      view.$lzc$bind_id = null;
      this.$lzc$bind_id = idbinder;
      idbinder.call(null, this);
    }
    var namebinder:Function =  view.$lzc$bind_name;
    if (namebinder != null) {
      // remove view binding
      namebinder.call(null, view, false);
      view.$lzc$bind_name = null;
      this.$lzc$bind_name = namebinder;
      namebinder.call(null, this);
    }

    //don't want to rerunxpath
    args.xpath = LzNode._ignoreAttribute;

    //copy sortpath and sortorder from odp, if they were set
    if ( odp.sortpath != null ){
        args.sortpath = odp.sortpath;
    }

    if ( odp.sortorder != null || odp.sortorder ){
        args.sortorder = odp.sortorder;
    }

    //store nodes for constructWithArgs
    this.initialnodes = odp.storednodes;
    if ( odp.__LZspecialDotDot ){
        this.__LZspecialDotDot = true;
        if ( odp.__LZdotdotCheckDel ){
            odp.__LZdotdotCheckDel.unregisterAll();
        }
        odp.__LZspecialDotDot = null;
    }
        

    //the real parent for this is datapaths view's (immediateparent) parent
    super.construct( view.parent, args);

    if ( view.parent != view.immediateparent ){
        view.immediateparent[ args.name ] = this;
    }

    //already have nodes when inited
    this.xpath = odp.xpath;
    this.parsedPath = odp.parsedPath;

    this.cloneClass = view.constructor;

    this.cloneParent = view.parent;

    //add clone transformer to original instance attributes
    this.cloneAttrs = new LzInheritedHash(view._instanceAttrs);

    this.cloneAttrs.datapath = LzNode._ignoreAttribute;
    this.cloneAttrs.$datapath = { name  : 'datapath' };
    this.cloneAttrs.$datapath.attrs = { datacontrolsvisibility: odp.datacontrolsvisibility, 
                                        __LZmanager : this }

    this.cloneAttrs.id = null;
    this.cloneAttrs.name = null;
    this.cloneAttrs.$lzc$bind_id = null;
    this.cloneAttrs.$lzc$bind_name = null;
    if ($profile) {
      if (view._profile_name) {
        this.cloneAttrs._profile_name = 'clone of ' + view._profile_name;
      }
    }

    var hadxpathconstraint:Boolean = false;
    var ia:Object = view._instanceAttrs;
    var oa:Object = odp._instanceAttrs;
    if (ia && 'datapath' in ia && ia.datapath is LzConstraintExpr) {
        // <view datapath="${ ... }"/>
        hadxpathconstraint = true;
        // we need to mask this constraint
        // NOTE: [2008-02-07 ptw] Why?  Why can't this just execute as
        // a constraint on the clone via the normal mechanism?
        // but, we want the constraint to apply to this object instead
        this.__LZpreventXPathUpdate = true;
        var methodName:String = ia.datapath.methodName;
        if ($swf9) {
            //FIXME: cannot copy a method in swf9, because 'this' is bound!
            this[methodName] = function (ignore) {};
        } else {
            this[methodName] = view[methodName];
        }
        if (ia.datapath is LzAlwaysExpr) {
            var dependencyName:String = ia.datapath.dependenciesName;
            if ($swf9) {
                //FIXME: cannot copy a method in swf9, because 'this' is bound!
                this[dependencyName] = function () {return [];};
            } else {
                this[dependencyName] = view[dependencyName];
            }
        }
        // NOTE: [2008-02-07 ptw] The method had better be available
        // on the clone (which means we really want a clone class here
        // to instantiate, rather than an instance to clone).
        this.applyConstraintExpr(ia.datapath);
        this.__LZpreventXPathUpdate = false;
    } else if (oa && 'xpath' in oa && oa.xpath is LzConstraintExpr){
        //<view><datapath xpath="${ ... }"/>
        hadxpathconstraint = true;
        //we want the constraint to apply to this object instead
        this.__LZpreventXPathUpdate = true;
        // we need to have an intermediate node, so relative constraints 
        // like "xpath='${this.immediateparent.parent.anyproperty}'" 
        // work for a replication-manager 
        var refObj:LzRefNode = new LzRefNode(this);
        var methodName:String = oa.xpath.methodName;
        if ($swf9) {
            //FIXME: cannot copy a method in swf9, because 'this' is bound!
            refObj[methodName] = function (ignore) {};
        } else {
            refObj[methodName] = odp[methodName];
        }
        if (oa.xpath is LzAlwaysExpr) {
            var dependencyName:String = oa.xpath.dependenciesName;
            if ($swf9) {
                //FIXME: cannot copy a method in swf9, because 'this' is bound!
                refObj[dependencyName] = function () {return [];};
            } else {
                refObj[dependencyName] = odp[dependencyName];
            }
        }
        // NOTE: [2008-02-07 ptw] The method had better be available
        // on the clone (which means the compiler really has to move
        // it from the datapath subnode to the clone class).
        refObj.applyConstraintExpr(oa.xpath);
        this.__LZpreventXPathUpdate = false;
    }

    this.__LZsetCloneAttrs();


    if ( view._instanceChildren ){
        this.cloneChildren = view._instanceChildren.concat();
    } else {
        this.cloneChildren = [];
    }

    this.visible = odp.datacontrolsvisibility ||
        (!view.isinited &&
            (view._instanceAttrs != null && 'visible' in view._instanceAttrs) ? view._instanceAttrs.visible : view.visible);

    if ( args.pooling != null ){
        this.pooling = args.pooling;
    }
    
    var mycontext:* = odp.context;

    //clone pool is used to store available views   
    this.clones = [];
    this.clonePool = [ ];

    if ( this.pooling ){
        odp.$lzc$set___LZmanager( this );
        //make sure that the original view and datapath don't get their xpath 
        //set by a constraint..
        if ( hadxpathconstraint ){
            //FIXME: breaks in swf9!
            odp.setXPath =  LzReplicationManager.__LZemptyFuntion;
        }
        this.clones.push ( view );
        // Because we're about to start making siblings to this view, (i.e. out
        // of lexical order) make sure that the replicated view has been added
        // to the parent's subview list. Also, it's ok to call this if view was
        // already added
        view.immediateparent.addSubview ( view );
    } else {
        this.destroyClone( view );
    }

    this.setDataContext( mycontext , mycontext instanceof LzDatapointer);
}

/**
  * @access private
  */
// See subclasses for definition
function __LZsetCloneAttrs () :void {}

/**
  * @access private
  */
static function __LZemptyFuntion ( ){
    return;
}

/**
  * @access private
  */
override function constructWithArgs ( args ){
    this.__LZHandleMultiNodes( this.initialnodes );
    this.initialnodes = null;
    if ( this.visible == false ){
        this.setVisible( false );
    }
}

/**
  * @access private
  */
override function setDataContext (p, implicit:Boolean = false) :void {
    if (p == null && this.immediateparent != null && this.immediateparent['datapath'] != null){
        p = this.immediateparent.datapath;
        implicit = true;
    }
    super.setDataContext(p, implicit);
}

/**
  * TODO: [20080428 anba] no reference to this function in the LFC, remove it?
  * 
  * @access private
  */
function getNodeOffset ( p ) :Number? {
    var nds:Array = this.nodes;
    if (nds != null) {
        var len:int = nds.length; 
        for ( var i:int = 0; i < len; i++ ){
            if ( p == nds[ i ] ){
                return i;
            }
        }
    }
}
    
/**
  * Retuns a pointer to the nth clone controlled by the replication manager
  * @param Number n: The zero-based offset of the clone to retrieve
  * @return LzView: A pointer to the nth clone
  */
function getCloneNumber ( n:int ) :LzNode {
    return this.clones[ n ];
}

/**
  * @access private
  */
override function __LZHandleNoNodes() :void {
    this.nodes = [];
    var cls:Array = this.clones;
    while ( cls.length ){
        if ( this.pooling ){
            this.poolClone();
        } else {
            var v:LzNode = cls.pop();
            this.destroyClone( v );
        }
    }
}

/**
  * @access private
  */
override function __LZHandleSingleNode ( n/*:LzDataNodeMixin*/ ) :void { 
    this.__LZHandleMultiNodes( [n] );
}

/**
  * @access private
  */
function mergesort ( arr:Array, lo:int, hi:int ) :Array {
    if ( lo < hi ) {
        var mid:int = lo + Math.floor ( (hi - lo) / 2 );
        var a:Array = this.mergesort( arr, lo, mid );
        var b:Array = this.mergesort( arr, mid + 1, hi );
    } else if( arr.length == 0 ) {
        return [];
    } else {
        return [ arr[ lo ] ];
    }

    //now merge
    var r:Array = [];
    var ia:int = 0;
    var ib:int = 0;
    var al:int = a.length;
    var bl:int = b.length;
    while ( ia < al && ib < bl ){
        if ( this.orderf( b[ ib ] , a[ ia ] ) == 1 ){
            r.push( b[ ib++ ] );
        } else {
            r.push( a[ ia++ ] );
        }
    }
    while ( ia < al ) r.push( a[ ia++ ] );
    while ( ib < bl ) r.push( b[ ib++ ] );

    return r;
}

/**
  * @access private
  */
override function __LZHandleMultiNodes ( n:Array ) :LzReplicationManager {
    var layouts:Array = this.parent && this.parent.layouts ? this.parent.layouts : [];
    for (var i:int = 0; i < layouts.length; ++i) {
        layouts[i].lock();
    }
    this.hasdata = true;
    var lastnodes:Array = this.nodes;
    this.nodes = n;
    if (this.onnodes.ready) this.onnodes.sendEvent( this.nodes );

    if ( this.__LZspecialDotDot ) this.__LZsetupDotDot( n[ 0 ] );

    if ( this.orderpath != null ){
        this.nodes = this.mergesort( this.nodes , 0 , this.nodes.length - 1 );
    }

    this.__LZadjustVisibleClones( lastnodes , true );

    var len:int = this.clones.length;
    for (var i:int = 0; i < len; i++ ){
        var cl:LzNode = this.clones[ i ];
        var iplusoffset:int = i + this.__LZdataoffset; 
        cl.clonenumber = iplusoffset;

        if (this.nodes) {
            cl.datapath.setClonePointer( this.nodes[ iplusoffset ] );
        }
        if (cl.onclonenumber.ready) cl.onclonenumber.sendEvent( iplusoffset );
    }
    if (this.onclones.ready) this.onclones.sendEvent( this.clones );
    
    for (var i:int = 0; i < layouts.length; ++i) {
        layouts[i].unlock();
    }
    
    return void(0);
}

/**
  * @access private
  */
function __LZadjustVisibleClones( lastnodes:Array , newnodes:Boolean) :void {
    var stpt:int = this.__LZdiffArrays( lastnodes , this.nodes);

    if ( ! this.pooling ) {
        while ( this.clones.length > stpt ){
            var v:LzNode = this.clones.pop();
            this.destroyClone( v );
        }
    }

    //this makes sure that children created as a result of data replication
    //init in order
    LzInstantiator.enableDataReplicationQueuing( );

    while ( this.nodes && this.nodes.length > this.clones.length ){
        var cl:LzNode = this.getNewClone();
        if (!cl)
            break;
        this.clones.push( cl );
    }

    LzInstantiator.clearDataReplicationQueue( );


    while ( this.nodes && this.nodes.length < this.clones.length ){
        //this condition can only be reached if pooling is turned on
        this.poolClone();
    }
}

/**
  * @access private
  */
//PBR TODO
function orderf ( a , b ){
    //a and b are dataset nodes


    var op = this.op_orderf;

    this.p = a;
    var aa = this.xpathQuery( op );
    this.p = b;
    var bb = this.xpathQuery( op );
    this.p = null;

    //this is lame, but comparison with null and "" doens't work right
    //so use newline
    if ( aa == null || aa == "" ) aa ="\n";
    if ( bb == null || bb == "" ) bb ="\n";

    return this.comp_orderf( aa , bb )
}


/**
  * @access private
  */
function ascDict ( a:String, b:String ) :int {
    if (a.toLowerCase() < b.toLowerCase()) {
        return 1;
    } else {
        return 0;
    }
}

/**
  * @access private
  */
function descDict ( a:String, b:String ) :int {
    if (a.toLowerCase() > b.toLowerCase()) {
        return 1;
    } else {
        return 0;
    }
}


/**
  * Orders the replicated nodes based on the value of the path passed in.
  * @access private
  * 
  * @param String xpath: An xpath giving the value to use for comparison.
  * @param Function|String comparator: See the <code>comparator</code> paramater
  * of <code>setComparator</code> for details.
  */
override function setOrder( xpath:String, comparator:* = null ) :void {
    this.orderpath = null;

    if ( comparator != null ){
        this.setComparator( comparator );
    }

    this.orderpath = xpath;

    this.op_orderf = this.orderpath;

    if ( this.nodes.length ){
        //reset nodes in order now
        this.__LZHandleMultiNodes( this.nodes );
    }
}

/**
  * Sets the comparator for the sort used by the replication manager.
  * @access private
  *
  * @param Function|String comparator: "ascending" or "descending" for the
  * appropriate dictionary sort, or a function to be used for comparison that
  * takes two arguments and returns 1 if the second argument should follow the
  * first, -1 if the first argument should follow the second, and 0 if the two
  * arguments are equivalent
  */
override function setComparator( comparator:* ) :void {
  if ( comparator == "descending" ){
    comparator = this.descDict;
  } else if ( comparator == "ascending" ){
    comparator = this.ascDict;
  } else if ( comparator is Function ) {
    // Just use it
  } else if ($debug) {
    Debug.error("Invalid comparator: %s", comparator);
  }

  this.comp_orderf = comparator;
  if ( this.orderpath != null && this.nodes.length ){
    //reset nodes in order now
    this.__LZHandleMultiNodes( this.nodes );
  }
}

/**
  * @access private
  */
function getNewClone ( forceNew = null ) :LzNode {
    if (!this.cloneParent) {
        return null;
    }
    if ( this.clonePool.length ){
        var v:LzNode = this.reattachClone( this.clonePool.pop() );
    } else {
        var v:LzNode = new this.cloneClass( this.cloneParent , this.cloneAttrs ,
                                     this.cloneChildren, 
                                     forceNew == null ? this.asyncnew : !forceNew);
    }
    if ( this.visible == false ) v.$lzc$set_visible( false );
    return v;
}

/**
  * @access private
  */
function poolClone ( ) :void {
    var v:LzNode = this.clones.pop();
    this.detachClone( v );
    this.clonePool.push ( v );
}

/**
  * TODO: [20080428 anba] do we still need this overhead?
  * 
  * @access private
  */
function destroyClone (v:LzNode) :void {
    v.destroy();
}

/**
  * This is an alias for the replication manager's setXPath method, but it is
  * provided for compatibility with the view API, since replication managers take
  * over the slot that a named replicated view occupied in the parent. (See
  * comment on the class as a whole, above.)
  * @param String xp: An xpath.
  * @access private
  */
override function setDatapath ( xp ){
    this.setXPath( xp );
}

/**
  * @access private
  */
override function setXPath ( xp:String ) :Boolean? {
    if ( this.__LZpreventXPathUpdate ) return;
    super.setXPath.apply(this, arguments); 
}

/**
  * TODO: [20080428 anba] no reference to this function in the LFC, remove it?
  * 
  * @access private
  */
function handleDeletedNode ( c:int ) :void {
    var tclone:LzNode = this.clones[ c ];
    if ( this.pooling ){
        this.detachClone( tclone );
        this.clonePool.push ( tclone );
    } else {
        this.destroyClone( tclone );
    }
    this.nodes.splice( c , 1 );
    this.clones.splice( c , 1 );
}

/**
  * Returns a clone which is mapped to the given data node.
  * @param LzDataElement p: The data node for which to return the clone.
  * @return LzView: A clone mapped to the given data.
  */
function getCloneForNode ( p, dontmake:Boolean = false ){
    var cls:Array = this.clones;
    var len:int = cls.length; 
    for ( var i:int = 0; i < len; i++ ){
        if ( cls[ i ].datapath.p == p ){
            return cls[ i ];
        }
    }
}
 
/**
  * @access private
  */
override function toString () :String {
    return "ReplicationManager in " + this.immediateparent;
}

/**
  * Sets the visibility of all the clones controlled by the replication manager
  * @param Boolean vis: The value to set the visibility to.
  * @access private
  * @devnote TODO: [2008-05-07 ptw] This should probably just be a
  * setter rather than being handled specially by construcWithArgs,
  * but I didn't want to mess with that now.  In any case, there is no
  * reason for this to be a public method.
  */
function setVisible ( vis:Boolean ) :void {
    this.visible = vis;
    var cls:Array = this.clones;
    var len:int = cls.length; 
    for ( var i:int = 0; i < len; i++ ){
        cls[ i ].$lzc$set_visible( vis );
    }
    if (this.onvisible.ready) this.onvisible.sendEvent( vis );
}

/**
  * @access private
  */
override function __LZcheckChange (chgpkg:Object) :Boolean {
    this.p = this.nodes[ 0 ];
    var didrun:Boolean = super.__LZcheckChange.apply(this, arguments);
    this.p = null;

    if ( !didrun ){
        var who = chgpkg.who;
        var cls:Array = this.clones;
        var len:int = cls.length; 
        for ( var i:int = 0; i < len; i++ ){
            var cl:LzNode = cls[ i ];
            var dp:LzDatapath = cl.datapath;
            if ( dp.__LZneedsOpUpdate( chgpkg ) ){
                dp.__LZsetData();
            }
            if ( who.childOfNode( dp.p , true ) ){
                if (dp.onDocumentChange.ready) dp.onDocumentChange.sendEvent( chgpkg ) ;
            }
        }
    }
    
    return false;
}


/** @access private */
override function __LZneedsOpUpdate (chgpkg:Object? = null) :Boolean {
    return false;
}

/**
  * @access private
  */
override function getContext ( chgpkg = null ) :* {
    return this.nodes[ 0 ];
}

/**
  * @access private
  */
function detachClone ( cl:LzNode ){
    //cl is instance of LzView
    if ( cl.isdetatchedclone ) return;

    cl.$lzc$set_visible(false);
    cl.addedToParent = false;

    var svs:Array =  cl.immediateparent.subviews;
    for( var i:int = svs.length - 1; i >= 0; i-- ){
        if ( svs[ i ] == cl ){
            svs.splice( i , 1 );
            break;
        }
    }

    cl.datapath.__LZtrackDel.unregisterAll();
    if (cl.immediateparent.onremovesubview.ready) cl.immediateparent.onremovesubview.sendEvent( cl );
    cl.isdetatchedclone = true;
    cl.p = null;
}

/**
  * @access private
  */
function reattachClone ( cl:LzView ) :LzView {
    if ( !cl.isdetatchedclone ) return cl;

    cl.immediateparent.addSubview( cl );
    cl.$lzc$set_visible( this.visible );
    cl.isdetatchedclone = false;
    return cl;
}

/**
  * returns the index at which the arrays differ
  * @access private
  */
function __LZdiffArrays ( a:Array, b:Array ) :int {
    var i:int = 0;

    var al:int = a ? a.length : 0;
    var bl:int = b ? b.length : 0;

    while( i < al && i < bl ){
        if ( a[ i ] != b[ i ] ){
            return i;
        }
        i++;
    }

    return i;

}

/**
  * @access private
  */
override function updateData () {
    this.__LZupdateData();
}

/**
  * @access private
  */
override function __LZupdateData (recursive:Boolean = false) :void {
    var cls:Array = this.clones;
    var len:int = cls.length; 
    for (var i:int = 0; i < len; i++) {
        cls[ i ].datapath.updateData();
    }
}

} // End of LzReplicationManager

/** @access private */
dynamic class LzRefNode extends LzNode {
    /**
      * @access private
      */
    function LzRefNode (parent:LzNode, attrs:Object? = null, children:Array? = null, instcall:Boolean = false) {
        super(parent, attrs, children, instcall);
    }
    
    /**
      * @access private
      */
    function $lzc$set_xpath (v) :void {
        // this.parent is the LzReplicationManager!
        this.parent.$lzc$set_xpath(v);
    }
}
