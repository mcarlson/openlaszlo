/**
  *
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access private
  * @topic LFC
  * @subtopic Data
  */

/**
  * <p>The <tagname>connection</tagname> tag instantiates a connection
  * manager object that handles asynchronous messages sent from the OpenLaszlo
  * Server. Use the the <method>LzConnection.connect</method> method to establish a
  * persistent connection and <method>disconnect</method> to close it down.</p>
  * 
  * <example title="Connection example" >
  * &lt;canvas debug="true" height="200"&gt;
  *   &lt;debug y="60"/&gt;
  *   &lt;connection authenticator="anonymous"&gt;
  *     &lt;handler name="onconnect"&gt;
  *       Debug.write('connected');
  *     &lt;/handler&gt;
  * 
  *     &lt;handler name="ondisconnect"&gt;
  *       Debug.write('client disconnected');
  *     &lt;/handler&gt;
  *   &lt;/connection&gt;
  * 
  *   &lt;view&gt;
  *     &lt;simplelayout axis="x" spacing="5"/&gt;
  * 
  *     &lt;button&gt;connect
  *       &lt;handler name="onclick"&gt;
  *         canvas.connection.connect();
  *       &lt;/handler&gt;
  *     &lt;/button&gt;
  *     &lt;button&gt;disconnect
  *       &lt;handler name="onclick"&gt;
  * 
  *         canvas.connection.disconnect();
  *       &lt;/handler&gt;
  *     &lt;/button&gt;
  *   &lt;/view&gt;
  * &lt;/canvas&gt;
  * </example>
  * 
  * <p>You can optionally use the <method>clientDisconnect</method> method to close
  * down only the client-side connection. The server will drop its end of the
  * connection when it next becomes aware that the connection has been dropped.</p>
  * 
  * <p>The previous example declares <tagname>connection</tagname> with
  * <code>authenticator="anonymous"</code>, which tells the connection
  * manager that no authentication should be used to handle the persistent
  * connection. Normally, the connection manager will tell the OpenLaszlo Server to
  * verify that your connection is authenticated with a back-end
  * authentication server before allowing the persistent connection, which
  * is done through a session cookie. The default authentication server it
  * uses is the <code>AuthenticationServlet</code> bundled with the OpenLaszlo Server. The set of usernames that server uses is located in
  * <code>lps/config/lzusers.xml</code>. To session and unsession your
  * application, use the connection's <method>login</method> and
  * <method>logout</method> methods.</p>
  * 
  * <p>The next example demonstrates how to login with the username
  * <code>adam</code>. Note that you will be allowed to connect only after
  * logging in.</p>
  * 
  * <example title="Session Example">
  * &lt;canvas debug="true" height="200"&gt;
  *   &lt;debug y="60"/&gt;
  * 
  *   &lt;connection&gt;
  *     &lt;handler name="onconnect"&gt;
  * 
  *       Debug.write('connected as ' + connection.getUsername()); 
  *     &lt;/handler&gt;
  *     &lt;handler name="ondisconnect"&gt;
  *       Debug.write('client disconnected');
  *     &lt;/handler&gt;
  *   &lt;/connection&gt;
  * 
  *   &lt;datapointer xpath="connection:loginDset:/login[1]/authentication[1]/response[1]/status[1]"&gt;
  * 
  *     &lt;handler name="ondata"&gt;
  *       var statusMessage = this.xpathQuery('@msg');
  *       Debug.write('login: ' + statusMessage);
  *     &lt;/handler&gt;
  *     &lt;handler name="onerror"&gt;
  *       Debug.write('login resulted in error');
  *     &lt;/handler&gt;
  *     &lt;handler name="ontimeout"&gt;
  * 
  *       Debug.write('login timed out');
  *     &lt;/handler&gt;
  *   &lt;/datapointer&gt;
  * 
  *   &lt;datapointer xpath="connection:logoutDset:/logout[1]/authentication[1]/response[1]/status[1]"&gt;
  *     &lt;handler name="ondata"&gt;
  *       var statusMessage = this.xpathQuery('@msg');
  *       Debug.write('logout: ' + statusMessage);
  *     &lt;/handler&gt;
  * 
  *     &lt;handler name="onerror"&gt;
  *       Debug.write('logout resulted in error');
  *     &lt;/handler&gt;
  *     &lt;handler name="ontimeout"&gt;
  *       Debug.write('logout timed out');
  *     &lt;/handler&gt;
  *   &lt;/datapointer&gt;
  * 
  *   &lt;view&gt;
  *     &lt;simplelayout axis="x" spacing="5"/&gt;
  *     &lt;button&gt;login
  *       &lt;handler name="onclick"&gt;
  *         canvas.connection.login('adam', 'adam');
  *       &lt;/handler&gt;
  *     &lt;/button&gt;
  * 
  *     &lt;button&gt;logout
  *       &lt;handler name="onclick"&gt;
  *         canvas.connection.logout();
  *       &lt;/handler&gt;
  *     &lt;/button&gt;
  *     &lt;simplelayout axis="x" spacing="5"/&gt;
  *     &lt;button&gt;connect
  *       &lt;handler name="onclick"&gt;
  * 
  *         canvas.connection.connect();
  *       &lt;/handler&gt;
  *     &lt;/button&gt;
  *     &lt;button&gt;disconnect
  *       &lt;handler name="onclick"&gt;
  *           canvas.connection.disconnect();
  *       &lt;/handler&gt;
  *     &lt;/button&gt;
  * 
  *   &lt;/view&gt;
  * &lt;/canvas&gt;
  * </example>
  * 
  * <p>Once a connection is established, clients can send and receive messages
  * using the <tagname>connectiondatasource</tagname> tag.</p>
  * 
  * <h2>Sample Apps</h2>
  * <p>Sample applications that use the <tagname>connection</tagname> tag are:</p>
  * 
  * <ul>
  *     <li> <a href="${demos}chat/chat.lzx">Chat</a></li>
  * </ul>
  * 
  * <seealso>
  * <tags>connectiondatasource</tags>
  * <dguide id="persistent_connection" title="Persistent Connection">for
  * more information on authentication, asynchronous XML messages, and
  * other persistent connection-related matters</dguide>
  * </seealso>
  * 
  * @shortdesc A connection manager to create a persistent connection and an
  *            authenticated session.
  * @devnote LzConnection multiplexes all incoming data from a persistent connection into
  * a connection datasource's dataset (see LzConnectionDatasource).
  *
  * @lzxname connection
  *
  * @initarg group
  * @initarg public Number heartbeat: min is 1000ms
  * @initarg public Number timeout: min is 1000ms
  * @initarg authenticator
  * @initarg authparam
  * @initarg secure
  * @initarg secureport
  */

class LzConnection extends LzHTTPDatasource {

/** @access private
  * @modifiers override 
  */
static var tagname = 'connection';
/** @access private */
  static var attributes = new LzInheritedHash(LzHTTPDatasource.attributes);

/**
  * LzAgent is a placeholder to silence warnings about undefined
  * classes -- the tag is permitted in a connection but only used
  * on the server side
  * @access private
  */
var LzAgent = function () {};

/**
  * @access private
  */
function $lzc$set_authparam(v) { this.setAuthParam(v); }


/**
  * @access private
  */
function construct (parent, args)
{
    // public attributes
    this.name = "connection";
    this.type = "connection";
    args.name = this.name;
    args.type = this.type;

    super.construct.apply(this, arguments);

    if (args.group) {
        this.group = args.group;
    }

    if (typeof(args.heartbeat) == 'undefined' || args.heartbeat < 1000) {
        this.heartbeat = 5000;
    } else {
        this.heartbeat = args.heartbeat;
    }

    if (typeof(args.timeout) == 'undefined' || 
        args.timeout < 1000 || 
        args.timeout < args.heartbeat) {
        this.timeout = this.heartbeat * 4;
    } else {
        this.timeout = args.timeout;
    }

    // java authenticator class and its parameters (public)
    this.authenticator = args.authenticator;
    if (typeof(args.authparam) == 'undefined') {
        this.setAuthParam('');
    } else {
        this.setAuthParam(args.authparam);
    }

    // private attributes

    // We don't want to display the waitcursor for persistent connections
    // (private - from LzDataSource)
    this.waitcursor = false;

    // connected flag (private)
    this.__LZisConnected = false;

    // secure flag
    var url = new LzURL(LzBrowser.getLoadURL());
    if (url.protocol == "https") {
        this.__LZisSecure = true;
        this.__LZsecurePort = url.port;
    } else {
        this.__LZisSecure = args.secure;
        this.__LZsecurePort = args.secureport;
    }

    // loader (private)
    this.__LZloader = this.getNewLoader(true);
    this.__LZloader.doCacheRequest = false;
    this.__LZloader.doPersist = true;
    this.__LZloader.timeout = null;
    if (this.__LZisSecure) {
        this.__LZloader.secure = this.__LZisSecure;
        this.__LZloader.secureport = this.__LZsecurePort;
    }
    new LzDelegate(this, "__LZgotData", this.__LZloader, "ondata");
    new LzDelegate(this, "__LZgotError", this.__LZloader, "onerror");

    // timeout delegate (private)
    this.__LZtimeoutDel = new LzDelegate(this , "__LZgotTimeout");

    // connection datasources attach their datasets here
    this.__LZdatasources = {};

    // username, session id and connection id 
    this.__LZusr = null;
    this.__LZsid = null;
    this.__LZcid = null;

    // disconnect and session datasets
    this.disconnectDset = new LzDataset(this, {name: "disconnectDset", 
                                                     secure: this.__LZisSecure, 
                                                     secureport: this.__LZsecurePort } );

    this.loginDset = new LzDataset(this, { name: "loginDset", 
                                                 secure: this.__LZisSecure, 
                                                 secureport: this.__LZsecurePort } );

    this.logoutDset = new LzDataset(this, { name: "logoutDset", 
                                                 secure: this.__LZisSecure, 
                                                 secureport: this.__LZsecurePort } );

    this.loginDset.getresponseheaders = true;
    this.logoutDset.getresponseheaders = true;

    // Anonymous connection datasource name counter 
    this.__LZdsrcNameCounter = 0; 
}


/**
  * @access private
  */
function init ()
{
    this.__LZisdebug = (typeof(Debug) != "undefined");

}

/**
  * @access private
  */
function __LZregisterDatasource (dsrc)
{
    var name = dsrc.name
    if (name == null) {
        name = '__LZconndsrc' + (this.__LZdsrcNameCounter++);
    }

    if ( this.__LZdatasources[name] == null ) {
        this.__LZdatasources[name] = dsrc;
    } else {
        Debug.warn("connection datasource '%'s already defined", name);
    }
}


/**
  * @access private
  */
function __LZconnect (type)
{
    this.__LZloader.unload();     // make sure we unload previous connection.
    this.__LZloader.request( { lzt: "connect" , type: type, i: this.__LZcid, 
                               url: LzBrowser.getBaseURL(this.__LZisSecure,
                                                         this.__LZsecurePort),
                               authparam: escape(this.authparam), 
                               debug: this.__LZisdebug, proxied: true } );
    LzTimer.resetTimer(this.__LZtimeoutDel, this.timeout);
}

/**
  * @access private
  */
function __LZunloadConnection ()
{
    if ( ! this.__LZunloadConnectionDel ) {
        this.__LZunloadConnectionDel = new LzDelegate(this, "__LZunloadConnection1");
    }
    LzIdle.callOnIdle( this.__LZunloadConnectionDel );

}

/**
  * @access private
  */
function __LZunloadConnection1 ()
{
    this.__LZloader.unload();
    if (this.__LZoninternaldisconnect.ready) this.__LZoninternaldisconnect.sendEvent(); 
}


/**
  * @access private
  */
function __LZreconnect ()
{
    this.__LZunloadConnection();
    if ( ! this.__LZreconnectDel ) {
        this.__LZreconnectDel = new LzDelegate(this, "__LZreconnect1") 
    }
    this.__LZreconnectDel.register(this, "__LZoninternaldisconnect");
}


/**
  * @access private
  */
function __LZreconnect1 ()
{
    this.__LZreconnectDel.unregisterAll();
    this.__LZconnect("r");
}


/**
  * @access private
  */
function __LZgotTimeout ()
{
    this.clientDisconnect();
    this.__LZsendEvent('ontimeout');
}

/**
  * Return error response.
  * @access private
  */
function __LZgotError(error)
{
    LzTimer.removeTimer(this.__LZtimeoutDel);
    this.__LZsendEvent('onerror', error);
    
    this.__LZisConnected = false;
    this.__LZusr = null;
    this.__LZsid = null;
    this.__LZcid = null;

    // just to be safe
    this.__LZunloadConnection();
}

/**
  * This function makes sure the connection message gets delivered to the
  * right dataset.
  * @access private
  */
function __LZgotData(data)
{
    LzTimer.resetTimer(this.__LZtimeoutDel, this.timeout);

    var name = data.childNodes[0].attributes.dset;

    if (data.childNodes[0].n == "error") {

        this.clientDisconnect();
        this.__LZsendEvent('onerror', data );

    } else if (name=="__LPSDORECONNECT") {

        this.__LZreconnect();

    } else if (name=="__LPSHB") {

        // don't report heartbeat
        // this.onheartbeat.sendEvent( this );

    } else if (name=="__LPSRECONNECTED") {

        this.__LZcid = data.childNodes[0].childNodes[0].childNodes[0].data;

    } else if (name=="__LPSCONNECTED") {

        this.__LZcid = data.childNodes[0].childNodes[0].childNodes[0].data;
        this.__LZsid = data.childNodes[0].childNodes[1].childNodes[0].data;
        this.__LZusr = data.childNodes[0].childNodes[2].childNodes[0].data;

        this.__LZisConnected = true;
        this.__LZsendEvent('onconnect');

        LzTimer.resetTimer(this.__LZtimeoutDel, this.timeout);

    } else if (name=="__LPSUSERDISCONNECT") {

        this.__LZsendEvent('onuserdisconnect', 
                           data.childNodes[0].childNodes[0].data );

    } else {

        var rdata = data.childNodes[0].childNodes;
        for (var d in this.__LZdatasources) {
            var dsrc = this.__LZdatasources[d];
            if (dsrc[name] != null) {
                // pass down just <root>
                dsrc[name].setData(rdata);
                if (dsrc.ondata.ready) dsrc.ondata.sendEvent(rdata);
            }
        }
        if (this.ondata.ready) this.ondata.sendEvent( rdata );

    }
}


/**
  * @access private
  */
function __LZsendEvent (event, obj)
{
    if (this[event].ready) this[event].sendEvent( obj );
    for (var d in this.__LZdatasources) {
        var dsrc = this.__LZdatasources[d];
        //Debug.write('sending event', event, 'to ', dsrc, 'with value ',  obj);
        if (dsrc[event].ready) dsrc[event].sendEvent( obj );
    }
}


/**
  * @access private
  */
function toString()
{
    return "LzConnection '" + this.name + "'";
}


/**
  * Close down the connection.
  * @access private
  */
function __LZdisconnect()
{
    LzTimer.removeTimer(this.__LZtimeoutDel);
    
    this.__LZunloadConnection();
    this.__LZisConnected = false;

    this.__LZusr = null;
    this.__LZsid = null;
    this.__LZcid = null;

    this.__LZsendEvent('ondisconnect');
}


function getLoaderForDataset ( forset, proxied ) {
    var tloader = forset.getOption( "dsloader" );

    if (typeof(forset.timeout) != "undefined" && forset.timeout != null) {
        tloader.timeout = forset.timeout;
    }

    // If there is no loader, or if the loader changed it's proxied
    // flag, make a new loader.
    if ( !tloader){
        tloader = this.getNewLoader(proxied);
        tloader.queuing = forset.queuerequests;
        forset.setOption( 'dsloader' , tloader );
        forset.setOption( 'dsloadDel' , 
                          new _root.LzDelegate( forset , "gotRawData" ,
                                                tloader , "ondata" ) );
        forset.setOption( 'dserrorDel' , 
                          new _root.LzDelegate( forset , "gotError" ,
                                                tloader , "onerror" ) );
        forset.setOption( 'dstimeoutDel' , 
                          new _root.LzDelegate( forset , "gotTimeout" ,
                                                tloader , "ontimeout" ) );
    }
    
    var secure = forset.secure;
    if (secure == null) {
        if (this.src.substring(0, 5) == "https") {
            secure = true;
        }
    }

    if (secure) {
        tloader.baserequest = _root.LzBrowser.getBaseURL( secure, forset.secureport );
        //_root.Debug.write('basereq ' + tloader.baserequest);
    }

    tloader.secure = secure;
    if (secure) {
        tloader.secureport = forset.secureport;
    }
    
    return tloader;
}

/**
  * Called by datasets
  * @param LzDataset dset: passed by dataset calling parent
  * @access private
  */
function doRequest (dset) 
{
    var params = dset.getParams();
    var reqLoader = this.getLoaderForDataset(dset, true);

    // We don't want to cache requests
    reqLoader.doCacheRequest = false;

    var obj = { proxied: true };
    var keys = params.getNames();
    if (keys != null) {
        for ( var i = 0; i < keys.length; i++ ){
            var name = keys[ i ]; 
            obj[ name ] = params.getValue( name );
        }
    }

    //obj.url = LzBrowser.getBaseURL(forset.secure, forset.secureport );

    reqLoader.request(obj);
}

/**
  * Called by datasets.
  * @access private
  */
function processRawData (dset, data)
{
    //Debug.write("LzConnection.processRawData", dset, data);
    dset.setData(data.childNodes);
}

/**
  * Authenticate and session the application. The results from this call are 
  * returned in the connection's loginDset.
  * @param String usr: login userame
  * @param String pwd: login password
  */
function login (usr, pwd)
{
    var dset = this.loginDset;
    dset.setQueryParams( { lzt: "connectionlogin", usr: escape(usr), 
                           pwd: escape(pwd), debug: this.__LZisdebug, 
                           proxied: true } );
    dset.doRequest();
}


/**
  * De-authenticate and unsession the application. The results from this call are 
  * returned in the connection's logoutDset.
  */
function logout ()
{
    var dset = this.logoutDset;
    dset.setQueryParams( { lzt: "connectionlogout", debug: this.__LZisdebug,
                           proxied: true } );
    dset.doRequest();
}

/**
  * Establish a connection. An application typically must be sessioned before
  * calling this method.
  */
function connect ()
{
    this.__LZconnect("");
}


/**
  * Disconnect connection. This also notifies the server to disconnect the
  * application. The results from asking the server to disconnect are returned in
  * the connection's disconnectDset. See clientDisconnect().
  */
function disconnect ()
{
    LzTimer.removeTimer(this.__LZtimeoutDel);

    var dset = this.disconnectDset;
    dset.setQueryParams({lzt: "disconnect", i: this.__LZcid, 
                         authparam: escape(this.authparam),
                         debug: this.__LZisdebug, proxied: true });
    dset.doRequest();

    this.clientDisconnect();
}

/**
  * Disconnect connection, but don't notify server. See disconnect().
  */
function clientDisconnect ()
{
    this.__LZdisconnect();
}

/**
  * Send a message. The format of the message sent looks like:
  *   <from name="name" />
  * message
  * 
  * The results are returned in the connection's sendMessageDset dataset.
  * 
  * @param String to: name(s), e.g., "victor,sam", or "*" for all users
  * @param String mesg: message to send. This string will be XML escaped.
  * @param String dest: destination connection dataset
  * @param LzDataset result: function resultset 
  * @access private
  */
// TODO: [2003-10-06 pkang] show possible dataset results
function __LZsendMessage (to, mesg, dest, result)
{
    var msg = 
    '<root dset="' + dest + '">' +
    '<from name="' + this.__LZusr + '" sid="' + this.__LZsid + '"/>' +
    LzBrowser.xmlEscape(mesg) +
    '</root>';

    // makes call w/autorequest
    result.setQueryParams( { lzt: "message", to: to, msg: msg, 
                             authparam: escape(this.authparam),
                             debug: this.__LZisdebug, proxied: true } );
    result.doRequest();
}


/**
  * Send arbitrary XML. Result returned in
  * LzConnection.sendXMLDset.
  * 
  * @param String to: name(s), e.g., "victor,sam", or "*" for all users
  * @param String xml: arbitrary XML message
  * @param String dest: destination connection dataset
  * @param LzDataset result: function resultset 
  * @access private
  */
// TODO: [2003-10-06 pkang] show possible dataset results
function __LZsendXML (to, xml, dest, result)
{
    var msg = '<root dset="' + dest + '">' + xml + '</root>'

    // makes call w/autorequest
    result.setQueryParams( { lzt: "message", to: to, msg: msg, 
                             authparam: escape(this.authparam),
                             debug: this.__LZisdebug, proxied: true } );
    result.doRequest();
}

/**
  * Send arbitrary XML to users only (no agents). Result returned in
  * LzConnection.sendXMLDset.
  * 
  * @param String to: user name(s), e.g., "victor,sam", or "*" for all users
  * @param String xml: arbitrary XML message
  * @param String dest: destination connection dataset
  * @param LzDataset result: function resultset 
  * @access private
  */
// TODO: [2003-10-06 pkang] show possible dataset results
function __LZsendUserXML (to, xml, dest, result)
{
    var msg = '<root dset="' + dest + '">' + xml + '</root>'

    // makes call w/autorequest
    result.setQueryParams( { lzt: "message", to: to, msg: msg, 
                             range: "user", authparam: escape(this.authparam),
                             debug: this.__LZisdebug, proxied: true });
    result.doRequest();
}

/**
  * Send arbitrary XML to agents only (no users). Result returned in
  * LzConnection.sendXMLDset.
  * 
  * @param String to: agent name(s), e.g., "victor,sam", or "*" for all users
  * @param String xml: arbitrary XML message
  * @param LzDataset result: function resultset 
  * @access private
  */
// TODO: [2003-10-06 pkang] show possible dataset results
function __LZsendAgentXML (to, xml, result)
{
    var msg = '<root>' + xml + '</root>'

    // makes call w/autorequest
    result.setQueryParams( { lzt: "message", to: to, msg: msg, 
                             range: "agent", authparam: escape(this.authparam), 
                             debug: this.__LZisdebug, proxied: true });
    result.doRequest();
}


/**
  * Verify which users are connected. Result returned in LzConnection.getListDset
  * dataset.
  * 
  * @param String users: name(s), e.g., "victor,sam", or "*" for all users
  * @param LzDataset result: function resultset 
  * @access private
  */
// TODO: [2003-10-06 pkang] show possible dataset results
function __LZgetList (users, result)
{
    result.setQueryParams( { lzt: "list", users: users, 
                             authparam: escape(this.authparam),
                             debug: this.__LZisdebug, proxied: true } );
    result.doRequest();
}


/**
  * Get connection's username.
  * @return String: session username
  */
function getUsername ()
{
    return this.__LZusr;
}

/**
  * Get connection's session id.
  * @return String: session id
  */
function getSID ()
{
    return this.__LZsid;
}

/**
  * Get parameters for authenticator.
  * @return String: authenticator parameters
  */
function getAuthParam ()
{
    return this.authparam;
}

/**
  * Set paramaters for server authenticator.
  * @param String authparam: a query string to pass the authenticator
  */
function setAuthParam (authparam)
{
    this.authparam = authparam;
}


/**
  * This is a helper method to create a loader for the dataset.
  * @access private
  * @return LzLoader 
  */
function getNewLoader (proxied){
    if ( ! $dataloaders ){
        // SWF-specific
        _root.attachMovie("empty", "$dataloaders", 4242);
        var mc = $dataloaders;
        mc.dsnum = 1;
    }

    $dataloaders.attachMovie( "empty", 
                                   "dsloader" + $dataloaders.dsnum,
                                   $dataloaders.dsnum );
    var newloadermc = $dataloaders[ "dsloader" + 
                                          $dataloaders.dsnum ];
    $dataloaders.dsnum++;
    
    //Debug.write("dataset timeout", this.timeout);

    return new LzLoader( this, { attachRef : newloadermc ,
                                       timeout : this.timeout,
                                       proxied: proxied} );
}
    
}; // End of LzConnection
