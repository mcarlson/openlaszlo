/**
  * @copyright Copyright 2001-2008 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @topic LFC
  * @subtopic Data
  */

/**
  * Just enough of LzNode to make setters work for DataElements
  * @access public
  * @topic LZX
  * @subtopic Runtime
  * @todo [2006-08-23 ptw] Fix this modularity.  Is it really too
  * expensive to have this above LzNode?
  * @devnote this is public because public classes inherit from it. Put it
  * in LZX.Runtime to semi-sorta obscure it.
  */

// Inlined contents of LzMiniNode class
class LzMiniNode {
  static function initialize (prototype) {
    if (! prototype.hasOwnProperty('setters')) {
      prototype['setters'] = new LzInheritedHash(prototype['setters']);
    }
  }

  var setAttribute = LzNode.prototype.setAttribute;
}


// *************************
// *                       *
// *  LzMiniNode_DataNode  *
// *                       *
// *************************

// class LzMiniNode_DataNode = LzMiniNode + LzDataNode
class LzMiniNode_DataNode extends LzMiniNode
{
// #include "data/LzDataNode.lzs"
// Manual copy of LzDataNode.lzx
/** @lzxtype event */
var onownerDocument = LzDeclaredEvent;


/** The type of this node -- ELEMENT_NODE or TEXT_NODE
  * @type Number
  * @keywords abstract
  */
var nodeType; // This is undefined. Set elsewhere

/**
  * Returns the sibling before this one this node's parentNodes List of children
  * @return LzDataNode: The node preceeding this one in this node's childNodes
  */
function getPreviousSibling (){
    if (!this.parentNode) return null;
    if ( this.parentNode.__LZcoDirty ) this.parentNode.__LZupdateCO();
    return this.parentNode.childNodes[ this.__LZo - 1 ];
}

/**
 * Returns the parent of this node
 * @return LzDataNode: the parent of this node
 */
function getParent () {
  return this.parentNode;
}

/**
  * gets offset of node in parent's childNodes array
  * @return number
  */
function getOffset (){
    if (!this.parentNode) return 0;
    if (this.parentNode.__LZcoDirty) this.parentNode.__LZupdateCO();

    return this.__LZo;
}

/** @access private */
function $lzc$getPreviousSibling_dependencies( who, self ){
    return [ this.parentNode , "childNodes" , this , "parentNode" ];
}

/**
  * Returns the sibling after this one this node's parentNodes List of children
  * @return LzDataNode: The node succeeding this one in this node's childNodes
  */
function getNextSibling (){
    if (!this.parentNode) return null;
    if ( this.parentNode.__LZcoDirty ) this.parentNode.__LZupdateCO();
    return this.parentNode.childNodes[ this.__LZo + 1 ];
}

/** @access private */
function $lzc$getNextSibling_dependencies( who, self ){
    return [ this.parentNode , "childNodes" , this , "parentNode" ];
}



/**
  * Tells whether the given node is above this one in the node hierarchy.
  * @param LzDataElement el: The LzDataElement to test to see if it is above
  * this one
  * @param Boolean allowself: If true, this function returns true if the given
  * node is the same as this node.
  */
function childOf ( el , allowself ) {
    var p = allowself ? this : this.parentNode
    while ( p ){
        if ( p == el ) return true;
        p = p.parentNode;
    }
    return false;
}

/**
  * Sets the LzDataNode which is the ownerDocument for this node.
  * @param LzDataNode ownerDoc: The LzDataNode to act as the ownerDocument for
  * this node.
  */
function setOwnerDocument ( ownerDoc ){
    this.ownerDocument = ownerDoc;
    if (this.childNodes) {
        for ( var i = 0; i < this.childNodes.length; i++ ){
            this.childNodes[ i ] .setOwnerDocument( ownerDoc );
        }
    }

    if (this.onownerDocument && this.onownerDocument.ready) {
        this.onownerDocument.sendEvent( ownerDoc );
    }
}

/**
  * @access private
  */
function __LZlockFromUpdate ( locker ){
    this.ownerDocument.__LZdoLock( locker );
}

/**
  * @access private
  */
function __LZunlockFromUpdate ( locker ){
    this.ownerDocument.__LZdoUnlock( locker );
}


//End of manual include
}


// *****************************
// *                           *
// *  LzMiniNode_DataNode_DOM  *
// *                           *
// *****************************

// class LzMiniNode_DataNode_DOM = LzMiniNode + LzDataNode + LzDataDOM
class LzMiniNode_DataNode_DOM extends LzMiniNode_DataNode
{
//    #include "data/LzDataDOM.lzs"
// Manual copy of LzDataDOM.lzs
    static function initialize (prototype) {
//       Debug.debug('LzDataElementTraitInitialize')
      // There will be no setters property in the trait prototype,
      // (and you don't want one there! as it would shadow the one
      // from LzNode) but it will be there after LzNode.initialize
      // runs
      if (prototype.hasOwnProperty('setters')) {
        // since you can't assign directly to these slots...
        // until LzNode.initialize has run
        prototype.setters.attributes = "setAttrs";
        prototype.setters.childNodes = "setChildNodes";
        prototype.setters.nodeName = "setNodeName";
        // Shouldn't be directly settable
        prototype.setters.ownerDocument = "setOwnerDocument";
      }
    }

/** @lzxtype event */
var onDocumentChange = LzDeclaredEvent;
/** @lzxtype event */
var onparentNode = LzDeclaredEvent;
/** @lzxtype event */
var onchildNode = LzDeclaredEvent;
/** @lzxtype event */
var onchildNodes = LzDeclaredEvent;
/** @lzxtype event */
var onattributes = LzDeclaredEvent;
/** @lzxtype event */
var onnodeName = LzDeclaredEvent;

/** @access private */
var __LZo = -1;
/** @access private */
var __LZcoDirty = true;
/** @access private */
var __LZchangeQ = null;
/** @access private */
var __LZlocker = null;


/** Inserts the given LzDataNode before another node in this node's childNodes
  * @param LzDataNode newChild: the LzDataNode to insert
  * @param LzDataNode refChild: the LzDataNode to insert newChild before
  * @return LzDataElement: The new child, or null if the refChild wasn't found
  */
function insertBefore (newChild, refChild){
    this.__LZcoDirty = true;

    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[ i ] == refChild ){
            this.childNodes.splice( i , 0 , newChild );
            newChild.setOwnerDocument( this.ownerDocument );

            newChild.parentNode = this;
            if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
            this.ownerDocument.handleDocumentChange( "insertBefore" , 
                                                     this, 0 );
            return newChild;
        }
    }

    //raise exception
    return null;
}


/**
  * Replaces a given LzDataNode in this node's childNodes with a new one.
  * @param LzDataNode newChild: the LzDataNode to add
  * @param LzDataNode oldChild: the LzDataNode to be replaced by the newChild
  * @return LzDataElement: The new child, or null if the oldChild wasn't found
  */
function replaceChild (newChild, oldChild){

    this.__LZcoDirty = true;
    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[ i ] == oldChild ){
            this.childNodes[ i ] = newChild;

            newChild.setOwnerDocument( this.ownerDocument );

            newChild.parentNode = this;
            if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
            this.ownerDocument.handleDocumentChange( "childNodes" , this , 0, newChild );
            return newChild;
        }
    }
    //raise exception
    return null;
}

/**
  * Removes a given node from this node's childNodes
  * @param LzDataNode oldChild: The LzDataNode to remove
  * @return LzDataNode: The removed child, or null if the oldChild was not found
  */
function removeChild (oldChild){
    var reval = null;
    this.__LZcoDirty = true;
    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[ i ] == oldChild ){
            this.childNodes.splice( i , 1 );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( oldChild );
            reval = oldChild;
            this.ownerDocument.handleDocumentChange("removeChild", this, 0, oldChild);
        }
    }
    //raise exception if not found
    return reval;
}

/**
  * Adds a child to this node's list of childNodes
  * @param LzDataNode newChild: The LzDataNode to add.
  * @return LzDataNode: The newChild.
  */
function appendChild (newChild){
    if ( this.childNodes ){
        this.childNodes.push( newChild );
    } else {
        this.childNodes = [ newChild ];
    }

    newChild.setOwnerDocument( this.ownerDocument );

    newChild.parentNode = this;
    if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );

    //instead of marking dirty, this is easy
    newChild.__LZo = this.childNodes.length -1;

    if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
    this.ownerDocument.handleDocumentChange( "appendChild" , this , 0, newChild );
    return newChild;
}

/**
  * Tests whether or not this node has child nodes.
  * @return Boolean: If true, this node has child nodes.
  */
function hasChildNodes (){
    return this.childNodes.length > 0;
}

/**
  * Returns a copy of this node.
  * @param Boolean deep: If true, the children of this node will be part of the
  * new node
  * @return LzDataNode: A copy of this node.
  */
function cloneNode ( deep ){
    var n = new LzDataElement(this.nodeName);
    n.setAttrs( this.attributes );
    if ( deep ){
        for ( var i = 0 ; i < this.childNodes.length; i++ ){
            n.appendChild ( this.childNodes[ i ].cloneNode( true ) );
        }
    }

    return n;
}

/**
  * Returns the value for the give attribute
  * @param String name: The name of the attribute whose value to return
  * @return String: The value for the given attribute
  */
function getAttr (name){
    if (this.attributes) return this.attributes[ name ];
}

/**
  * @access private
  */
prototype.getAttr.dependencies = function (who , self){
    return [ self, 'attributes' ];
}

/**
  * Sets the given attribute to the given value
  * @param String name: The name of the attribute to set.
  * @param String value: The value for the attribute.
  */
function setAttr (name, value){
    if ( ! this.attributes ) {
      this.attributes = {};
    }
    this.attributes[ name ] = value;
    if (this.onattributes.ready) this.onattributes.sendEvent( name );
    this.ownerDocument.handleDocumentChange( "attributes" , this , 1, {name: name, value: value, type: 'set'});
    return value;
}

/**
  * Removes the named attribute
  * @param String name: The name of the attribute to remove.
  */
function removeAttr (name){
    var v = this.attributes[ name ];
    delete this.attributes[ name ];
    if (this.onattributes.ready) this.onattributes.sendEvent( name );
    this.ownerDocument.handleDocumentChange( "attributes" , this , 1, {name: name, value: v, type: 'remove'});
    return v;
}

/**
  *This method returns a Attr object.
  *The name parameter is of type String.
  */
//function getAttributeNode (name){
//}

/**
  *This method returns a Attr object.
  *The newAttr parameter is a Attr object.
  */
//function setAttrNode (newAttr){
//}

/**
  * Tests whether or not this node has a given attribute.
  * @param String name: The name of the attribute to test
  * @return Boolean: If true, the named attribute is present.
  */
function hasAttr (name){
    return this.attributes[ name ] != null;
}

/**
  * Returns the first child of this node.
  * @return LzDataNode: The first child of this node
  */
function getFirstChild (){
    return this.childNodes[ 0 ];
}
/**
  * @access private
  */
prototype.getFirstChild.dependencies = function( who, self ){
    return [ this , "childNodes" ];
}

/**
  * Returns the last child of this node.
  * @return LzDataNode: The last child of this node
  */
function getLastChild (){
    return this.childNodes[ this.childNodes.length-1 ];
}
/**
  * @access private
  */
prototype.getLastChild.dependencies = function( who, self ){
    return [ this , "childNodes" ];
}


/**
  * @access private
  */
function __LZupdateCO (){
    for ( var i = 0; i < this.childNodes.length; i++ ){
        this.childNodes[ i ].__LZo = i;
    }
    this.__LZcoDirty = false;
}


/**
  * @access private
  */
prototype.hasAttr.dependencies = function (who , self){
    return [ self, 'attributes' ];
}

/**
  * Sets the attributes of this node to the given Object.
  * @param Object attrs: The object to use as the attrs for this node.
  */
function setAttrs ( attrs ){
    var a = {};
    for ( var k in attrs ){ a[ k ] = attrs[ k ]; }

    this.attributes = a;
    if (this.onattributes.ready) this.onattributes.sendEvent( a);
    if (this.ownerDocument) {
        this.ownerDocument.handleDocumentChange( "attributes" , this , 1);
    }
}

/**
  * Sets the children of this node to the given array.
  * @param [LzDataNode] children: An array of LzDataNodes to be the new children
  * of this node
  */
function setChildNodes ( children ){
    this.childNodes = children;
    for ( var i = 0; i < children.length; i++ ){
        var c = children[ i ];
        if (c) {
            c.setOwnerDocument( this.ownerDocument );
            c.parentNode = this;
            if (c.onparentNode) {
                if (c.onparentNode.ready) c.onparentNode.sendEvent( this );
            }
            c.__LZo = i;
        }
    }
    this.__LZcoDirty = false;
    if (this.onchildNodes) {
        if (this.onchildNodes.ready) this.onchildNodes.sendEvent( children );
    }
    this.ownerDocument.handleDocumentChange( "childNodes" , this , 0);
}

/**
  * Sets the name of this node.
  * @param String name: The new name for this node
  */
function setNodeName ( name ){
    //Debug.write('setting node name from "',this.nodeName, '" to "', name, '"');
    this.nodeName = name;
    //since this can affect xpaths, send onchildNodes event
    if (this.onnodeName.ready) this.onnodeName.sendEvent( name );
    if (this.parentNode) {
        if (this.parentNode.onchildNodes.ready) this.parentNode.onchildNodes.sendEvent( this );
        if (this.parentNode.onchildNode.ready) this.parentNode.onchildNode.sendEvent( this );
    }
    this.ownerDocument.handleDocumentChange( "childNodeName" , 
                                             this.parentNode , 0 );
    this.ownerDocument.handleDocumentChange( "nodeName" , this, 1 );
}

/**
  * @access private
  */
function __LZgetText ( ){
    var s= "";
    for ( var i = 0; i < this.childNodes.length; i++ ){
        var c = this.childNodes[ i ]
        if ( c.nodeType == LzDataNode.TEXT_NODE ){
            s += c.data;
        }
    }
    return s;
}

/**
  * Returns a list of the childNodes of this node which have a given name
  * @param String name: The name of the node to look for.
  * @return [LzDataNode]: A list of childNodes which have the given name.
  */
function getElementsByTagName (name) {
    var r = [];
    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[i].nodeName == name ){
            r.push( this.childNodes[ i ] );
        }
    }
    return r;
}

/*
//This method returns a Attr object.
//The oldAttr parameter is a Attr object.
//This method can raise a DOMException object. 
// function removeAttributeNode (oldAttr) {
}
//This method returns a String.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getAttributeNS (namespaceURI, localName) {
}
//This method has no return value.
//The namespaceURI parameter is of type String.
//The qualifiedName parameter is of type String.
//The value parameter is of type String.
//This method can raise a DOMException object. 
// function setAttrNS (namespaceURI, qualifiedName, 
                                                                    value) {
}
//This method has no return value.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String.
//This method can raise a DOMException object. 
// function removeAttributeNS (namespaceURI, localName) {
}
//This method returns a Attr object.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getAttributeNodeNS (namespaceURI, localName) {
}
//This method returns a Attr object.
//The newAttr parameter is a Attr object.
//This method can raise a DOMException object. 
// function setAttrNodeNS (newAttr) {
}
//This method returns a NodeList object.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getElementsByTagNameNS (namespaceURI, localName) {
}
//This method returns a Boolean.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String.
// function hasAttrNS (namespaceURI, localName) {
}
*/

var __LZlt = "<";
var __LZgt = ">";


/**
  * Returns this node as a string of xml.
  * @return String: The string serialization of this node.
  */
function serialize (){
    return this.serializeInternal(Infinity);
}

/**
  * Implementation of serialize with option to limit string length
  * @access private
  */
function serializeInternal (len) {
    if (arguments.length < 1) {
        len = Infinity;
    }
    var s = this.__LZlt + this.nodeName;

    //Debug.info('k', this.attributes);
    for ( var k in this.attributes ){
        s += " " + k + '="' + LzDataNode.__LZXMLescape( this.attributes[ k ] ) + '"';
        if (s.length > len) { break; }
    }

    if ( s.length <= len && this.childNodes && this.childNodes.length ){
        s += this.__LZgt;
        for ( var i = 0; i < this.childNodes.length; i++ ){
            s += this.childNodes[ i ].serialize(len);
            if (s.length > len) { break; }
        }
        s += this.__LZlt + "/" + this.nodeName + this.__LZgt;
    } else {
        s += "/" + this.__LZgt;
    }
    if (s.length > len) { s = Debug.abbreviate(s, len); }
    return s;
}

/**
  * For debugging.  Same as serialize, but will abbreviate at printLength.
  * @access private
  */
function _dbg_name () {
    return this.serializeInternal(Debug.printLength);
}

/**
  * Nodes call this method on their ownerDocument whenever they change in any 
  * way. This method sends the onDocumentChange event, which triggers
  * datapointer updates
  * @param String what: A description of what changed.
  * @param LzDataNode who: The node that changed.
  * @param Number type: private
  */
function handleDocumentChange ( what , who , type, cobj ){
    var o = { who:  who , what: what , type : type};
    if (cobj) o.cobj = cobj;
    if ( this.__LZchangeQ ){
        this.__LZchangeQ.push ( o );
    } else {
        if (this.onDocumentChange.ready) this.onDocumentChange.sendEvent( o );
    }
}

/**
  * @access private
  */
function toString (){
    //this.__LZlt = "&lt;";
    //this.__LZgt = "&gt;";
    var r = this.serialize();
    //delete this.__LZlt;
    //delete this.__LZgt;
    return r;
}

/**
  * @access private
  */
function __LZdoLock ( locker ){
    if ( !this.__LZchangeQ ){
        this.__LZchangeQ = [];
        this.__LZlocker = locker;
    }
}


/**
  * @access private
  */
function __LZdoUnlock ( locker ){
    
    if ( this.__LZlocker != locker ){
        return;
    }

    var lzq = this.__LZchangeQ;
    this.__LZchangeQ = null;

    if (lzq != null) {
        for ( var i = 0; i < lzq.length; i++ ){
            var sendit = true;
            var tc = lzq[ i ];
            for ( var j = 0; j < i; j++ ){
                var oc = lzq[ j ];
                if ( tc.who == oc.who &&
                     tc.what == oc.what &&
                     tc.type == oc.type ){
                    sendit = false;
                    break;
                }
            }

            if ( sendit ){
                this.handleDocumentChange ( tc.what, tc.who, tc.type );
            }
        }
    }
    

}

/**
  * Get LzDataElement representation of primitive type, array, or object value.
  */
static function valueToElement ( o ) {
    var n = new LzDataElement("element", { }, LzMiniNode_DataNode_DOM.__LZv2E(o));
    return n; 
}

/**
  * @param Type o: primitive type, array, or object value.
  * @return array of LzDataElements
  * @access private
  */
static function __LZv2E ( o ) {

    var type = typeof( o );
    type.toLowerCase();

    var c = [];
    if (type == "object") {
        if ( o instanceof LzDataElement ||
             o instanceof LzDataText ) {
            c[0] = o;
        } else if (o instanceof Date) {

            type = "date";
            // FIXME: [2004-04-10 pkang] what should we do with dates?

        } else if (o instanceof Array) {
            type = "array";
            var tag = (o.__LZtag != null ? o.__LZtag : 'item');
            for (var i=0; i < o.length; i++) {
                var tmpC = LzMiniNode_DataNode_DOM.__LZv2E( o[i] );
                c[i] = new LzDataElement(tag, null, tmpC ); 
            }
        } else {
            type = "struct";
            var i = 0;
            for (var k in o) {
                // skip any properties that start with __LZ
                if (k.indexOf('__LZ') == 0) continue;
                c[i++] = new LzDataElement(k, null, LzMiniNode_DataNode_DOM.__LZv2E(o[k]));
            }
        }
    } else if (o != null) {
        c[0] = new LzDataText( o );
    }

    if (c.length == 0) c = null;

    return c;
}
// End of Manual include
}



// *********************
// *                   *
// *  LzNode_DataNode  *
// *                   *
// *********************

class LzNode_DataNode extends LzNode
{
//    #include "data/LzDataNode.lzs"
// Manual include of LzDataNode.lzs
var onownerDocument = LzDeclaredEvent;


/** The type of this node -- ELEMENT_NODE or TEXT_NODE
  * @type Number
  * @keywords abstract
  */
var nodeType; // This is undefined. Set elsewhere

/**
  * Returns the sibling before this one this node's parentNodes List of children
  * @return LzDataNode: The node preceeding this one in this node's childNodes
  */
function getPreviousSibling (){
    if (!this.parentNode) return null;
    if ( this.parentNode.__LZcoDirty ) this.parentNode.__LZupdateCO();
    return this.parentNode.childNodes[ this.__LZo - 1 ];
}

/**
 * Returns the parent of this node
 * @return LzDataNode: the parent of this node
 */
function getParent () {
  return this.parentNode;
}

/**
  * gets offset of node in parent's childNodes array
  * @return number
  */
function getOffset (){
    if (!this.parentNode) return 0;
    if (this.parentNode.__LZcoDirty) this.parentNode.__LZupdateCO();

    return this.__LZo;
}

/**
  * @access private
  */
prototype.getPreviousSibling.dependencies = function( who, self ){
    return [ this.parentNode , "childNodes" , this , "parentNode" ];
}

/**
  * Returns the sibling after this one this node's parentNodes List of children
  * @return LzDataNode: The node succeeding this one in this node's childNodes
  */
function getNextSibling (){
    if (!this.parentNode) return null;
    if ( this.parentNode.__LZcoDirty ) this.parentNode.__LZupdateCO();
    return this.parentNode.childNodes[ this.__LZo + 1 ];
}

/**
  * @access private
  */
prototype.getNextSibling.dependencies = function( who, self ){
    return [ this.parentNode , "childNodes" , this , "parentNode" ];
}

/**
  * Tells whether the given node is above this one in the node hierarchy.
  * @param LzDataElement el: The LzDataElement to test to see if it is above
  * this one
  * @param Boolean allowself: If true, this function returns true if the given
  * node is the same as this node.
  */
function childOf ( el , allowself ) {
    var p = allowself ? this : this.parentNode
    while ( p ){
        if ( p == el ) return true;
        p = p.parentNode;
    }
    return false;
}

/**
  * Sets the LzDataNode which is the ownerDocument for this node.
  * @param LzDataNode ownerDoc: The LzDataNode to act as the ownerDocument for
  * this node.
  */
function setOwnerDocument ( ownerDoc ){
    this.ownerDocument = ownerDoc;
    if (this.childNodes) {
        for ( var i = 0; i < this.childNodes.length; i++ ){
            this.childNodes[ i ] .setOwnerDocument( ownerDoc );
        }
    }

    if (this.onownerDocument && this.onownerDocument.ready) {
        this.onownerDocument.sendEvent( ownerDoc );
    }
}


/**
  * @access private
  */
function __LZlockFromUpdate ( locker ){
    this.ownerDocument.__LZdoLock( locker );
}

/**
  * @access private
  */
function __LZunlockFromUpdate ( locker ){
    this.ownerDocument.__LZdoUnlock( locker );
}

// End of Manual include
}


// *************************
// *                       *
// *  LzNode_DataNode_DOM  *
// *                       *
// *************************

// class LzMiniNode_DataNode_DOM = LzMiniNode + LzDataNode + LzDataDOM
class LzNode_DataNode_DOM extends LzNode_DataNode
{
//    #include "data/LzDataDOM.lzs"
// Manual include of LzDataDOM.lzs
    static function initialize (prototype) {
//       Debug.debug('LzDataElementTraitInitialize')
      // There will be no setters property in the trait prototype,
      // (and you don't want one there! as it would shadow the one
      // from LzNode) but it will be there after LzNode.initialize
      // runs
      if (prototype.hasOwnProperty('setters')) {
        // since you can't assign directly to these slots...
        // until LzNode.initialize has run
        prototype.setters.attributes = "setAttrs";
        prototype.setters.childNodes = "setChildNodes";
        prototype.setters.nodeName = "setNodeName";
        // Shouldn't be directly settable
        prototype.setters.ownerDocument = "setOwnerDocument";
      }
    }

/** @lzxtype event */
var onDocumentChange = LzDeclaredEvent;
/** @lzxtype event */
var onparentNode = LzDeclaredEvent;
/** @lzxtype event */
var onchildNode = LzDeclaredEvent;
/** @lzxtype event */
var onchildNodes = LzDeclaredEvent;
/** @lzxtype event */
var onattributes = LzDeclaredEvent;
/** @lzxtype event */
var onnodeName = LzDeclaredEvent;

/** @access private */
var __LZo = -1;
/** @access private */
var __LZcoDirty = true;
/** @access private */
var __LZchangeQ = null;
/** @access private */
var __LZlocker = null;


/** Inserts the given LzDataNode before another node in this node's childNodes
  * @param LzDataNode newChild: the LzDataNode to insert
  * @param LzDataNode refChild: the LzDataNode to insert newChild before
  * @return LzDataElement: The new child, or null if the refChild wasn't found
  */
function insertBefore (newChild, refChild){
    this.__LZcoDirty = true;

    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[ i ] == refChild ){
            this.childNodes.splice( i , 0 , newChild );
            newChild.setOwnerDocument( this.ownerDocument );

            newChild.parentNode = this;
            if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
            this.ownerDocument.handleDocumentChange( "insertBefore" , 
                                                     this, 0 );
            return newChild;
        }
    }

    //raise exception
    return null;
}


/**
  * Replaces a given LzDataNode in this node's childNodes with a new one.
  * @param LzDataNode newChild: the LzDataNode to add
  * @param LzDataNode oldChild: the LzDataNode to be replaced by the newChild
  * @return LzDataElement: The new child, or null if the oldChild wasn't found
  */
function replaceChild (newChild, oldChild){

    this.__LZcoDirty = true;
    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[ i ] == oldChild ){
            this.childNodes[ i ] = newChild;

            newChild.setOwnerDocument( this.ownerDocument );

            newChild.parentNode = this;
            if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
            this.ownerDocument.handleDocumentChange( "childNodes" , this , 0, newChild );
            return newChild;
        }
    }
    //raise exception
    return null;
}

/**
  * Removes a given node from this node's childNodes
  * @param LzDataNode oldChild: The LzDataNode to remove
  * @return LzDataNode: The removed child, or null if the oldChild was not found
  */
function removeChild (oldChild){
    var reval = null;
    this.__LZcoDirty = true;
    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[ i ] == oldChild ){
            this.childNodes.splice( i , 1 );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( oldChild );
            reval = oldChild;
            this.ownerDocument.handleDocumentChange("removeChild", this, 0, oldChild);
        }
    }
    //raise exception if not found
    return reval;
}

/**
  * Adds a child to this node's list of childNodes
  * @param LzDataNode newChild: The LzDataNode to add.
  * @return LzDataNode: The newChild.
  */
function appendChild (newChild){
    if ( this.childNodes ){
        this.childNodes.push( newChild );
    } else {
        this.childNodes = [ newChild ];
    }

    newChild.setOwnerDocument( this.ownerDocument );

    newChild.parentNode = this;
    if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );

    //instead of marking dirty, this is easy
    newChild.__LZo = this.childNodes.length -1;

    if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
    this.ownerDocument.handleDocumentChange( "appendChild" , this , 0, newChild );
    return newChild;
}

/**
  * Tests whether or not this node has child nodes.
  * @return Boolean: If true, this node has child nodes.
  */
function hasChildNodes (){
    return this.childNodes.length > 0;
}

/**
  * Returns a copy of this node.
  * @param Boolean deep: If true, the children of this node will be part of the
  * new node
  * @return LzDataNode: A copy of this node.
  */
function cloneNode ( deep ){
    var n = new LzDataElement(this.nodeName);
    n.setAttrs( this.attributes );
    if ( deep ){
        for ( var i = 0 ; i < this.childNodes.length; i++ ){
            n.appendChild ( this.childNodes[ i ].cloneNode( true ) );
        }
    }

    return n;
}

/**
  * Returns the value for the give attribute
  * @param String name: The name of the attribute whose value to return
  * @return String: The value for the given attribute
  */
function getAttr (name){
    if (this.attributes) return this.attributes[ name ];
}

/**
  * @access private
  */
prototype.getAttr.dependencies = function (who , self){
    return [ self, 'attributes' ];
}

/**
  * Sets the given attribute to the given value
  * @param String name: The name of the attribute to set.
  * @param String value: The value for the attribute.
  */
function setAttr (name, value){
    if ( ! this.attributes ) {
      this.attributes = {};
    }
    this.attributes[ name ] = value;
    if (this.onattributes.ready) this.onattributes.sendEvent( name );
    this.ownerDocument.handleDocumentChange( "attributes" , this , 1, {name: name, value: value, type: 'set'});
    return value;
}

/**
  * Removes the named attribute
  * @param String name: The name of the attribute to remove.
  */
function removeAttr (name){
    var v = this.attributes[ name ];
    delete this.attributes[ name ];
    if (this.onattributes.ready) this.onattributes.sendEvent( name );
    this.ownerDocument.handleDocumentChange( "attributes" , this , 1, {name: name, value: v, type: 'remove'});
    return v;
}

/**
  *This method returns a Attr object.
  *The name parameter is of type String.
  */
//function getAttributeNode (name){
//}

/**
  *This method returns a Attr object.
  *The newAttr parameter is a Attr object.
  */
//function setAttrNode (newAttr){
//}

/**
  * Tests whether or not this node has a given attribute.
  * @param String name: The name of the attribute to test
  * @return Boolean: If true, the named attribute is present.
  */
function hasAttr (name){
    return this.attributes[ name ] != null;
}

/**
  * Returns the first child of this node.
  * @return LzDataNode: The first child of this node
  */
function getFirstChild (){
    return this.childNodes[ 0 ];
}
/**
  * @access private
  */
prototype.getFirstChild.dependencies = function( who, self ){
    return [ this , "childNodes" ];
}

/**
  * Returns the last child of this node.
  * @return LzDataNode: The last child of this node
  */
function getLastChild (){
    return this.childNodes[ this.childNodes.length-1 ];
}
/**
  * @access private
  */
prototype.getLastChild.dependencies = function( who, self ){
    return [ this , "childNodes" ];
}


/**
  * @access private
  */
function __LZupdateCO (){
    for ( var i = 0; i < this.childNodes.length; i++ ){
        this.childNodes[ i ].__LZo = i;
    }
    this.__LZcoDirty = false;
}


/**
  * @access private
  */
prototype.hasAttr.dependencies = function (who , self){
    return [ self, 'attributes' ];
}

/**
  * Sets the attributes of this node to the given Object.
  * @param Object attrs: The object to use as the attrs for this node.
  */
function setAttrs ( attrs ){
    var a = {};
    for ( var k in attrs ){ a[ k ] = attrs[ k ]; }

    this.attributes = a;
    if (this.onattributes.ready) this.onattributes.sendEvent( a);
    if (this.ownerDocument) {
        this.ownerDocument.handleDocumentChange( "attributes" , this , 1);
    }
}

/**
  * Sets the children of this node to the given array.
  * @param [LzDataNode] children: An array of LzDataNodes to be the new children
  * of this node
  */
function setChildNodes ( children ){
    this.childNodes = children;
    for ( var i = 0; i < children.length; i++ ){
        var c = children[ i ];
        if (c) {
            c.setOwnerDocument( this.ownerDocument );
            c.parentNode = this;
            if (c.onparentNode) {
                if (c.onparentNode.ready) c.onparentNode.sendEvent( this );
            }
            c.__LZo = i;
        }
    }
    this.__LZcoDirty = false;
    if (this.onchildNodes) {
        if (this.onchildNodes.ready) this.onchildNodes.sendEvent( children );
    }
    this.ownerDocument.handleDocumentChange( "childNodes" , this , 0);
}

/**
  * Sets the name of this node.
  * @param String name: The new name for this node
  */
function setNodeName ( name ){
    //Debug.write('setting node name from "',this.nodeName, '" to "', name, '"');
    this.nodeName = name;
    //since this can affect xpaths, send onchildNodes event
    if (this.onnodeName.ready) this.onnodeName.sendEvent( name );
    if (this.parentNode) {
        if (this.parentNode.onchildNodes.ready) this.parentNode.onchildNodes.sendEvent( this );
        if (this.parentNode.onchildNode.ready) this.parentNode.onchildNode.sendEvent( this );
    }
    this.ownerDocument.handleDocumentChange( "childNodeName" , 
                                             this.parentNode , 0 );
    this.ownerDocument.handleDocumentChange( "nodeName" , this, 1 );
}

/**
  * @access private
  */
function __LZgetText ( ){
    var s= "";
    for ( var i = 0; i < this.childNodes.length; i++ ){
        var c = this.childNodes[ i ]
        if ( c.nodeType == LzDataNode.TEXT_NODE ){
            s += c.data;
        }
    }
    return s;
}

/**
  * Returns a list of the childNodes of this node which have a given name
  * @param String name: The name of the node to look for.
  * @return [LzDataNode]: A list of childNodes which have the given name.
  */
function getElementsByTagName (name) {
    var r = [];
    for ( var i = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[i].nodeName == name ){
            r.push( this.childNodes[ i ] );
        }
    }
    return r;
}

/*
//This method returns a Attr object.
//The oldAttr parameter is a Attr object.
//This method can raise a DOMException object. 
// function removeAttributeNode (oldAttr) {
}
//This method returns a String.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getAttributeNS (namespaceURI, localName) {
}
//This method has no return value.
//The namespaceURI parameter is of type String.
//The qualifiedName parameter is of type String.
//The value parameter is of type String.
//This method can raise a DOMException object. 
// function setAttrNS (namespaceURI, qualifiedName, 
                                                                    value) {
}
//This method has no return value.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String.
//This method can raise a DOMException object. 
// function removeAttributeNS (namespaceURI, localName) {
}
//This method returns a Attr object.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getAttributeNodeNS (namespaceURI, localName) {
}
//This method returns a Attr object.
//The newAttr parameter is a Attr object.
//This method can raise a DOMException object. 
// function setAttrNodeNS (newAttr) {
}
//This method returns a NodeList object.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getElementsByTagNameNS (namespaceURI, localName) {
}
//This method returns a Boolean.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String.
// function hasAttrNS (namespaceURI, localName) {
}
*/

var __LZlt = "<";
var __LZgt = ">";


/**
  * Returns this node as a string of xml.
  * @return String: The string serialization of this node.
  */
function serialize (){
    return this.serializeInternal(Infinity);
}

/**
  * Implementation of serialize with option to limit string length
  * @access private
  */
function serializeInternal (len) {
    if (arguments.length < 1) {
        len = Infinity;
    }
    var s = this.__LZlt + this.nodeName;

    //Debug.info('k', this.attributes);
    for ( var k in this.attributes ){
        s += " " + k + '="' + LzDataNode.__LZXMLescape( this.attributes[ k ] ) + '"';
        if (s.length > len) { break; }
    }

    if ( s.length <= len && this.childNodes && this.childNodes.length ){
        s += this.__LZgt;
        for ( var i = 0; i < this.childNodes.length; i++ ){
            s += this.childNodes[ i ].serialize(len);
            if (s.length > len) { break; }
        }
        s += this.__LZlt + "/" + this.nodeName + this.__LZgt;
    } else {
        s += "/" + this.__LZgt;
    }
    if (s.length > len) { s = Debug.abbreviate(s, len); }
    return s;
}

/**
  * For debugging.  Same as serialize, but will abbreviate at printLength.
  * @access private
  */
function _dbg_name () {
    return this.serializeInternal(Debug.printLength);
}

/**
  * Nodes call this method on their ownerDocument whenever they change in any 
  * way. This method sends the onDocumentChange event, which triggers
  * datapointer updates
  * @param String what: A description of what changed.
  * @param LzDataNode who: The node that changed.
  * @param Number type: private
  */
function handleDocumentChange ( what , who , type, cobj ){
    var o = { who:  who , what: what , type : type};
    if (cobj) o.cobj = cobj;
    if ( this.__LZchangeQ ){
        this.__LZchangeQ.push ( o );
    } else {
        if (this.onDocumentChange.ready) this.onDocumentChange.sendEvent( o );
    }
}

/**
  * @access private
  */
function toString (){
    //this.__LZlt = "&lt;";
    //this.__LZgt = "&gt;";
    var r = this.serialize();
    //delete this.__LZlt;
    //delete this.__LZgt;
    return r;
}

/**
  * @access private
  */
function __LZdoLock ( locker ){
    if ( !this.__LZchangeQ ){
        this.__LZchangeQ = [];
        this.__LZlocker = locker;
    }
}


/**
  * @access private
  */
function __LZdoUnlock ( locker ){
    
    if ( this.__LZlocker != locker ){
        return;
    }

    var lzq = this.__LZchangeQ;
    this.__LZchangeQ = null;

    if (lzq != null) {
        for ( var i = 0; i < lzq.length; i++ ){
            var sendit = true;
            var tc = lzq[ i ];
            for ( var j = 0; j < i; j++ ){
                var oc = lzq[ j ];
                if ( tc.who == oc.who &&
                     tc.what == oc.what &&
                     tc.type == oc.type ){
                    sendit = false;
                    break;
                }
            }

            if ( sendit ){
                this.handleDocumentChange ( tc.what, tc.who, tc.type );
            }
        }
    }
    

}

/**
  * Get LzDataElement representation of primitive type, array, or object value.
  */
static function valueToElement ( o ) {
    var n = new LzDataElement("element", { }, LzNode_DataNode_DOM.__LZv2E(o));
    return n; 
}

/**
  * @param Type o: primitive type, array, or object value.
  * @return array of LzDataElements
  * @access private
  */
static function __LZv2E ( o ) {

    var type = typeof( o );
    type.toLowerCase();

    var c = [];
    if (type == "object") {
        if ( o instanceof LzDataElement ||
             o instanceof LzDataText ) {
            c[0] = o;
        } else if (o instanceof Date) {

            type = "date";
            // FIXME: [2004-04-10 pkang] what should we do with dates?

        } else if (o instanceof Array) {
            type = "array";
            var tag = (o.__LZtag != null ? o.__LZtag : 'item');
            for (var i=0; i < o.length; i++) {
                var tmpC = LzNode_DataNode_DOM.__LZv2E( o[i] );
                c[i] = new LzDataElement(tag, null, tmpC ); 
            }
        } else {
            type = "struct";
            var i = 0;
            for (var k in o) {
                // skip any properties that start with __LZ
                if (k.indexOf('__LZ') == 0) continue;
                c[i++] = new LzDataElement(k, null, LzNode_DataNode_DOM.__LZv2E(o[k]));
            }
        }
    } else if (o != null) {
        c[0] = new LzDataText( o );
    }

    if (c.length == 0) c = null;

    return c;
}
// End of Manual include
}
