/**
  * @copyright Copyright 2001-2009 Laszlo Systems, Inc.  All Rights Reserved.
  *            Use is subject to license terms.
  *
  * @access public
  * @topic LFC
  * @subtopic Data
  */


/**
  * @shortdesc A node of hierarchical data.
  * @see LzDataNodeMixin LzDataText LzDataPointer
  * @access public
  *
  * @devnote W3C-DOM Element interface: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-745549614
  */
mixin LzDataElementMixin {
    // N.B.: LzDataElementMixin may or may not be an LzNode, so
    // _if_ it were to have an initialize method, it would have to
    // match LzNode.initialize's signature.

/** @access private */
var __LZchangeQ :Array = null;
/** @access private */
var __LZlocker :LzDatapath = null;

/** The name of this node.
  * @type String
  */
var nodeName:String = null;

/** The dictionary of attributes for this node.
  * @type Object
  */
var attributes:Object = null;


/** Inserts the given LzDataNodeMixin before another node in this node's childNodes
  * @param LzDataNodeMixin newChild: the LzDataNodeMixin to insert
  * @param LzDataNodeMixin refChild: the LzDataNodeMixin to insert newChild before
  * @return LzDataNodeMixin: The new child, or null if the refChild wasn't found
  */
public function insertBefore (newChild, refChild){
    if (newChild == null) {
        return null;
    } else if (refChild == null) {
        return this.appendChild(newChild);
    } /* else if (newChild === this) {
        //raise DOMException "HIERARCHY_REQUEST_ERR"
        return null;
    } */ else {
        var off:int = this.__LZgetCO(refChild);
        if (off >= 0) {
            var samenode:Boolean = (newChild === refChild);
            if (newChild.parentNode != null) {
                if (newChild.parentNode === this) {
                    if (! samenode) {
                        this.__LZremoveChild( newChild );
                    }
                } else {
                    newChild.parentNode.removeChild( newChild );
                }
            }

            if (! samenode) {
                this.__LZcoDirty = true;
                this.childNodes.splice( off, 0, newChild );
            }

            newChild.$lzc$set_ownerDocument( this.ownerDocument );
            newChild.parentNode = this;
            if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
            this.ownerDocument.handleDocumentChange( "insertBefore", this, 0 );

            return newChild;
        }

        //raise DOMException "NOT_FOUND_ERR"
        return null;
    }
}


/**
  * Replaces a given LzDataNodeMixin in this node's childNodes with a new one.
  * @param LzDataNodeMixin newChild: the LzDataNodeMixin to add
  * @param LzDataNodeMixin oldChild: the LzDataNodeMixin to be replaced by the newChild
  * @return LzDataNodeMixin: The new child, or null if the oldChild wasn't found
  * @dev-note: DOM-Spec (Level2, Level3) says we need to return the oldChild instead of the newChild
  */
public function replaceChild (newChild, oldChild){
    if (newChild == null) {
        return null;
    } /* else if (newChild === this) {
        //raise DOMException "HIERARCHY_REQUEST_ERR"
        return null;
    } */ else {
        var off:int = this.__LZgetCO(oldChild);
        if (off >= 0) {
            var samenode:Boolean = (newChild === oldChild);
            if (newChild.parentNode != null) {
                if (newChild.parentNode === this) {
                    if (! samenode) {
                        this.__LZremoveChild( newChild );
                    }
                } else {
                    newChild.parentNode.removeChild( newChild );
                }
            }

            if (! samenode) {
                // @devnote parentNode needs to be set to null, but that breaks smoke-check.
                // DOM Level1, parentNode description:
                // "The parent of this node. [...], if a node has just been created and not yet
                // added to the tree, or if it has been removed from the tree, this is null."
                // oldChild.parentNode = null;
                //adjust node-offset
                newChild.__LZo = off;
                this.childNodes[ off ] = newChild;
            }

            newChild.$lzc$set_ownerDocument( this.ownerDocument );
            newChild.parentNode = this;
            if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );
            if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
            this.ownerDocument.handleDocumentChange( "childNodes", this, 0, newChild );

            return newChild;
        }

        //raise DOMException "NOT_FOUND_ERR"
        return null;
    }
}

/**
  * Removes a given node from this node's childNodes
  * @param LzDataNodeMixin oldChild: The LzDataNodeMixin to remove
  * @return LzDataNodeMixin: The removed child, or null if the oldChild was not found
  */
public function removeChild (oldChild){
    var off:int = this.__LZgetCO(oldChild);
    if (off >= 0) {
        // @devnote parentNode needs to be set to null, but that breaks smoke-check.
        // DOM Level1, parentNode description:
        // "The parent of this node. [...], if a node has just been created and not yet
        // added to the tree, or if it has been removed from the tree, this is null."
        // oldChild.parentNode = null;

        this.__LZcoDirty = true;
        this.childNodes.splice( off, 1 );

        if (this.onchildNodes.ready) this.onchildNodes.sendEvent( oldChild );
        this.ownerDocument.handleDocumentChange("removeChild", this, 0, oldChild);

        return oldChild;
    }

    //raise DOMException "NOT_FOUND_ERR"
    return null;
}

/**
  * Adds a child to this node's list of childNodes
  * @param LzDataNodeMixin newChild: The LzDataNodeMixin to add.
  * @return LzDataNodeMixin: The newChild.
  */
public function appendChild (newChild){
    if (newChild == null) {
        return null;
    } /* else if (newChild === this) {
        //raise DOMException "HIERARCHY_REQUEST_ERR"
        return null;
    } */ else {
        if (newChild.parentNode != null) {
            if (newChild.parentNode === this) {
                this.__LZcoDirty = true;
                this.__LZremoveChild( newChild );
            } else {
                newChild.parentNode.removeChild( newChild );
            }
        }

        if (this.childNodes) {
            this.childNodes.push( newChild );
        } else {
            this.childNodes = [newChild];
        }

        //instead of marking dirty, this is easy
        newChild.__LZo = this.childNodes.length - 1;

        newChild.$lzc$set_ownerDocument( this.ownerDocument );
        newChild.parentNode = this;
        if (newChild.onparentNode.ready) newChild.onparentNode.sendEvent( this );
        if (this.onchildNodes.ready) this.onchildNodes.sendEvent( newChild );
        this.ownerDocument.handleDocumentChange( "appendChild", this, 0, newChild );

        return newChild;
    }
}

/**
  * Tests whether or not this node has child nodes.
  * @return Boolean: If true, this node has child nodes.
  */
public function hasChildNodes () :Boolean {
    return this.childNodes.length > 0;
}

/**
  * @access private
  */
override public function cloneNode ( deep:Boolean = false ) :LzDataNodeMixin {
    var n:LzDataElement = new LzDataElement(this.nodeName);
    n.$lzc$set_attributes( this.attributes );
    if ( deep ){
        for ( var i:int = 0; i < this.childNodes.length; i++ ){
            n.appendChild( this.childNodes[ i ].cloneNode( true ) );
        }
    }

    return n;
}

/**
  * Returns the value for the give attribute
  * @param String name: The name of the attribute whose value to return
  * @return String: The value for the given attribute
  */
public function getAttr (name:String) :String {
    if (this.attributes) return this.attributes[ name ];
    return null;
}
/** @access private */
function $lzc$getAttr_dependencies (who , self) :Array {
    return [ self, 'attributes' ];
}

/**
  * Sets the given attribute to the given value
  * @param String name: The name of the attribute to set.
  * @param String value: The value for the attribute.
  */
public function setAttr (name:String, value:String) :String {
    // Enforce string coercion for other runtimes.  This is consistent
    // with other DOM's which only permit string attributes.
    if ($as3) {
    } else {
      value = String(value);
    }
    if ( ! this.attributes ) {
      this.attributes = {};
    }
    this.attributes[ name ] = value;
    if (this.onattributes.ready) this.onattributes.sendEvent( name );
    this.ownerDocument.handleDocumentChange( "attributes" , this, 1, {name: name, value: value, type: 'set'});
    return value;
}

/**
  * Removes the named attribute
  * @param String name: The name of the attribute to remove.
  */
public function removeAttr (name:String) :String {
    var v:String = this.attributes[ name ];
    delete this.attributes[ name ];
    if (this.onattributes.ready) this.onattributes.sendEvent( name );
    this.ownerDocument.handleDocumentChange( "attributes", this, 1, {name: name, value: v, type: 'remove'});
    return v;
}

/**
  *This method returns a Attr object.
  *The name parameter is of type String.
  */
//function getAttributeNode (name){
//}

/**
  *This method returns a Attr object.
  *The newAttr parameter is a Attr object.
  */
//function setAttrNode (newAttr){
//}

/**
  * Tests whether or not this node has a given attribute.
  * @param String name: The name of the attribute to test
  * @return Boolean: If true, the named attribute is present.
  */
public function hasAttr (name:String) :Boolean {
    return this.attributes[ name ] != null;
}
/** @access private */
function $lzc$hasAttr_dependencies (who , self) :Array {
    return [ self, 'attributes' ];
}

/**
  * Returns the first child of this node.
  * @return LzDataNodeMixin: The first child of this node
  */
public function getFirstChild (){
    return this.childNodes[ 0 ];
}
/** @access private */
function $lzc$getFirstChild_dependencies( who, self ) :Array {
    return [ this, "childNodes" ];
}

/**
  * Returns the last child of this node.
  * @return LzDataNodeMixin: The last child of this node
  */
public function getLastChild (){
    return this.childNodes[ this.childNodes.length-1 ];
}
/** @access private */
function $lzc$getLastChild_dependencies( who, self ) :Array {
    return [ this, "childNodes" ];
}

/** @access private */
function __LZgetCO (child /*:LzDataNodeMixin*/) :int {
    if (child != null) {
        var cn:Array = this.childNodes;
        if (! this.__LZcoDirty) {
            //this is the fast path
            var i:int = child.__LZo;
            if (cn[i] === child) {
                return i;
            }
        } else {
            for (var i:int = cn.length - 1; i >= 0; --i) {
                if (cn[i] === child) {
                    return i;
                }
            }
        }
    }
    return -1;
}

/**
  * fast removing of a childnode without: 
  * - notifying the event-system 
  * - setting parentNode to null 
  * - setting ownerDocument to null 
  * @access private
  */
function __LZremoveChild (oldChild /*:LzDataNodeMixin*/ ) :void {
    var off:int = this.__LZgetCO(oldChild);
    if (off >= 0) {
        this.childNodes.splice(off, 1);
    }
}

/**
  * @access private
  */
function __LZupdateCO () :void {
    var cn:Array = this.childNodes;
    for ( var i:int = 0; i < cn.length; i++ ){
        cn[ i ].__LZo = i;
    }
    this.__LZcoDirty = false;
}

/** @access private */
function $lzc$set_attributes (attrs:Object) :void {
    var a:Object = {};
    for (var k:String in attrs) { a[ k ] = attrs[ k ]; }

    this.attributes = a;
    if (this.onattributes.ready) this.onattributes.sendEvent( a );
    if (this.ownerDocument) {
        this.ownerDocument.handleDocumentChange( "attributes", this, 1);
    }
}

/**
  * Sets the attributes of this node to the given Object.
  * @param Object attrs: The object to use as the attributes for this node.
  * @deprecated Use setAttribute('attributes', ...) instead.
  */
public final function setAttrs (attrs:Object) :void {
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    this.$lzc$set_attributes(attrs);
}

/** @access private */
function $lzc$set_childNodes (children:Array) :void {
    // @devnote parentNode needs to be set to null, but that breaks smoke-check.
    // DOM Level1, parentNode description:
    // "The parent of this node. [...], if a node has just been created and not yet
    // added to the tree, or if it has been removed from the tree, this is null."
    //var cn = this.childNodes;
    //if (cn && cn.length > 0) {
    //    for (var i = 0; i < cn.length; ++i) {
    //        cn.parentNode = null;
    //    }
    //}

    if (! children) children = [];
    this.childNodes = children;

    if (children.length > 0) {
        // special-case: we cannot call removeChild() if 'children' is the childNodes-Array
        // of another LzDataElement, because removeChild() alters the childNodes-Array directly. Argh!
        var notifyParent:Boolean = true;
        var otherParent = children[0].parentNode;
        if (otherParent != null && otherParent !== this && otherParent.childNodes === children) {
            notifyParent = false;
            otherParent.$lzc$set_childNodes([]);
        }

        for (var i:int = 0; i < children.length; i++) {
            var c = children[ i ];
            if (c) {
                if (notifyParent && c.parentNode != null) {
                    if (c.parentNode !== this) {
                        c.parentNode.removeChild( c );
                    }
                }

                c.$lzc$set_ownerDocument( this.ownerDocument );
                c.parentNode = this;
                if (c.onparentNode.ready) c.onparentNode.sendEvent( this );
                c.__LZo = i;
            }
        }
    }

    this.__LZcoDirty = false;
    if (this.onchildNodes.ready) this.onchildNodes.sendEvent( children );
    this.ownerDocument.handleDocumentChange( "childNodes", this, 0);
}

/**
  * Sets the children of this node to the given array.
  * @param [LzDataNodeMixin] children: An array of LzDataNodeMixins to be the new children
  * @deprecated Use setAttribute('childNodes', ...) instead.
  * of this node
  */
public final function setChildNodes (children:Array) :void {
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    this.$lzc$set_childNodes(children);
}

/** @access private */
function $lzc$set_nodeName (name:String) :void {
    this.nodeName = name;
    //since this can affect xpaths, send onchildNodes event
    if (this.onnodeName.ready) this.onnodeName.sendEvent( name );
    if (this.parentNode) {
        if (this.parentNode.onchildNodes.ready) this.parentNode.onchildNodes.sendEvent( this );
        if (this.parentNode.onchildNode.ready) this.parentNode.onchildNode.sendEvent( this );
    }
    this.ownerDocument.handleDocumentChange( "childNodeName", this.parentNode, 0 );
    this.ownerDocument.handleDocumentChange( "nodeName", this, 1 );
}

/**
  * Sets the name of this node.
  * @param String name: The new name for this node
  * @deprecated Use setAttribute('nodeName', ...) instead.
  */
public final function setNodeName (name:String) :void {
    if ($debug) Debug.deprecated(this, arguments.callee, this.setAttribute);
    this.$lzc$set_nodeName(name);
}

/**
  * @access private
  */
function __LZgetText () :String {
    var s:String = "";
    for ( var i:int = 0; i < this.childNodes.length; i++ ){
        var c = this.childNodes[ i ];
        if ( c.nodeType == LzDataElement.TEXT_NODE ){
            s += c.data;
        }
    }
    return s;
}

/**
  * Returns a list of the childNodes of this node which have a given name
  * @param String name: The name of the node to look for.
  * @return [LzDataNodeMixin]: A list of childNodes which have the given name.
  */
public function getElementsByTagName (name:String) :Array {
    var r:Array = [];
    for ( var i:int = 0; i < this.childNodes.length; i++ ){
        if ( this.childNodes[i].nodeName == name ){
            r.push( this.childNodes[ i ] );
        }
    }
    return r;
}

/*
//This method returns a Attr object.
//The oldAttr parameter is a Attr object.
//This method can raise a DOMException object. 
// function removeAttributeNode (oldAttr) {
}
//This method returns a String.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getAttributeNS (namespaceURI, localName) {
}
//This method has no return value.
//The namespaceURI parameter is of type String.
//The qualifiedName parameter is of type String.
//The value parameter is of type String.
//This method can raise a DOMException object. 
// function setAttrNS (namespaceURI, qualifiedName, 
                                                                    value) {
}
//This method has no return value.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String.
//This method can raise a DOMException object. 
// function removeAttributeNS (namespaceURI, localName) {
}
//This method returns a Attr object.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getAttributeNodeNS (namespaceURI, localName) {
}
//This method returns a Attr object.
//The newAttr parameter is a Attr object.
//This method can raise a DOMException object. 
// function setAttrNodeNS (newAttr) {
}
//This method returns a NodeList object.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String. 
// function getElementsByTagNameNS (namespaceURI, localName) {
}
//This method returns a Boolean.
//The namespaceURI parameter is of type String.
//The localName parameter is of type String.
// function hasAttrNS (namespaceURI, localName) {
}
*/

/**
  * @access private
  */
const __LZlt :String = "<";
/**
  * @access private
  */
const __LZgt :String = ">";


/**
  * @access private
  */
override public function serialize (len:Number = Infinity) :String {
    return this.serializeInternal(len);
}

/**
  * Implementation of serialize with option to limit string length
  * @access private
  */
function serializeInternal (len:Number = Infinity) :String {
    var s:String = this.__LZlt + this.nodeName;

    //Debug.info('k', this.attributes);
    for ( var k:String in this.attributes ){
        s += " " + k + '="' + LzDataElement.__LZXMLescape( this.attributes[ k ] ) + '"';
        if (s.length > len) { break; }
    }

    if ( s.length <= len && this.childNodes && this.childNodes.length ){
        s += this.__LZgt;
        for ( var i:int = 0; i < this.childNodes.length; i++ ){
            s += this.childNodes[ i ].serialize(len);
            if (s.length > len) { break; }
        }
        s += this.__LZlt + "/" + this.nodeName + this.__LZgt;
    } else {
        s += "/" + this.__LZgt;
    }
    if ($debug) {
      if (s.length > len) { s = Debug.abbreviate(s, len); }
    }
    return s;
}

if ($debug) {
/**
  * For debugging, useful to override _dbg_name().
  * _dbg_name should not be defined here, unless it
  * can be consistently overridden or not (some runtimes
  * need an 'override' keyword).
  * Same as serialize, but will abbreviate at printLength.
  * @access private
  */
function dataElementMixin_dbg_name () :String {
    return this.serializeInternal(Debug.printLength);
}
}

/**
  * Nodes call this method on their ownerDocument whenever they change in any 
  * way. This method sends the onDocumentChange event, which triggers
  * datapointer updates
  * @param String what: A description of what changed.
  * @param LzDataNodeMixin who: The node that changed.
  * @param Number type: private
  */
public function handleDocumentChange ( what:String, who /*:LzDataNodeMixin*/, type:int, cobj:Object? = null ) :void {
    var o:Object = {who: who, what: what, type: type};
    if (cobj) o.cobj = cobj;
    if ( this.__LZchangeQ ){
        this.__LZchangeQ.push( o );
    } else {
        if (this.onDocumentChange.ready) this.onDocumentChange.sendEvent( o );
    }
}

/**
  * @access private
  */
override function toString () /*:String*/ {
    return this.serialize();
}

/**
  * @dev-note: public for swf9, but still doc-private!
  * @access private
  */
public function __LZdoLock ( locker:LzDatapath ) :void {
    if ( !this.__LZchangeQ ){
        this.__LZchangeQ = [];
        this.__LZlocker = locker;
    }
}

/**
  * @dev-note: public for swf9, but still doc-private!
  * @access private
  */
public function __LZdoUnlock ( locker:LzDatapath ) :void {

    if ( this.__LZlocker != locker ){
        return;
    }

    var lzq:Array = this.__LZchangeQ;
    this.__LZchangeQ = null;
    this.__LZlocker = null;

    if (lzq != null) {
        for ( var i:int = 0; i < lzq.length; i++ ){
            var sendit:Boolean = true;
            var tc:Object = lzq[ i ];
            for ( var j:int = 0; j < i; j++ ){
                var oc:Object = lzq[ j ];
                if ( tc.who == oc.who &&
                     tc.what == oc.what &&
                     tc.type == oc.type ){
                    sendit = false;
                    break;
                }
            }

            if ( sendit ){
                this.handleDocumentChange( tc.what, tc.who, tc.type );
            }
        }
    }
}

} // End of LzDataElementMixin
lz.DataElementMixin = LzDataElementMixin;  // publish


/**
  * <p>
  * An <code>lz.DataElement</code> represents a node a in a hierarchical dataset.
  * An <code>lz.DataElement</code> can contain other <code>lz.DataElements</code>,
  * or <sgmltag class="element" role="LzDataText">lz.DataText</sgmltag>, which
  * represents a text node. See the example on <sgmltag class="element" role="LzDataNodeMixin">lz.DataNodeMixin</sgmltag>. 
  * </p>
  *
  * @shortdesc A node of hierarchical data.
  * @see LzDataNodeMixin LzDataText LzDataPointer
  * @access public
  */
class LzDataElement extends LzDataNode with LzDataElementMixin, LzDataNodeMixin {
    /** DEFINE OBJECT: LzDataElement
     * This object represents a hierarchical data node.
     * @param String name: The name for this node.
     * @param Object attributes: A optional dictionary of attributes for this node.
     * @param [LzDataNode] children: An optional array of children for this node
     */
    function LzDataElement ( name:String, attributes:Object? = null, children:Array? = null) {
        // N.B.: LzDataElement is not an LzNode so has a different
        // initialize signature.
        super();
        this.nodeName = name;
        this.nodeType = LzDataElement.ELEMENT_NODE;
        this.attributes = attributes;
        this.ownerDocument = this;
        this.$lzc$set_childNodes( children );
    }

/**
  * Returns a list of empty nodes, each named 'name'.
  * @param int count: how many nodes to create.
  * @param String name: the name for each node
  * @return Array: list of new nodes.
  */
static function makeNodeList(count:int, name:String) :Array {
    var a:Array = [];
    for (var i:int = 0; i < count; i++) {
        a[i] = new LzDataElement(name, {}, null);
    }
    return a;
}

/**
  * Get LzDataElement representation of primitive type, array, or object value.
  */
static function valueToElement ( o:* ) :LzDataElement {
    return new LzDataElement("element", {}, LzDataElement.__LZv2E(o));
}

/**
  * @param Type o: primitive type, array, or object value.
  * @return array of LzDataElements
  * @access private
  */
static function __LZv2E ( o:* ) :Array {

    var type:String = typeof( o );

    var c:Array = [];
    if (type == "object") {
        if ( o is LzDataElement ||
             o is LzDataText ) {
            c[0] = o;
        } else if (o is Date) {
            type = "date";
            // FIXME: [2004-04-10 pkang] what should we do with dates?
        } else if (o is Array) {
            type = "array";
            var tag:String = (o.__LZtag != null ? o.__LZtag : 'item');
            for (var i:int = 0; i < o.length; i++) {
                var tmpC:Array = LzDataElement.__LZv2E( o[i] );
                c[i] = new LzDataElement(tag, null, tmpC ); 
            }
        } else {
            type = "struct";
            var i:int = 0;
            for (var k:String in o) {
                // skip any properties that start with __LZ
                if (k.indexOf('__LZ') == 0) continue;
                c[i++] = new LzDataElement(k, null, LzDataElement.__LZv2E(o[k]));
            }
        }
    } else if (o != null) {
        c[0] = new LzDataText( o );
    }

    if (c.length == 0) c = null;

    return c;
}


/** constant for LZX DOM data element node type 
  * @type int
  * @lzxdefault 1
  * @keywords read-only
  */
static const ELEMENT_NODE :int = 1;
/** constant for LZX DOM data text node type 
  * @type int
  * @lzxdefault 3
  * @keywords read-only
  */
static const TEXT_NODE :int = 3;
/** constant for LZX DOM document root node type  
  * @type int
  * @lzxdefault 9
  * @keywords read-only
  */
static const DOCUMENT_NODE :int = 9;

/** this is similar to the escape routine in LzText, but that one's shorter
  * since flash it's just for escaping &gt;&lt;
  * @access private
  */
static const __LZescapechars :Object =
{ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&apos;'};


/**
  * @access private
  */
static function __LZXMLescape ( t:* ) :* {
    if ( typeof( t ) != "string" ) return t;

    const escChars:Object = LzDataElement.__LZescapechars;
    var olen:int = t.length;
    var r:String = "";
    for ( var i:int = 0; i < olen; i++ ){
        //handle newlines
        var code:Number = t.charCodeAt( i );
        if ( code < 32 ){
            r += "&#x" + code.toString(16) + ";";
        } else {
            var c:String = t.charAt( i );
            r += (escChars[c] || c);
        }
    }

    return r;
}


/**
  * Converts string to XML data.
  * @param String str: A valid string of XML. If the string is simple text, or
  * that there isn't a single root element, this function returns null. In cases
  * where the string is an invalid but well formatted snippet of XML, this
  * function will close any tags to make for a valid XML document
  * @param boolean trimwhitespace: if true, text nodes have whitespace trimmed from start and end.
  * @param boolean nsprefix: if true, preserve namespace prefixes on node names and attribute names.
  * @return LzDataElement: An LzDataElement which is the top of the hierarchy
  * generated from the string
  */
static function stringToLzData( str:String, trimwhitespace:Boolean=false, nsprefix:Boolean=false ) :LzDataElement {
    if (str != null && str != "") {
        try {
            var nativexml:* = LzXMLParser.parseXML(str, trimwhitespace, nsprefix);
            var lfcnode:LzDataElement = LzXMLTranslator.copyXML(nativexml, trimwhitespace, nsprefix);
            return lfcnode;
        } catch (e) {
            if ($debug) {
                Debug.warn("Cannot parse xml-string '%s': %w", str, e);
            }
            return null;
        }
    }
    return null;
}

/** @type Dictionary
  * @keywords read-only
  * @access private
  */
static const whitespaceChars :Object = {' ': true, '\r': true, '\n': true, '\t': true};


/**
  * trim whitespace from start and end of string
  * @access private
  */
static function trim( str:String ) :String {
    var whitech:Object = LzDataElement.whitespaceChars;
    var len:int = str.length;
    var sindex:int = 0;
    var eindex:int = len - 1;
    var ch:String;
    while (sindex < len) {
        ch = str.charAt(sindex);
        if (whitech[ch] != true) break;
        sindex++;
    }

    while (eindex > sindex) {
        ch = str.charAt(eindex);
        if (whitech[ch] != true) break;
        eindex--;
    }
        
    return str.slice(sindex, eindex + 1);
}


} // End of LzDataElement
lz.DataElement = LzDataElement;  // publish
